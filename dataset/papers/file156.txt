Many learning problems involve inferring properties of temporally extended sequences given an objective function. For instance, in reinforcement learning (RL), the task is to find a policy that maximizes expected future discounted rewards (value). RL algorithms fall into two main classes: (1) model-free algorithms that learn cached value functions directly from sample trajectories, and (2) model-based algorithms that estimate transition and reward functions, from which values can be computed using tree-search or dynamic programming. However, there is a third class, based on the successor representation (SR), that factors the value function into a predictive representation and a reward function. Specifically, the value function at a state can be expressed as the dot product between the vector of expected discounted future state occupancies and the immediate reward in each of those successor states.Representing the value function using the SR has several appealing properties. It combines computa- tional efficiency comparable to model-free algorithms with some of the flexibility of model-based algorithms. In particular, the SR can adapt quickly to changes in distal reward, unlike model-free algorithms. In this paper, we also highlight a feature of the SR that has been less well-investigated: the ability to extract bottleneck states (candidate subgoals) from the successor representation under a random policy [35]. These subgoals can then be used within a hierarchical RL framework. In this paper we develop a powerful function approximation algorithm and architecture for the SR using a deep neural network, which we call Deep Successor Reinforcement Learning (DSR). This enables learning the SR and reward function from raw sensory observations with end-to-end training.   (1) feature branch f θ (CNN) which takes in raw images and computes the features φ st , (2) successor branch u α which computes the SR m st,a for each possible action a ∈ A, (3) a deep convolutional decoder which produces the input reconstructionˆs reconstructionˆ reconstructionˆs t and (4) a linear regressor to predict instantaneous rewards at s t . The Q-value function can be estimated by taking the inner-product of the SR with reward weights:The DSR consists of two sub-components: (1) a reward feature learning component, constructed as a deep neural network, predicts intrinsic and extrinsic rewards to learn useful features from raw observations; and (2) an SR component, constructed as a separate deep neural network, that estimates the expected future "feature occupancy" conditioned on the current state and averaged over all actions. The value function can then be estimated as the dot product between these two factored representations. We train DSR by sampling experience trajectories (state, next-state, action and reward) from an experience replay memory and apply stochastic gradient descent to optimize model parameters. To avoid instability in the learning algorithm, we interleave training of the successor and reward components.We show the efficacy of our approach on two different domains: (1) learning to solve goals in grid-world domains using the MazeBase game engine and (2) learning to navigate a 3D maze to gather a resource using the Doom game engine. We show the empirical convergence results on several policy learning problems as well as sensitivity of the value estimator given distal reward changes. We also demonstrate the possibility of extracting plausible subgoals for hierarchical RL by performing normalized-cuts on the SR [32].The SR has been used in neuroscience as a model for describing different cognitive phenomena. [7] showed that the temporal context model [11], a model of episodic memory, is in fact estimating the SR using the temporal difference algorithm. [3] introduced a model based on SR for preplay and rapid path planning in the CA3 region of the hippocampus. They interpret the SR as an an attractor network in a low-dimensional space and show that if the network is stimulated with a goal location it can generate a path to the goal. [35] suggested a model for tying the problems of navigation and reward maximization in the brain. They claimed that the brain's spatial representations are designed to support the reward maximization problem (RL); they showed the behavior of the place cells and grid cells can be explained by finding the optimal spatial representation that can support RL. Based on their model they proposed a way for identifying reasonable subgoals from the spectral features of the SR. Other work (see for instance, [2,4]) have also discussed utilizing the SR for subgoal and option discovery.There are also models similar to the SR that have been been applied to other RL-related domains.[31] introduced a model for evaluating the positions in the game of Go; the model is reminiscent of SR as it predicts the fate of every position of the board instead of the overall game score. Another reward-independent model, universal option model (UOM), proposed in [39], uses state occupancy function to build a general model of options. They proved that UOM of an option, given a reward function, can construct a traditional option model. There has also been a lot of work on option discovery in the tabular setting [14,[18][19][20]34]. In more recent work, Machado et al. [17] presented an option discovery algorithm where the agent is encouraged to explore regions that were previously out of reach. However, option discovery where non-linear state approximations are required is still an open problem.Our model is also related to the literature on value function approximation using deep neural networks. The deep-Q learning model [22] and its variants (e.g., [21,24,29,33]) have been successful in learning Q-value functions from high-dimensional complex input states.Consider an MDP with a set of states S, set of actions A, reward function R : S → R, discount factor γ ∈ [0,1], and a transition distribution T : S × A → [0,1]. Given a policy π : S × A → [0, 1], the Q-value function for selecting action a in state s is defined as the expected future discounted return:where, s t is the state visited at time t and the expectation is with respect to the policy and transition distribution. The agent's goal is to find the optimal policy Q * which follows the Bellman equation:The SR can be used for calculating the Q-value function as follows. Given a state s, action a and future states s , SR is defined as the expected discounted future state occupancy:where 1[.] = 1 when its argument is true and zero otherwise. This implicitly captures the state visitation count. Similar to the Bellman equation for the Q-value function (Eq. 2), we can express the SR in a recursive form:Given the SR, the Q-value for selecting action a in state s can be expressed as the inner product of the immediate reward and the SR [5]:s ∈SFor large state spaces, representing and learning the SR can become intractable; hence, we appeal to non-linear function approximation. We represent each state s by a D-dimensional feature vector φ s which is the output of a deep neural network f θ : S → R D parameterized by θ.For a feature vector φ s , we define a feature-based SR as the expected future occupancy of the features and denote it by m sa . We approximate m sa by another deep neural network u α parameterized by α: m sa ≈ u α (φ s , a). We also approximate the immediate reward for state s as a linear function of the feature vector φ S : R(s) ≈ φ s · w, where w ∈ R D is a weight vector. Since reward values can be sparse, we can also train an intrinsic reward predictor R i (s) = g ˜ θ (φ s ). A good intrinsic reward channel should give dense feedback signal and provide features that preserve latent factors of variations in the data (e.g. deep generative models that do reconstruction). Putting these two pieces together, the Q-value function can be approximated as (see 4 for closed form):The SR for the optimal policy in the non-linear function approximation case can then be obtained from the following Bellman equation:where a = argmax a m st+1a · w.The parameters (θ, α, w, ˜ θ) can be learned online through stochastic gradient descent.The loss function for α is given by:where a = argmax a u α (φ st+1 , a) · w and the parameter α prev denotes a previously cached parameter value, set periodically to α. This is essential for stable Q-learning with function approximations (see [22]).For learning w, the weights for the reward approximation function, we use the following squared loss function:Parameter θ is used for obtaining the φ(s), the shared feature representation for both reward prediction and SR approximation. An ideal φ(s) should be: 1) a good predictor for the immediate reward for that state and 2) a good discriminator for the states. The first condition can be handled by minimizing loss function L r t ; however, we also need a loss function to help in the second condition. To this end, we use a deep convolutional auto-encoder to reconstruct images under an L2 loss function. This dense feedback signal can be interpreted as an intrinsic reward function. The loss function can be stated as:The composite loss function is the sum of the three loss functions given above:For optimizing Eq. 9, with respect to the parameters (θ, α, w, ˜ θ), we iteratively update α and (θ, w, ˜ θ). That is, we learn a feature representation by minimizing L, we find the optimal α * . This iteration is important to ensure that the successor branch does not back-propagate gradients to affect θ. We use experience replay memory D of size 1e 6 to store transitions, and apply stochastic gradient descent with a learning rate of 2.5e −4 , momentum of 0.95, a discount factor of 0.99 and the exploration parameter annealed from 1 to 0.1 as training progresses. Algorithm 1 highlights the learning algorithm in greater detail.Learning policies given sparse or delayed rewards is a significant challenge for current reinforcement learning algorithms. This is mainly due to inefficient exploration schemes such as Existing methods like Boltzmann exploration and Thomson sampling [26,36] offer significant improvements over but are limited due to the underlying models functioning at the level of basic actions. Hierarchical reinforcement learning algorithms [1] such as the options framework [38,39] provide a flexible framework to create temporal abstractions, which will enable exploration at different time-scales. The agent will learn options to reach the subgoals which can be used for intrinsic motivation. In the context of hierarchical RL, [8] discuss a framework for subgoal extraction using the structural aspects of a learned policy model. Inspired by previous work in subgoal discovery from while not terminal do 5:With probability sample a random action a, otherwise choose argmax a u α (φ s , a) · wExecute a and obtain next state s and reward R(s ) from environment 8:Randomly sample mini-batches from DPerform gradient descent on the loss L r (w, θ) + L a ( ˜ θ, θ) with respect to w, θ and˜θand˜ and˜θ.Fix (θ, ˜ θ, w) and perform gradient descent on L m (α, θ) with respect to α.s ← send while 14:Anneal exploration variable 15: end for state trajectories [34] and the tabular SR [35], we use the learned SR to generate plausible subgoal candidates.Given a random policy π r ( = 1), we train the DSR until convergence and collect the SR for a large number of states T = {m s1,a1 , m s2,a2 , ..., m sn,an }. Following [32,34], we generate an affinity matrix W given T , by applying a radial basis function (with Euclidean distance metric) for each pairwise entry (m si,ai , m sj ,aj ) in T (to generate w ij ). Let D be a diagonal matrix with D(i, i) = j w ij . Then as per [32], the second largest eigenvalue of the matrixgives an approximation of the minimum normalized cut value of the partition of T . The states that lie on the end-points of the cut are plausible subgoal candidates, as they provide a path between a community of state groups. Given randomly sampled T from π r , we can collect statistics of how many times a particular state lies along the cut. We pick the top-k states as the subgoals. Our experiments indicate that it is possible to extract useful subgoals from the DSR.In this section, we demonstrate the properties of our approach on MazeBase [37], a grid-world environment, and the Doom game engine [13]. In both environments, observations are presented as raw pixels to the agent. In the first experiment we show that our approach is comparable to DQN in two goal-reaching tasks. Next, we investigate the effect of modifying the distal reward on the initial Q-value. Finally, using normalized-cuts, we identify subgoals given the successor representations in the two environments.Solving a maze in MazeBase We learn the optimal policy in the maze shown in Figure 2 using the DSR and compare its performance to the DQN [22]. The cost of living or moving over water blocks is -0.5 and the reward value is 1. For this experiment, we set the discount rate to 0.99 and the learning rate to 2.5 · 10 −4 . We anneal the from 1 to 0.1 over 20k steps; furthermore, for training the reward branch, we anneal the number of samples that we use, from 4000 to 1 by a factor of 0.5 after each training episode. For all experiments, we prioritize the reward training by keeping a database of non-zero rewards and sampling randomly from the replay buffer with a 0.8 probability and 0.2 from the database. Figure 3 shows the average trajectory (over 5 runs) of the rewards obtained over 100k episodes. As the plot suggests, DSR performs on par with DQN.Finding a goal in a 3D environment We created a map with 4 rooms using the ViZDoom plat- form [13]. The map is shown in Figure 2. We share the same network architecture as in the case of MazeBase. The agent is spawned inside a room, and can explore any of the other three rooms. The agent gets a per-step penalty of -0.01 and a positive reward of 1.0 after collecting an item from one Figure 2: Environments: (left) MazeBase [37] map where the agent starts at an arbitrary location and needs to get to the goal state. The agent gets a penalty of -0.5 per-step, -1 to step on the water-block (blue) and +1 for reaching the goal state. The model observes raw pixel images during learning. (center) A Doom map using the VizDoom engine [13] where the agent starts in a room and has to get to another room to collect ammo (per-step penalty = -0.01, reward for reaching goal = +1). (right) Sample screen-shots of the agent exploring the 3D maze. Steps ( × 1000)   Figure 2. After convergence, we change the value of the distal reward and update the Q-value for the optimal action at the origin (bottom-left corner of the maze). In order for the value function to converge again, the model only needs to update the linear weights w given the new external rewards.The decomposition of value function into SR and immediate reward prediction allows DSR to rapidly adapt to changes in the reward function. In order to probe this, we performed experiments to measure the adaptability of the value function to distal reward changes. Given the grid-world map in Figure2, we can train the agent to solve the goal specified in the map as highlighted in section 5.1. Without changing the goal location, we can change the reward scalar value upon reaching the goal from 1.0 to 3.0. Our hypothesis is that due to the SR-based value decomposition, our value estimate will converge to this change by just updating the reward weights w (SR remains same). As shown in Figure 4, we confirm that the DSR is able to quickly adapt to the new value function by just updating w.Following section 4, we can also extract subgoals from the SR. We collect T by running a ran- dom policy on both MazeBase and VizDoom. During learning, we only update SR (u α ) and the reconstruction branch (g ˜ θ ), as the immediate reward at any state is zero (due to random policy). As shown in Figures 5 and 6, our subgoal extraction scheme is able to capture useful subgoals and clusters the environment into reasonable segments. Such a scheme can be ran periodically within a hierarchical reinforcement learning framework to aid exploration. One inherent limitation of this approach is that due to the random policy, the subgoal candidates are often quite noisy. Future work should address this limitation and provide statistically robust ways to extract plausible candidates. Additionally, the subgoal extraction algorithm should be non-parametric to handle flexible number of subgoals.(a) (b) Figure 5: Subgoal extraction on grid-world: Given a random policy, we train DSR until conver- gence and collect a large number of sample transitions and their corresponding successor representa- tions as described in section 4. We apply a normalized cut-based algorithm on the SRs to obtain a partition of the environment as well as the bottleneck states (which correspond to goals) (a) Subgoals are states which separate different partitions of the environments under the normalized-cut algorithm. Our approach is able to find reasonable subgoal candidates. (b) Partitions of the environment reflect latent structure in the environment.We presented the DSR, a novel deep reinforcement learning framework to learn goal-directed behavior given raw sensory observations. The DSR estimates the value function by taking the inner product between the SR and immediate reward predictions. This factorization of the value function gives rise to several appealing properties over existing deep reinforcement learning methods-namely increased sensitivity of the value function to distal reward changes and the possibility of extracting subgoals from the SR under a random policy.For future work, we plan to combine the DSR with hierarchical reinforcement learning. Learning goal- directed behavior with sparse rewards is a fundamental challenge for existing reinforcement learning algorithms. The DSR can enable efficient exploration by periodically extracting subgoals, learning policies to satisfy these intrinsic goals (skills), and subsequently learning hierarchical policy over these subgoals in an options framework [15,28,39]. One of the major issues with the DSR is learning discriminative features. In order to scale up our approach to more expressive environments, it will be crucial to combine various deep generative and self-supervised models [6,9,10,12,16,25,27,40] Figure 6: Subgoal extraction on the Doom map The subgoals are extracted using the normalized cut-based algorithm on the SR. The SR samples are collected based on a random policy. The subgoals mostly correspond to the rooms' entrances in the common area between the rooms. Due to random policy, we sometimes observe high variance in the subgoal quality. Future work should address robust statistical techniques to obtain subgoals, as well as non-parametric approaches to obtaining flexible number of subgoals.with our approach. In addition to subgoals, using DSR for extracting other intrinsic motivation measures such as improvements to the predictive world model [30] or mutual information [23] is worth pursuing.
