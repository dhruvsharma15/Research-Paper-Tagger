Dialogue systems and conversational agents -including chatbots, personal assistants and voice- control interfaces -are becoming ubiquitous in modern society. Examples of these include personal assistants on mobile devices, technical support help over telephone lines, as well as online bots selling anything from fashion clothes and cosmetics to legal advice and self-help therapy. However, building intelligent conversational agents remains a major unsolved problem in artificial intelligence research.In 2016, Amazon.com Inc proposed an international university competition with the goal of building a socialbot: a spoken conversational agent capable of conversing coherently and engagingly with humans on popular topics, such as entertainment, fashion, politics, sports, and technology. The socialbot converses through natural language speech through Amazon's Echo device (Stone &amp; Soper 2014). This article describes the models, experiments and final system (MILABOT) developed by our team at University of Montreal. 3 Our main motivation for participating has been to help advance artificial intelligence research. To this end, the competition has provided a special opportunity for training and testing state-of-the-art machine learning algorithms with real users (also known as machine learning in the wild) in a relatively unconstrained setting. The ability to experiment with real users is unique in the artificial intelligence community, where the vast majority of work consists of experiments on fixed datasets (e.g. labeled datasets) and software simulations (e.g. game engines). In addition, the computational resources, technical support and financial support provided by Amazon has helped scale up our system and test the limits of state-of-the-art machine learning methods. Among other things, this support has enabled us to crowdsource 200, 000 labels on Amazon Mechanical Turk and to maintain over 32 dedicated Tesla K80 GPUs for running our live system. Our socialbot is based on a large-scale ensemble system leveraging deep learning and reinforcement learning. We develop a new set of deep learning models for natural language retrieval and generation -including recurrent neural networks, sequence-to-sequence models and latent variable models - and evaluate them in the context of the competition. These models are combined into an ensemble, which generates a candidate set of dialogue responses. Further, we apply reinforcement learning - including value function and policy gradient methods -to train the system to select an appropriate response from the models in its ensemble. In particular, we propose a novel reinforcement learning procedure, based on estimating a Markov decision process. Training is carried out on crowdsourced data and on interactions recorded between real-world users and a preliminary version of the system. The trained systems yield substantial improvements in A/B testing experiments with real-world users.In the competition semi-finals, our best performing system reached an average user score of 3.15 on a scale 1 − 5, with a minimal number of hand-crafted states and rules and without engaging in non-conversational activities (such as playing games or taking quizzes). 4 The performance of this best system is substantially better than the average of all the teams in the competition semi-finals. Further, the same system averaged a high 14.5 − 16.0 turns per dialogue, which is also significantly higher than the average of all the teams in the competition semi-finals, as well as the finalist teams. This improvement in back-and-forth exchanges between the user and system suggests that our system is likely to be the most engaging system among all systems in the competition. Finally, the system is bound to improve with additional data, as nearly all system components are learnable.Early work on dialogue systems (Weizenbaum 1966, Colby 1981, Aust et al. 1995, McGlashan et al. 1992, Simpson &amp; Eraser 1993 were based mainly on states and rules hand-crafted by human experts. Modern dialogue systems typically follow a hybrid architecture, combining hand-crafted states and rules with statistical machine learning algorithms ( Suendermann-Oeft et al. 2015, Jurčíček et al. 2014, Bohus et al. 2007, Williams 2011). Due to the complexity of human language, however, it will probably never be possible to enumerate states and rules required for building a socialbot capable of conversing with humans on open-domain, popular topics. In contrast to such rule-based systems, our core approach is built entirely on statistical machine learning. We believe that this is the most plausible path to artificially intelligent conversational agents. The system architecture we propose aims to make as few assumptions as possible about the process of understanding and generating natural human language. As such, the system utilizes only a small number of hand-crafted states and rules. However, every system component has been designed to be optimized (trained) using machine learning algorithms. These system components will be trained first independently on massive datasets and then jointly on real-world user interactions. This way, the system will learn all relevant states and rules for conducting open-domain conversations implicitly. Given an adequate amount of examples, such a system should outperform systems based on hand-crafted states and rules. Further, the system will continue to improve in perpetuity with additional data.Our system architecture is inspired by the success of ensemble-based machine learning systems. These systems consist of many independent sub-models combined intelligently together. Examples of such ensemble systems include the winner of the Netflix Prize ( Koren et al. 2009), utilizing hundreds of machine learning models to predict user movie preferences, and IBM Watson (Ferrucci et al. 2010), the first machine learning system to win the quiz game Jeopardy! in 2011. More recently, Google observed substantial improvements building an ensemble-based neural machine translation system ( Wu et al. 2016).Our system consists of an ensemble of response models. The response models take as input a dialogue and output a response in natural language text. In addition, the response models may also output one or several scalar values, indicating their internal confidence. As will be explained later, the response models have been engineered to generate responses on a diverse set of topics using a variety of strategies. The dialogue manager is responsible for combining the response models together. As input, the dialogue manager expects to be given a dialogue history (i.e. all utterances recorded in the dialogue so far, including the current user utterance) and confidence values of the automatic speech recognition system (ASR confidences). To generate a response, the dialogue manager follows a three-step procedure. First, it uses all response models to generate a set of candidate responses. Second, if there exists a priority response in the set of candidate responses (i.e. a response which takes precedence over other responses), this response will be returned by the system. 5 For example, for the question "What is your name?", the response "I am an Alexa Prize socialbot" is a priority response. Third, if there are no priority responses, the response is selected by the model selection policy. For example, the model selection policy may select a response by scoring all candidate responses and picking the highest-scored response. The overall process is illustrated in Figure 1.When the ASR confidences are below a certain threshold, the system requests the user to repeat their last utterance. Otherwise, the system does not utilize the ASR confidences. In particular, neither the response models nor the model selection policy make use of the ASR confidences. Nevertheless, the ASR system is far from perfect. Therefore, it is very plausible that the system could be improved significantly by conditioning the response models and model selection policy on the ASR confidences.There are 22 response models in the system, including retrieval-based neural networks, generation- based neural networks, knowledge base question answering systems and template-based systems. Examples of candidate model responses are shown in Table 1. This section aims to summarize these response models. First, the template-based models are described.We start by describing the template-based response models in the system.Alicebot: Alicebot uses a set of AIML (artificial intelligence markup language) templates to produce a response given the dialogue history and user utterance ( Wallace 2009, Shawar &amp; Atwell 2007. We use the freely available Alice kernel available at www.alicebot.org. By default all templates generate non-priority responses, so we configure templates related to the socialbot's name, age and location to output priority responses. We modify a few templates further to make them consistent with the challenge (e.g. to avoid obscene language and to encourage the user to discuss certain topics, such as news, politics and movies). The majority of templates remain unchanged.The Alicebot model also outputs a scalar confidence score. Since the AIML templates repeat the user's input utterance, they are not always correct sentences. Therefore, we use a string-based rules to deter- mine if the response constitutes a correct sentence. If the response is correct sentence, it returns a high confidence and otherwise it returns a low confidence score. This process is illustrated in Algorithm 1.1 input: dialogue history 2 response ← apply AIML templates to dialogue history 3 if response is correct sentence then 4 if response is given priority then Elizabot Similar to Alicebot, the Elizabot model performs string matching to select an answer from a set of templates. The model is based on the famous Eliza system, designed to mimic a Rogerian psychotherapist. (Weizenbaum 1966). 6 Therefore, in contrast with Alicebot, most of Elizabot's responses are personal questions which are meant to engage the user to continue the conversation.Here are two example templates:1. "I am (.*)" → "Did you come to me because you are ..."2. "What (.*)" → "Why do you ask?"The ellipses mark the parts of the response sentence which will be replaced with text from the user's utterance. The model detects the appropriate template and selects the corresponding response (if there are multiple templates, then a template is selected at random). The model then runs the template response through a set of reflections to better format the string for a response (e.g. "I'd" → "you would", "your" → "my").1 input: dialogue history 2 if Initiatorbot was triggered in one of last two turns then 3 return "" 4 else if user did not give a greeting then 5 return a non-priority response with a random initiator phrase 6 else 7 return a priority response with a random initiator phrase Initiatorbot The Initiatorbot model acts as a conversation starter: it asks the user an open-ended question to get the conversation started and increase the engagement of the user. We wrote 40 question phrases for the Initiatorbot. Examples of phrases include "What did you do today?", "Do you have pets?" and "What kind of news stories interest you the most?". As a special case, the model can also start the conversation by stating an interesting fact. In this case, the initiator phrase is "Did you know that &lt;fact&gt;?", where fact is replaced by a statement. The set of facts is the same as used by the BoWFactGenerator model, described later.Before returning a response, Initiatorbot first checks that it hasn't already been triggered in the last two turns of the conversation. If the user gives a greeting (e.g. "hi"), then Initiatorbot will return a response with priority. This is important because we observed that greetings often indicate the beginning of a conversation, where the user does not have a particular topic they would like to talk about. By asking a question, the system takes the initiative (i.e. control of the dialogue). The procedure is detailed in Algorithm 2.The Storybot model outputs a short fiction story at the request of the user. We implemented this model as we observed that many users were asking the socialbot to tell stories. 7 Storybot determines if the user requested a story by checking if there was both a request word (e.g. say, tell.) and story-type word in the utterance (e.g. story, tale). The response states the story's title and author followed by the story body. For example, one set of responses from this model follows the pattern "Alright, let me tell you the story &lt;story_title&gt; &lt;story_body&gt; by &lt;story_author&gt;" where &lt;story_title&gt; is the title of the story, &lt;story_body&gt; is the main text and &lt;story_author&gt; is the name of the story's author. The stories were scraped from the website: www.english-for-students.com.** The Ant and The Grasshopper ** The ants worked hard in summer. They sorted food for winter. At that time, a grasshopper remained idle. When winter came, the ants had enough to eat. But, the grasshopper had nothing to eat. He had to starve. He went to the ants and begged for foods. The ants asked in return, "What did you do in summer?" He replied, "I idled away my time during summer". The ant replied, "Then you must starve in winter." MORAL: Never be idle.The Storybot is the only component in the system performing a non-conversational activity. It is triggered only when a user specifically asks for a story, and in that case its response is a priority response. Otherwise, the Storybot response model is never triggered. Further, the rest of the system will not encourage the user to request stories.Evibot The Evibot response model forwards the user's utterance to Amazon's question-answering web-service Evi: www.evi.com. Evi was designed primarily to handle factual questions. There- fore, Evibot returns a priority response for direct questions, defined as user utterances contain- ing a wh-word (e.g. "who", "what"), and otherwise returns a non-priority or, possibly, an empty response. If the query is a direct question and contains non-stop words, Evibot will follow a three step procedure to generate its response. First, Evibot forwards a query to www.evi.com containing the whole user utterance, and returns the resulting answer if its valid. If that fails, Evibot applies NLTK's named entity processor ( Bird et al. 2009) to the query to find sub- queries with named entities. For each subphrase that contains a named entity, Evibot forwards queries to www.evi.com, and returns the result upon a valid response. Finally, if the previ- ous two steps fail, Evibot forwards queries for every subquery without named entities, and re- turns either a valid response or an empty response. The procedure is detailed in Algorithm 3.1 input: dialogue history 2 query ← last user utterance 3 has-wh-words ← true if utterance contains a wh-word, otherwise false 4 has-only-stop-words ← true if utterance only has stop words, otherwise false 5 if has-only-stop-words and not has-wh-words then 6 return "" 7 evi-response ← send query to www.evi.com 8 priority ← true if has-wh-words and evi-response is valid, otherwise false 9 if evi-response is valid then 10 return evi-response, priority 11  return "" BoWMovies The BoWMovies model is a template-based response model, which handles questions in the movie domain. The model has a list of entity names and tags (e.g. movie plot and release year).The model searches the user's utterance for known entities and tags. Entities are identified by string matching. This is done in a cascading order, by giving first preference to movie title matches, then actor name matches, and finally director name matches. Tags are also identified by string matching. However, if exact string matching fails for tags, then identification is performed by word embedding similarity. If both an entity and a tag are present, the agent will dispatch an API call to one of several data sources to retrieve the data item for the selected query type. The agent is limited by the data available in the APIs to which it has access. The model's responses follow predefined templates.Movie titles, actor names, and director names are extracted from the Internet Movie Database (IMDB). Movie descriptions are taken from Google Knowledge Graph's API. Other movie title queries are directed to the Open Movie Database (OMDB).8 For actor and director queries, the Wikiedata API is used. First, a search for actor and director names is done on a Wikidata JSON dump.As described earlier, the model uses word embeddings to match tags. These word embeddings are trained using Word2Vec on movie plot summaries and actor biographies extracted from the IMDB database ( Mikolov et al. 2013).1 input: dialogue history 2 entity ← entity contained both in last user utterance and list of movie titles, actors or directors 3 if no entity then 4 entity ← entity contained in previous user utterances and movie titles, actors or directors 5 if no entity then 6 return "" 7 if entity is a movie title then 8 response ← ComputeEntityResponse(entity, movie title) 9 else if entity is an actor name then 10 response ← ComputeEntityResponse(entity, actor name) 11 else if entity is an director name then 12 response ← ComputeEntityResponse(entity, director name) 13 return response Algorithm 5: BoWMovies -ComputeEntityResponse 1 input: entity and entity type 2 tag ← string matching tag, where tag is valid for entity type (movie title, actor name, director name) 3 if no tag then 4 tag ← word embedding matching tag, where tag is a single word and valid for the entity type (movie title, actor name, director name) 5 if no tag then 6 tag ← word embedding matching tag, where tag is multiple words and valid for the entity type (movie title, actor name, director name) 7 if no tag then 8 return "" 9 api-response ← call external API with query (entity, tag). 10 response ← template with api-response inserted 11 return responseVHRED models: The system contains several VHRED models, sequence-to-sequence models with Gaussian latent variables trained as variational auto-encoders ( Serban et al. 2017, Kingma &amp; Welling 2014, Rezende et al. 2014). The models are trained using the same procedure as Serban et al. (2017). A comparison between VHRED and other generative sequence-to-sequence models is provided by Serban et al. (2016). The trained VHRED models generate candidate responses as follows. First, a set of K model responses are retrieved from a dataset using cosine similarity between the current dialogue history and the dialogue history in the dataset based on bag-of-words TF-IDF Glove word embeddings ( Pennington et al. 2014). 9 An approximation of the log-likelihood for each of the 20 responses is computed by VHRED, and the response with the highest log-likelihood is returned. The system has 4 VHRED models based on datasets scraped from Reddit, one VHRED model based on news articles and one VHRED model based on movie subtitles:• VHREDRedditPolitics trained on https://www.reddit.com/r/politics and extracting responses from all Reddit datasets with K = 10, • VHREDRedditNews trained on Reddit https://www.reddit.com/r/news and extracting responses from all Reddit datasets with K = 20, • VHREDRedditSports trained on Reddit https://www.reddit.com/r/sports and ex- tracting responses from all Reddit datasets with K = 20, • VHREDRedditMovies trained on Reddit https://www.reddit.com/r/movies and ex- tracting responses from all Reddit datasets with K = 20, • VHREDWashingtonPost 10 trained on Reddit https://www.reddit.com/r/politics and extracting responses from user comments to WashingtonPost news articles, and • VHREDSubtitles 11 using the movie subtitles dataset SubTle ( Ameixa et al. 2014) with K = 10.In particular, VHREDRedditPolitics and VHREDWashingtonPost use a different retrieval procedure. These two models use a logistic regression model to score the responses instead of the approximate log-likelihood. The logistic regression model is trained on a set of 7500 Reddit threads and candidate responses annotated by Amazon Mechanical Turk workers on a Likert-type scale 1 − 5. The candidate responses are selected from other Reddit threads according to cosine similarity w.r.t. Glove word embeddings. The label collection and training procedure for the logistic regression model are similar to the procedures described in Section 4. For each response, the logistic regression model takes as input the VHRED log-likelihood score, as well as several other input features, and outputs a scalar-valued score. Even though the logistic regression model did improve the appropriateness of responses selected for Reddit threads, VHREDRedditPolitics is used extremely rarely in the final system (see Section 4). This suggests that training a model to rerank responses based on labeled Reddit threads and responses cannot help improve performance.SkipThought Vector Models: The system contains a SkipThought Vector model ( Kiros et al. 2015) trained on the BookCorpus dataset ( Zhu et al. 2015) and on the SemEval 2014Task 1 (Marelli et al. 2014). The model was trained using the same procedure as Kiros et al. (2015) and is called SkipThoughtBooks.SkipThoughtBooks ensures that the system complies with the Amazon Alexa Prize competition rules. One rule, introduced early in the competition, is that socialbots were not supposed to state their own opinions related to political or religious topics. If a user wishes to discuss such topics, the socialbots should proceed by asking questions or stating facts. SkipThoughtBooks also handles idiosyncratic issues particular to the Alexa platform. For example, many users did not understand the purpose of a socialbot and asked our socialbot to play music. In this case, the system should instruct the user to exit the socialbot application and then play music.SkipThoughtBooks follows a two-step procedure to generate its response. The first step compares the user's last utterance to a set of trigger phrases. If a match is found, the model returns a corresponding priority response. 12 For example, if the user says "What do you think about Donald trump?", the model will return a priority response, such as "Sometimes, truth is stranger than fiction.". A match is found if: 1) the SkipThought Vector model's semantic relatedness score between the user's last utterance and a trigger phrase is above a predefined threshold, and 2) the user's last utterance contains keywords relevant to the trigger phrase. 13 In total, there are 315 trigger phrases (most are paraphrases of each other) and 35 response sets.If the model did not find a match in the first step, it proceeds to the second step. In this step, the model selects its response from among all Reddit dataset responses. As before, a set of K model responses are retrieved using cosine similarity. The model then returns the response with the highest semantic relatedness score.Dual Encoder Models: The system contains two Dual Encoder retrieval models ( Lowe et al. 2015, Lowe, Pow, Serban, Charlin, Liu &amp; Pineau 2017), DualEncoderRedditPolitics and DualEncoderRed- ditNews. Both models are composed of two sequence encoders ENC Q and ENC R with a single 10 For VHREDWashingtonPost, the K responses are extracted based on the cosine similarity between the current dialogue and the news article keywords. K varies depending on the number of user comments within a set of news articles above a certain cosine similarity threshold. 11 For VHREDSubtitles, cosine similarity is computed based on one-hot vectors for each word. 12 Trigger phrases may have multiple responses. In this case, a response is selected at random. 13 Some trigger phrases do not have keywords. In this case, matching is based only on semantic relatedness.LSTM recurrent layer used to encode the dialogue history and a candidate response. The score for a candidate response is computed by a bilinear mapping of the dialogue history embedding and the candidate response embedding as Lowe et al. (2015). The models are trained using the method proposed by (Lowe et al. 2015). In principle, it is also possible to use early stopping based on separate model trained on a domain similar to our target domain ( Lowe et al. 2016). The response with the highest score from a set of K = 50 candidate responses are retrieved using TF-IDF cosine similarity based on Glove word embeddings. The model DualEncoderRedditPolitics is trained on the Reddit https://www.reddit.com/r/politics dataset and extracts responses from all Reddit datasets. The model DualEncoderRedditNews is trained on the Reddit https://www.reddit.com/r/news dataset and extracts responses from all Reddit datasets.Bag-of-words Retrieval Models: The system contains three bag-of-words retrieval models based on TF-IDF Glove word embeddings ( Pennington et al. 2014) and Word2Vec embeddings ( Mikolov et al. 2013). 14 Similar to the VHRED models, these models retrieve the response with the highest cosine similarity. The BoWWashingtonPost model retrieves user comments from WashingtonPost news articles using Glove word embeddings. The model BoWTrump retrieves responses from a set of Twitter tweets scraped from Donald Trump's profile: https://twitter.com/realDonaldTrump. This model also uses Glove word embeddings and it only returns a response when at least one relevant keyword or phrase is found in the user's utterance (e.g. when the word "Trump" is mentioned by the user). The list of trigger keywords and phrases include: 'donald', 'trump', 'potus', 'president of the united states', 'president of the us', 'hillary', 'clinton', 'barack', and 'obama'. The model BoWFactGenerator retrieves responses from a set of about 2500 interesting and fun facts, including facts about animals, geography and history. The model uses Word2Vec word embeddings. The model BoWGameofThrones retrieves responses from a set of quotes scraped from https://twitter.com/ ThroneQuotes using Glove word embeddings. Tweets from this source were manually inspected and cleaned to remove any tweets that were not quotes from the series. As in the BoWTrump model, we use a list of trigger phrases to determine if the model's output is relevant to the user's utterance. We populate this list with around 80 popular character names, place names and family names, which are large unique to the domain. We also added a few aliases to try and account for alternative speech transcriptions of these named entities. Some phrases include: 'ned stark', 'jon snow', 'john snow', 'samwell tarly', "hodor", "dothraki" and so on. 15 BoWEscapePlan: The system contains a response model, called BoWEscapePlan, which returns a response from a set of 35 topic-independent, generic pre-defined responses, such as "Could you repeat that again", "I don't know" and "Was that a question?". Its main purpose is to maintain user engagement and keep the conversation going, when other models are unable to provide meaningful responses. This model uses a logistic regression classifier to select its response based on a set of higher-level features.To train the logistic regression classifier, we annotated 12, 000 user utterances and candidate response pairs for appropriateness on a Likert-type scale 1 − 5. The user utterances were extracted from interactions between Alexa users and a preliminary version of the system. The candidate responses were sampled at random from BoWEscapePlan's response list. The label collection and training procedure for the logistic regression model are similar to the procedures described in Section 4. The logistic regression model is trained with log-likelihood on a training set, with early-stopping on a development set, and evaluated on the testing set. However, the trained model's performance was poor. It obtained a Pearson correlation coefficient of 0.05 and a Spearman's rank correlation coefficient of 0.07. This indicates that the logistic regression model is only slightly better at selecting a topic-independent, generic response compared to selecting a response at uniform random. Future work should investigate collecting more labeled data and pre-training the logistic regression model.The system contains a deep classifier model, called LSTMClassifierMSMarco, which chooses its response from a set of search engine results. The system searches the web with the last user utterance as query, and retrieves the first 10 search snippets. The retrieved snippets are preprocessed by stripping trailing words, removing unnecessary punctuation and truncating to the last full sentence. The model uses a bidirectional LSTM to separately map the last dialogue utterance and the snippet to their own embedding vectors. The resulting two representations are concatenated and passed through an MLP to predict a scalar-value between 0 − 1 indicating how appropriate the snippet is as a response to the utterance.The model is trained as a binary classification model on the Microsoft Marco dataset with cross- entropy to predict the relevancy of a snippet given a user query ( Nguyen et al. 2016). Given a search query and a search snippet, the model must output one when the search snippet is relevant and otherwise zero. Search queries and ground truth search snippets are taken as positive samples, while other search snippets are selected at random as negative samples. On this task, the model is able to reach a prediction accuracy of 72.96% w.r.t. the Microsoft Marco development set.The system is able to use search APIs from various search engines including Google, Bing, and AIFounded (Im 2017). In the current model, we choose Google as the search engine, since qualitative inspection showed that this retrieved the most appropriate responses.The system contains a generative recurrent neural network language model, called GRUQuestion- Generator, which can generate follow-up questions word-by-word, conditioned on the dialogue history. The input to the model consists of three components: a one-hot vector of the current word, a binary question label and a binary speaker label. The model contains two GRU layers ( Cho et al. 2014) and softmax output layer. The model is trained on Reddit Politics and Reddit News conversa- tions, wherein posts were labeled as questions by detecting question marks. We use the optimizer Adam (Kingma &amp; Ba 2015), and perform early stopping by checking the perplexity on the validation set For generation, we first condition the model on a short question template (e.g. "How about", "What about", "How do you think of", "What is your opinion of"), and then generate the rest of the question by sampling from the model with the question label clamped to one. The generation procedure stops once a question mark is detected. Further, the length of the question is controlled by tuning the temperature of the softmax layer. Due to speed requirements, only two candidate responses are generated and the best one w.r.t. log-likelihood of the first 10 words is returned.After generating the candidate response set, the dialogue manager uses a model selection policy to select the response it returns to the user. The dialogue manager must select a response which increases the satisfaction of the user for the entire dialogue. It must make a trade-off between immediate and long-term user satisfaction. For example, suppose the user asks to talk about politics. If the dialogue manager chooses to respond with a political joke, the user may be pleased for one turn. Afterwards, however, the user may be disappointed with the system's inability to debate political topics. Instead, if the dialogue manager chooses to respond with a short news story, the user may be less pleased for one turn. However, the news story may influence the user to follow up with factual questions, which the system may be better adept at handling. To make the trade-off between immediate and long-term user satisfaction, we consider selecting the appropriate response as a sequential decision making problem. This section describes five approaches to learn the model selection policy. These approaches are all evaluated with real-world users in the next section.We use the reinforcement learning framework (Sutton &amp; Barto 1998). The dialogue manager is an agent, which takes actions in an environment in order to maximize rewards. For each time step t = 1, . . . , T , the agent observes the dialogue history h t and must choose one of K actions (responses): a 1 t , . . . , a K t . After taking an action, the agent receives a reward r t and is transferred to the next state h t+1 (which includes the user's next response). Then, the agent is provided with a new set of K actions: a 1 t+1 , . . . , a K t+1 . The agent's goal is to maximize the discounted sum of rewards:t=1 which is referred to as the expected cumulative return (or simply expected return). The parameterAn issue specific to our setting is that the set of actions changes depending on the state (dialogue history). This happens because the candidate responses are generated by response models, which also depend on the dialogue history. In addition, the response models are not deterministic. This means the set of candidate responses is likely to be different every time the agent encounters the same state h t . 16 This is in contrast to certain reinforcement learning problems, such as learning to play Atari 2600 games, where the set of actions is fixed given the state. To simplify notation, we will fix the number of actions to K henceforth.Action-value Parametrization: We use two different approaches to parametrize the agent's policy. The first approach is based on an action-value function, defined by parameters θ:which estimates expected return of taking action a k t (candidate response k) given dialogue history h t and given that the agent will continue to use the same policy afterwards. Given Q θ , the agent chooses the action with highest expected return:The use of an action-value function for selecting dialogue responses is closely related to the recent work by Lowe, Noseworthy, Serban, Angelard-Gontier, , where a model is learned to predict the quality of a dialogue system response. However, in our case, Q θ is only conditioned on the dialogue context. On the other hand, the model proposed by Lowe, Noseworthy, Serban, Angelard-Gontier, Bengio &amp; Pineau (2017) is conditioned both on the dialogue context and on a human reference response. The action-value function is also related to the the work by Yu et al. (2016), who learn an evaluation model, which is used to train a reinforcement learning agent to select appropriate dialogue response strategies.Stochastic Policy Parametrization: The second approach instead parameterizes the policy as a discrete distribution over actions. Let θ be the parameters. The agent selects its action by sampling:The next section describes the input features for the scoring model.As input to the scoring model we compute 1458 features based on the given dialogue history and candidate response. The input features are based on a combination of word embeddings, dialogue acts, part-of-speech tags, unigram word overlap, bigram word overlap and model-specific features:Word embeddings of response: Average of candidate response word embed- dings ( Mikolov et al. 2013).Word embeddings of last user utterance: Average of the last user utterance word embeddings. Word embeddings of context: Average of the word embeddings of the last six utter- ances in dialogue context. Word embedding of user context:Average of the word embeddings of the last three user utterances in dialogue context. Word embedding similarity metrics:The Embedding Average, Embedding Extrema and Embedding Greedy similarity metrics described by Liu et al. (2016). Each similarity metric is computed between 1) the last user utterance and candidate re- sponse, 2) the last six utterances in the dialogue and candidate response, 3) the last three user utterances in the dialogue and candidate response, 4) the last six utterances in the dialogue and candidate response with stop-words removed, and 5) the last three user utterances in the dialogue and candidate response with stop-words removed. Response model class:A one-hot vector with size equal to the number of response models, where entry i is equal to 1.0 when candidate response was generated by the model class with index i. Part-of-speech response class:The part-of-speech tags for candidate response is es- timated using a maximum entropy tagger trained on the Penn Treebank corpus. The sequence of part-of- speech tags is then mapped to a one-hot vector, which constitutes the input feature. Dialogue act response model class:The outer-product between a one-hot vector represent- ing the dialogue act (we consider 10 types of dialogue acts) and a one-hot vector for indicating the model class (Stolcke et al. 2000). Word overlap:1.0 when one or more non-stop-words overlap be- tween candidate response and last user utterance, and otherwise zero. Bigram overlap short-term:1.0 when a bigram (two consecutive tokens) exists both in the candidate response and in the last user utterance, and otherwise zero. Bigram overlap long-term:1.0 when a bigram exists both in candidate response and in one of the last utterances in dialogue context, and otherwise zero. Named-entity overlap short-term:1.0 when a named-entity (an upper-cased word, which is not a stop-word) exists both in candidate response and in the last user utterance, and otherwise zero. Named-entity overlap long-term:1.0 when a named-entity exists both in candidate re- sponse and in one of the last utterances in dialogue context, and otherwise zero. Generic response:1.0 when candidate response consists of only stop- words or words shorter than 3 characters, and other- wise zero. Wh-word response feature:1.0 when candidate response contains a wh-word (e.g. what, where, and so on), and otherwise zero. Wh-word context:1.0 when last user utterance contains a wh-word, and otherwise zero. Intensifier word response:1.0 when candidate response contains an intensifier word (e.g. amazingly, crazy, and so on), and otherwise zero.Intensifier word context:1.0 when last user utterance contains an intensifier word, and otherwise zero.Unigram response: A set of binary features which are 1.0 when candidate response contains a specific word (including the words I, you and thanks), and otherwise zero.Negation response:1.0 when candidate response contains a negation word, such as not or n't, and otherwise zero.Non-stop-words response:1.0 when candidate response contains a non-stop- word, and otherwise zero.We do not include features based on the confidences of the speech recognition system, for experimental reasons. Speech recognition errors are a confounding factor in experiments with real-world users. Speech recognition errors are likely to affect user satisfaction. If features based on speech recognition confidences were included, one policy might learn to handle speech recognition errors better than another policy. In turn, this could make that policy perform better w.r.t. overall user satisfaction. However, that would be an effect caused by the imperfect speech recognition system, and would not reflect user satisfaction under a perfect speech recognition system. Excluding these features as input to the scoring model helps minimize this confounding effect.Nevertheless, even if these features are excluded, it should be noted that speech recognition errors still constitute a substantial confounding factor in our later experiments. Lastly, for the same reasons, none of the response models utilize speech recognition confidences.In principle, it is possible to compute input features by encoding the dialogue context and candi- date response using Recurrent Neural Networks (RNNs) or Convolutional Neural Networks (Con- vNets) ( Socher et al. 2013, Cho et al. 2014, Yu et al. 2014).However, these models are known to require training on large corpora in order to achieve acceptable performance, which we do not have access to. In addition, we need to keep the scoring model's execution time under 150ms. Otherwise, the slowdown in the response time, could frustrate the user and lower the overall user satisfaction. This rules out large RNNs and ConvNets for the Amazon Alexa Prize competition, since these would require more computational runtime. However, future dialogue systems utilizing larger datasets should consider large-scale models.This section describes the scoring model's architecture. The scoring model is a five-layered neural network. The first layer is the input, consisting of the 1458 features, described in the previous section. The second layer contains 500 hidden units, computed by applying a linear transformation followed by the rectified linear activation function (Nair &amp; Hinton 2010, Glorot et al. 2011) to the input layer units. The third layer contains 20 hidden units, computed by applying a linear transformation to the preceding layer units. Similar to matrix factorization, this layer compresses the 500 hidden units down to 20 hidden units. The fourth layer contains 5 outputs units, which are probabilities (i.e. all values are positive and sum to one). These output units are computed by applying a linear transformation to the preceding layer units followed by a softmax transformation. This layer corresponds to the Amazon Mechanical Turk labels, which will be described in the next sub-section. The fifth layer is the final output scalar, computed by applying a linear transformation to the units in the third and fourth layers. The model is illustrated in Figure 2.Before settling on this architecture, we experimented both with deeper and more shallow models. However, we found that both the deeper models and the more shallow models performed worse. Nevertheless, future work should explore alternative architectures.We use five different machine learning approaches to learn the scoring model. These are described next.This section describes the first approach to learning the scoring model, which is based on estimating the action-value function using supervised learning on crowdsourced labels. This approach also serves as initialization for the approaches discussed later. Crowdsourcing: We use Amazon Mechanical Turk (AMT) to collect data for training the scoring model. We follow a setup similar to Liu et al. (2016). We show human evaluators a dialogue along with 4 candidate responses, and ask them to score how appropriate each candidate response is on a 1-5 Likert-type scale. The score 1 indicates that the response is inappropriate or does not make sense, 3 indicates that the response is acceptable, and 5 indicates that the response is excellent and highly appropriate.Our setup only asks human evaluators to rate the overall appropriateness of the candidate responses.In principle, we could choose to evaluate other aspects of the candidate responses. For example, we could evaluate fluency. However, fluency ratings would not be very useful since most of our models retrieve their responses from existing corpora, which contain mainly fluent and grammatically correct responses. As another example, we could evaluate topical relevancy. However, we choose not to evaluate such criteria since it is known to be difficult to reach high inter-annotator agreement on them ( Liu et al. 2016). In fact, it is well known that even asking for a single overall rating tends to produce only a fair agreement between human evaluators ( Charras et al. 2016); disagreement between annotators tends to arise either when the dialogue context is short and ambiguous, or when the candidate response is only partially relevant and acceptable.The dialogues are extracted from interactions between Alexa users and preliminary versions of our system. Only dialogues where the system does not have a priority response were extracted (when there is a priority response, the dialogue manager must always return the priority response). About 3/4 of these dialogues were sampled at random, and the remaining 1/4 dialogues were sampled at random excluding identical dialogues. 18 For each dialogue, the corresponding candidate responses are created by generating candidate responses from the response models.We preprocess the dialogues and candidate responses by masking out profanities and swear words with stars (e.g. we map "fuck" to "****"). 19 Furthermore, we anonymize the dialogues and candidate responses by replacing first names with randomly selected gender-neutral names (for example, "Hi John" could be mapped to "Hello Casey"). Finally, the dialogues are truncated to the last 4 utterances and last 500 words. This reduces the cognitive load of the annotators. Examples from the crowdsourcing task are shown in Figure 3, Figure 4 and Figure 5. The dialogue example shown in Figure 5 is a fictitious example.   We inspected the annotations manually. We observed that annotators tended to frequently overrate topic-independent, generic responses. Such responses may be considered acceptable for a single turn in a conversation, but are likely to be detrimental when repeated over and over again. In particular, annotators tended to overrate responses generated by the response models Alicebot, Elizabot, VHREDSubtitles and BoWEscapePlan. Responses generated by these models are often acceptable or good, but the majority of them are topic-independent, generic sentences. Therefore, for these response models, we mapped all labels 5 ("excellent") to 4 ("good"). Furthermore, for responses consisting of only stop-words, we decreased the labels by one level (e.g. 4 is mapped to 3). Finally, the BoWMovies response model suffered from a bug during the label collection period. Therefore, we decreased all labels given to BoWMovies responses to be at most 2 ("poor").In total, we collected 199, 678 labels. We split this into training (train), development (dev) and testing (test) datasets consisting of respectively 137,549, 23,298 and 38,831 labels each.Training: We optimize the scoring model w.r.t. log-likelihood (cross-entropy) to predict the 4th layer, which represents the AMT label classes. Formally, we optimize the parameters θ:where x are the input features, y is the corresponding AMT label class (a one-hot vector) and P θ (y|x) is the model's predicted probability of y given x, computed in the second last layer of the scoring model. We use the first-order gradient-descent optimizer Adam (Kingma &amp; Ba 2015) We experiment with a variety of hyper-parameters, and select the best hyper-parameter combination based on the log-likelihood of the dev set. For the first hidden layer, we experiment with layer sizes in the set: {500, 200, 50}. For the second hidden layer, we experiment with layer sizes in the set: {50, 20, 5}.We use L2 regularization on all model parameters, except for bias parameters. We experiment with L2 regularization coefficients in the set: {10.0, 1.0, 10 −1 , . . . , 10 −9 } Unfortunately, we do not have labels to train the last layer. Therefore, we fix the parameters of the last layer to the vector [1.0, 2.0, 3.0, 4.0, 5.0]. In other words, we assign a score of 1.0 for the label very poor, a score of 2.0 for the label poor, a score of 3.0 for the label acceptable, a score of 4.0 for the label good and a score of 5.0 for the label excellent. As this model was trained on crowdsourced data from Amazon Mechanical Turk (AMT), we call this model Supervised AMT.   Table 2 shows the performance w.r.t. Pearson correlation coefficient, Spearman's rank correlation coefficient and mean squared error. The metrics are computed after linearly transforming the AMT class categories to the scalar output score (i.e. by taking the dot-product between the one-hot class vector and the vector [1.0, 2.0, 3.0, 4.0, 5.0]). The Average Predictor is a baseline model, which always predicts with the average output score. As shown, Supervised AMT achieves a Pearson correlation coefficient of 0.40, a Spearman's rank correlation coefficient of 0.38 and a significant reduction in mean squared error. This indicates Supervised AMT performs significantly better than the baseline. Figure 6 shows the performance w.r.t. each AMT label class. In addition to Supervised AMT, the figure shows the performance of three baseline policies: 1) Random, which selects a response at random, 2) Alicebot, which selects an Alicebot response if available and otherwise selects a response at random, and 3) Evibot + Alicebot, which selects an Evibot response if available and otherwise selects an Alicebot response. For each policy, the figure shows the percentage of responses selected by the policy belonging to a particular AMT label class. In one end of the spectrum, we observe that Supervised AMT has a ~30% point reduction compared to Random in responses belonging to the "very poor" class. For the same AMT label class, Supervised AMT has a reduction of ~10% points compared to Alicebot and Evibot + Alicebot. In the other end of the spectrum, we observe that Supervised AMT performs significantly better than the three baselines w.r.t. the classes "good" and "excellent". In particular, Supervised AMT reaches ~8% responses belonging to the class "excellent". This is more than double compared to all three baseline policies. This demonstrates that Supervised AMT has learned to select "good" and "excellent" responses, while avoiding "very poor" and "poor" responses.Overall, the results show that Supervised AMT improves substantially over all baseline policies. Nevertheless, ~46% of the Supervised AMT responses belong to the classes "very poor" and "poor". This implies that there is ample space for improving both Supervised AMT and the set of candidate responses (i.e. the system's response models).In the first scoring model Supervised AMT we fixed the last output layer weights to [1.0, 2.0, 3.0, 4.0, 5.0]. In other words, we assigned a score of 1.0 for very poor responses, 2.0 for poor responses, 3.0 for acceptable responses, and so on. It's not clear whether this score is correlated with scores given by real-world Alexa users, which is what we ultimately want to optimize the system for. This section describes another approach, which remedies this problem by learning to predict the Alexa user scores based on previously recorded dialogues.Learned Reward Function: Let h t be a dialogue history and let a t be the corresponding response, given by the system at time t. We aim to learn a linear regression model, g φ , which predicts the corresponding return (Alexa user score) at the current dialogue turn:where φ are the model parameters. We call this a reward model, since it directly models the Alexa user score, which we aim to maximize.Let {h Specifically, we set R d to be the Alexa user score given at the end of dialogue d. It's optional for users to a give a score; users are prompted to give a score at the end, but they may opt out by stopping the application. Although not all users give scores, we do not consider examples without scores.Furthermore, users are encouraged to give a score in the range 1 − 5. The majority of users give whole number (integer) scores, but some users give decimal scores (e.g. 3.5). Therefore, we treat R d as a real-valued number in the range 1 − 5.We learn φ by minimizing the squared error between the model's prediction and the observed return: As before, we optimize the model parameters with mini-batch stochastic gradient de- scent (SGD) using Adam.We use L2 regularization with coefficients in the set {10.0, 1.0, 0.1, 0.01, 0.001, 0.0001, 0.00001, 0.0}. We select the coefficient with the smallest squared error on a hold-out dataset.As input to the reward model we compute 23 features based on the dialogue history and a candidate response. As training data is scarce, we use only higher-level features:AMT label class:A vector indicating the probability of the AMT label classes for the candidate response, computed using Supervised AMT, as well as the probability that the candidate response has priority. If the candidate response has priority, the vector is zero in all entries, except the last entry corresponding to the priority class: A binary feature, which is 1.0 when the response only contains stop-words and otherwise zero. Response length:The number of words in the response, and the square root of the number of words in the response. Dialogue act:A one-hot vector, indicating whether the last user utterance's dialogue is a request, a question, a statement or contains profanity (Stolcke et al. 2000).A one-hot vector, indicating whether the last user utterance's dialogue is negative, neutral or positive. Generic user utterance: A binary feature, which is 1.0 when the last user utterance only contains stop-words, and otherwise zero. User utterance length: The number of words in the last user utterance, and the square root of the number of words in the response. Confusion indicator:A binary feature, which is 1.0 when the last user utterance is very short (less than three words) and contains at least one word indicating the user is confused (e.g. "what", "silly", "stupid"). Dialogue length:The number of dialogue turns so far, as well as the square root and logarithm of the number of dialogue turns.In total, our dataset for training the reward model has 4340 dialogues. We split this into a training set with 3255 examples and a test set with 1085 examples.To increase data efficiency, we learn an ensemble model through a variant of the bagging tech- nique (Breiman 1996). We create 5 new training sets, which are shuffled versions of the original training set. Each shuffled dataset is split into a sub-training set and sub-hold-out set. The sub- hold-out sets are created such that the examples in one set do not overlap with other sub-hold-out sets. A reward model is trained on each sub-training set, with its hyper-parameters selected on the sub-hold-out set. This increases data efficiency by allowing us to re-use the sub-hold-out sets for training, which would otherwise not have been used. The final reward model is an ensemble, where the output is an average of the underlying linear regression models.The reward model obtains a mean squared error of 0.96 and a Spearman's rank correlation coefficient of 0.19 w.r.t. the real Alexa user on the test set. In comparison, a model predicting with the average user score obtains a mean squared error of 0.99 and (because it outputs a constant) a Spearman's rank correlation coefficient of zero. Although the reward model is better than predicting the average, its correlation is relatively low. There are two reasons for this. First, the amount of training data is very small. This makes it difficult to learn the relationships between the features and the Alexa user scores.Second, the Alexa user scores are likely to have high variance because, they are influenced by many different factors. The score of the user may be determined by a single turn in the dialogue (e.g. a single misunderstanding at the end of the dialogue could result in a very low user score, even if all the previous turns in the dialogue were excellent). The score of the user may be affected by the accuracy of the speech recognition module. More speech recognition errors will inevitably lead to frustrated users. In a preliminary study, we found that Spearman's rank correlation coefficient between the speech recognition confidences and the Alexa user scores was between 0.05 − 0.09. In comparison to correlations with other factors, this implies that speech recognition performance plays an important role in determining user satisfaction. 21 In addition, extrinsic factors are likely to have a substantial influence on the user scores. The user scores are likely to depend not only on the dialogue, but also on the user's profile (e.g. whether the user is an adult or a child), the environment (e.g. whether the user is alone with the system or several users are taking turns conversing with the system), the user's expectations towards the system before starting the conversation (e.g. whether the system is capable of playing games) and the emotional state of the user (e.g. the user's mood).Training: To prevent overfitting, we do not train the scoring model (action-value function) from scratch with the reward model as target. Instead, we first initialize the model with the parameters of the Supervised AMT scoring model, and then fine-tune it with the reward model outputs to minimize the squared error:the hold-out dataset w.r.t. Alexa user scores predicted by the reward model. As this scoring model was trained with a learned reward function, we call it Supervised Learned Reward.As discussed earlier, one way to parametrize the policy is as a discrete probability distribution over actions. This parametrization allows us to learn the policy directly from recorded dialogues through a set of methods known as policy gradient methods. This section describes one such approach.Off-policy Reinforcement Learning: We use a variant of the classical REINFORCE algo- rithm (Williams 1992, Precup 2000, Precup et al. 2001), which we call Off-policy REINFORCE. Recall eq. (4), where the policy's distribution over actions is parametrized as softmax function applied to a function f θ with parameters θ. As before, let {hwhere c d t is the importance weight ratio:.This ratio corrects for the discrepancy between the learned policy π θ and the policy under which the data was collected π θ d (sometimes referred to as the behaviour policy). It up-weights examples with high probability under the learned policy and down-weights examples with low probability under the learned reward function.The intuition behind the algorithm can be illustrated by analogy with learning from trial and error.When an example has a high return (i.e. high user score), the term ∇ θ log π θ (a Therefore, we truncate the products in the nominator and denominator to only include the current time step t:.This induces bias in the learning process, but also acts as a regularizer.Reward Shaping: As mentioned before, one problem with the Off-policy REINFORCE algorithm presented in eq. (10) is that it suffers from high variance ( Precup et al. 2001). The algorithm uses the return, observed only at the very end of an episode, to update the policy's action probabilities for all intermediate actions in an episode. With a small number of examples, the variance in the gradient estimator is overwhelming and this could easily lead the agent to over-estimate the utility of poor actions and, vice versa, to under-estimate the utility of good actions. One remedy for this problem is reward shaping, where the reward at each time step is estimated using an auxiliary function ( Ng et al. 1999). For our purpose, we propose a simple variant of reward shaping which takes into account the sentiment of the user. When the user responds with a negative sentiment (e.g. an angry comment), we will assume that the preceding action was highly inappropriate and assign it a reward of zero. Given a dialogue d, at each time t we assign reward r With reward shaping and truncated importance weights, the learning update becomes:Off-policy Evaluation: To evaluate the policy, we estimate the expected return (Precup 2000):Furthermore, by substituting r d t with a constant reward of 1.0 for each time step, we can compute the estimated number of time steps per episode under the policy. As will be discussed later, this is an orthogonal metric based on which we can analyse and evaluate each policy. However, this estimate does not include the number of priority responses, since there are no actions for the agent to take when there is a priority response.Training: We initialize the policy model with the parameters of Supervised AMT, and then train the parameters w.r.t. eq. (14) with stochastic gradient descent using Adam. We use a set of a few thousand dialogues recorded between Alexa users and a preliminary version of the system. About 60% of these examples are used for training, and about 20% are used for development and testing. To reduce the risk of overfitting, we only train the weights related to the second last layer using off-policy REINFORCE. We use a random grid search with different hyper-parameters, which include the temperature parameter λ and the learning rate. We select the hyper-parameters with the highest expected return on the development set.Similar to the Supervised Learned Reward policy, we may use the reward model for training with the Off-policy REINFORCE algorithm. This section describes how we combine the two approaches.We use the reward model to compute a new estimate for the reward at each time step in each dialogue:if user utterance at time t + 1 has negative sentiment, g φ (h t , a t ) otherwise.This is substituted into eq. (14) for training and into eq. (15) for evaluation.Training: As with Off-policy REINFORCE, we initialize the policy model with the parameters of the Supervised AMT model, and then train the parameters w.r.t. eq. (14) with mini-batch stochastic gradient descent using Adam. We use the same set of dialogues and split as Off-policy REINFORCE.We use a random grid search with different hyper-parameters, As before, to reduce the risk of overfitting, we only train the weights related to the second last layer using this method. which include the temperature parameter λ and the learning rate, and select the hyper-parameters with the highest expected return on the development set. In this case, the expected return is computed according to the learned reward model. As this policy uses the learned reward model, we call it Off-policy REINFORCE Learned Reward.The approaches described so far have each their own advantages and disadvantages. One way to quantify their differences is through a decomposition known as the bias-variance trade-off. At one end of the spectrum, the Supervised AMT policy has low variance, because it was trained with hundreds of thousands of human annotations at the level of each model response. However, for the same reason, Supervised AMT incurs a substantial bias, because the human annotations do not reflect the real user satisfaction for an entire conversation. At the other end of the spectrum, Off-policy REINFORCE suffers from high variance, because it was trained with only a few thousand dialogues and corresponding user scores. To make matters worse, the user scores are affected by many external factors (e.g. user profile, user expectations, and so on) and occur at the granularity of an entire conversation. Nevertheless, this method incurs low bias because it directly optimizes the objective metric we care about (i.e. the user score). 22 By utilizing a learned reward function, Supervised 22 Due to truncated importance weights, however, the off-policy REINFORCE training procedure is still biased.Learned Reward and Off-policy REINFORCE Learned Reward suffer less from bias, but since the learned reward function has its own variance component, they are both bound to have higher variance. In general, finding the optimal trade-off between bias and variance can be notoriously difficult. In this section we propose a novel method for trading off bias and variance by learning the policy from simulations in an approximate Markov decision process.Motivation A Markov decision process (MDP) is a framework for modeling sequential decision making (Sutton &amp; Barto 1998). In the general setting, an MDP is a model consisting of a discrete set of states H, a discrete set of actions A, a transition distribution function P , a reward distribution function R, and a discount factor γ. As before, an agent aims to maximize its reward during each episode. Let t denote the time step of an episode with length T . At time step t, the agent is in state h t ∈ H and takes action a t ∈ A. Afterwards, the agent receives reward r t ∼ R(h t , a t ) and transitions to a new state h t+1 ∼ P (h t |a t ).Given an MDP model for open-domain conversations, there are dozens of algorithms we could apply to learn the agent's policy (Sutton &amp; Barto 1998). Unfortunately, such an MDP is difficult to build or estimate. We could try to naively estimate one from the recorded dialogues, but this would require solving two extremely difficult problems. First, we would need to learn the transition distribution P , which outputs the next user utterance in the dialogue given the dialogue history. This problem is likely to be as difficult as our original problem of finding an appropriate response to the user! Second, we would need to learn the reward distribution R for each time step. However, as we have shown earlier, it is very difficult to learn to predict the user score for an entire dialogue. Given the data we have available, estimating the reward for a single turn is likely also going to be difficult. Instead, we propose to tackle the problem by splitting it into three smaller parts. For each time step t, z t is a discrete random variable which represents the abstract state of the dialogue, h t represents the dialogue history, a t represents the action taken by the system (i.e. the selected response), y t represents the sampled AMT label and r t represents the sampled reward.The Abstract Discourse Markov Decision Process The model we propose to learn is called the Abstract Discourse MDP. As illustrated in Figure 7, the model follows a hierarchical structure at each time step. At time t, the agent is in state z t ∈ Z, a discrete random variable representing the abstract discourse state. This variable only represents a few high-level properties related to the dialogue history. We define the set Z is the Cartesian product:where Z Dialogue act , Z User sentiment and Z Generic user utterance are three discrete sets.The first set consists of 10 dialogue acts: Z Dialogue act = {Accept, Reject, Request, Politics, Generic Question, Personal Question, Statement, Greeting, Goodbye, Other}.These dialogue acts represent the high-level intention of the user's utterance (Stolcke et al. 2000).The second set consists of sentiments types: Z User sentiment = {Negative, Neutral, Positive}. The third set represent a binary variable: Z Generic user utterance = {True, False}. This variable is True only when the user utterance is generic and topic-independent (i.e. when the user utterance only contains stop-words). We build a hand-crafted deterministic classifier, which maps a dialogue history to the corresponding classes in Z Dialogue act , Z User sentiment and Z Generic user utterance . We denote this mapping f h→z . Although we only consider dialogue acts, sentiment and generic utterances, it is trivial to expand the abstract discourse state with other types of discrete or real-valued variables.Given a sample z t , the Abstract Discourse MDP samples a dialogue history h t from a finite set of dialogue histories H. In particular, h t is sampled at uniformly random from the set of dialogue histories where the last utterance is mapped to z t :In other words, h t is a dialogue history where dialogue act, user sentiment and generic property is identical to the discrete variable z t .For our purpose, H is the set of all recorded dialogues between Alexa users and a preliminary version of the system. This formally makes the Abstract Discourse MDP a non-parametric model, since sampling from the model requires access to the set of recorded dialogue histories H. This set grows over time when the system is deployed in practice. This is useful, because it allows to continuously improve the policy as new data becomes available. Further, it should be noted that the set Z is small enough that every possible state is observed several times in the recorded dialogues.Given a sample h t , the agent chooses an action a t according to its policy π θ (a t |h t ), with parameters θ. A reward r t is then sampled such that r t ∼ R(h t , a t ), where R is a distribution function. In our case, we use the probability function P ˆ θ , where the parametersˆθparametersˆ parametersˆθ are estimated using supervised learning on AMT labels in eq. (6). We specify a reward of −2.0 for a "very poor" response class, a reward of −1.0 for a "poor" response class, a reward of 0.0 for an "acceptable" response class, a reward of 1.0 for a "good" response class and a reward of 2.0 for an "excellent" response class. To reduce the number of hyperparameters, we use the expected reward instead of a sample:Next, a variable y t ∈ {"very poor", "poor", "acceptable", "good", "excellent"} is sampled:This variable represents one appropriateness interpretation of the output. This variable helps predict the future state z t+1 , because the overall appropriateness of a response has a significant impact on the user's next utterance (e.g. very poor responses often cause users to respond with What? or I don't understand.).Finally, a new state z t+1 is sampled according to P ˆ ψ :where P ˆ ψ is the transition distribution with parametersˆψparametersˆ parametersˆψ. The transition distribution is parametrized by three independent two-layer MLP models, which take as input the same features as the scoring function, as well as 1) a one-hot vector representing the sampled response class y t , 2) a one-hot vector representing the dialogue act of the last user utterance, 3) a one-hot vector representing the sentiment of the last user utterance, 4) a binary variable indicating whether the last user utterance was generic, and 5) a binary variable indicating whether the last user utterance contained a wh-word (e.g. what, who). The first MLP predicts the next dialogue act, the second MLP predicts the next sentiment type and the third MLP predicts whether the next user utterance is generic. The dataset for training the MLPs consists of 499, 757 transitions, of which 70% are used for training and 30% for evaluation. The MLPs are trained with maximum log-likelihood using mini-batch stochastic gradient descent. We use Adam and early-stop on a hold-out set. Due to the large number of examples, no regularization is used. The three MLP models obtain a joint perplexity of 19.51. In comparison, a baseline model, which always assigns the average class frequency as the output probability obtains a perplexity of 23.87. On average, this means that roughly 3 − 4 possible z t+1 states can be eliminated by conditioning on the previous variables z t , h t , a t and y t . In other words, the previous state z t and h t , together with the agent's action a t has a significant effect on the future state z t+1 . This means that an agent trained in the Abstract Discourse MDP has the potential to learn to take into account future states of the dialogue when selecting its action. This is in contrast to policies learned using supervised learning, which do not consider future dialogue states. Table 3: Policy evaluation on AMT w.r.t. score mean and score standard deviation (std). 90% confidence intervals are given for means (after ±) and standard deviations (in square brackets). The idea of modeling a high-level abstraction of the dialogue, z t , is related to the dialogue state tracking challenge ( Williams et al. 2013Williams et al. , 2016. In this challenge, the task is to map the dialogue history to a discrete state representing all salient information about the dialogue. Unlike the dialogue state tracking challenge, however, the variable z t only includes limited salient information about the dialogue. For example, in our implementation, z t does not include topical information. As such, z t is only a partial representation of the dialogue history.Training Given the Abstract Discourse MDP, we are now able to learn policies directly from simulations. We use Q-learning with experience replay to learn the policy parametrized as an action- value function ( Mnih et al. 2013, Lin 1993. Q-learning is a simple off-policy reinforcement learning algorithm, which has been shown to be effective for training policies parametrized by neural networks.For experience replay, we use a memory buffer of size 1000. We use an exploration scheme with = 0.1. We experiment with discount factors γ ∈ {0.1, 0.2, 0.5}. As before, the parameters are updated using Adam. To reduce the risk of overfitting, we only train the weights related to the final output layer and the skip-connection (shown in dotted lines in Figure 2) using Q-learning.Training is carried out in two alternating phases. We train the policy for 100 episodes. Then, we evaluate the policy for 100 episodes w.r.t. average return. Afterwards, we continue training the policy for another 100 episodes. During evaluation, each dialogue history is sampled from a separate set of dialogue histories, H Eval , which is disjoint from the set of dialogue histories, H Train used at training time. This ensures that the policy is not overfitting our finite set of dialogue histories. For each hyper-parameter combination, we train the policy between 400 and 600 episodes. We select the policy which performs best w.r.t. average return. To keep notation brief, we call this policy Q-learning AMT.In this section, we carry out a preliminary evaluation of the response model selection policies.AMT Evaluation: We first evaluate the learned policies on the w.r.t. the human scores in the AMT test set. We measure the average performance as a real-valued scalar, where the label "Very poor" is given a score of 1, label "Poor" is given a score of 2 and so on. We also report standard deviations for the scores, which measure the variance or risk the policies are willing to take; higher standard deviations indicate that a policy is more likely to select responses which result in extreme labels (e.g. "Very poor" and "Excellent"). For both means and standard deviations we report 90% confidence intervals estimated under the assumption that the scores are Gaussian-distributed. In addition to measuring performance on the full test set, we also measure performance on a subset of the test set where neither Alicebot nor Evibot had responses labeled "Good" or "Excellent". These are test examples, where an appropriate response is likely to come only from some of the other models. Determining an appropriate response for these examples is likely to be more difficult. We refer to this subset as the "Difficult test set".We evaluate the policies Supervised AMT, Off-policy REINFORCE and Q-learning AMT. In addition, we also evaluate two heuristic policies: 1) a policy selecting only Alicebot responses called Alicebot, and 2) a policy selecting Evibot responses when possible and Alicebot responses otherwise, called Evibot + Alicebot.The results are given in Table 3. The results show that the three learned policies are all significantly better w.r.t. mean score compared to both Alicebot and Evibot + Alicebot. Not surprisingly, this difference is amplified on the difficult test set. Q-learning AMT, Supervised AMT and Off-policy REINFORCE appear to perform overall equally well. This shows that machine learning has helped learn effective policies, able to select other model responses when neither the Alicebot and Evibot responses are appropriate. Next, the results show that Q-learning AMT has higher standard deviations than the other policies on both the full test set and the difficult test set. Furthermore, since these standard deviations are evaluated at the level of a single response, we might expect this variability to compound throughout an entire conversation. This strongly indicates that Q-learning AMT is more risk tolerant than the other policies. Off-policy Evaluation: One way to evaluate the selection policies is by using the off-policy evalu- ation given in eq. (15). This equation provides an estimate of the expected Alexa user score under each policy. 24 As described earlier, the same equation can be used to estimate the expected number of time steps per episode (excluding priority responses).The expected (average) Alexa user score and number of time steps per episode (excluding priority responses) are given in Table 4. Here we observe that the Off-policy REINFORCE performs best followed by Q-learning AMT and Supervised AMT w.r.t. expected Alexa user score. Off-policy REINFORCE reaches 2.45, which is a major 17.8% improvement over the second best performing model Q-learning AMT. However, this advantage should be taken with a grain of salt. As discussed earlier, the off-policy evaluation in eq. (15) is a biased estimator since the importance weights have been truncated. Moreover, Off-policy REINFORCE has been trained specifically to maximize this biased estimator, while all other policies have been trained to maximize other objective functions. Similarly, w.r.t. expected number of time steps, Off-policy REINFORCE reaches the highest number of time steps followed by Q-learning AMT and Supervised AMT. As before, we should take this result with a grain of salt, since this evaluation is also biased and does not take into account priority responses. Further, it's not clear that increasing the number of time steps will increase user scores. Nevertheless, Off-policy REINFORCE, Q-learning AMT and Supervised AMT appear to be our prime candidates for further experiments.Response Model Selection Frequency: Figure 8 shows the frequency with which Supervised AMT, Off-policy REINFORCE and Q-learning AMT select different response models. We observe that the policy learned using Off-policy REINFORCE tends to strongly prefer Alicebot responses over other models. The Alicebot responses are among the safest and most topic-dependent, generic responses in the system, which suggests that Off-policy REINFORCE has learned a highly risk averse strategy. On the other hand, the Q-learning AMT policy selects Alicebot responses substantially less often than both Off-policy REINFORCE and Supervised AMT. Instead, Q-learning AMT tends to prefer responses retrieved from Washington Post and from Google search results. These responses are semantically richer and have the potential to engage the user more deeply in a particular topic, but they are also more risky (e.g. a bad choice could derail the entire conversation.). This suggests that Q-learning AMT has learned a more risk tolerant strategy. One possible explanation for this difference is that Q-learning AMT was trained using simulations. By learning online from simulations, the policy has been able to explore new actions and discover high-level strategies lasting multiple time steps. In particular, the policy has been allowed to experiment with riskier actions and to learn remediation or fall-back strategies, in order to handle cases where a risky action fails. This might also explain its stronger preference for BoWFactGenerator responses, which might be serving as a fall-back strategy by outputting factual statements on the current topic. This would have been difficult   to learn for Off-policy REINFORCE, since the sequence of actions for such high-level strategies are sparsely observed in the data and, when they are observed, the corresponding returns (Alexa user scores) have high variance.A second observation is that Q-learning AMT has the strongest preference for Initiatorbot among the three policies. This could indicate that Q-learning AMT leans towards a system-initiative strategy (e.g. a strategy where the system tries to maintain control of the conversation by asking questions, changing topics and so on). Further analysis is needed to confirm this.Abstract Discourse MDP Evaluation Next, we can evaluate the performance of each policy w.r.t. simulations in the Abstract Discourse MDP. We simulate 500 episodes under each policy and evaluate it w.r.t. average return, average reward per time step and dialogue length. In addition to evaluating the five policies described earlier, we also evaluate three heuristic policies: 1) a policy selecting responses at random called Random, 2) the Alicebot policy, and 3) the Evibot + Alicebot policy. Evaluating these models will serve to validate the approximate MDP.The results are given in Table 5. We observe that Supervised AMT performs best w.r.t. average return and average reward per time step. However, this comes as no surprise. The reward function in the MDP is defined as Supervised AMT, so by construction this policy achieves the highest reward per time step. Next we observe that Q-learning AMT is on par with Supervised AMT, both achieving same −0.15 average reward per time step. Second in line comes Off-policy REINFORCE, achieving an average reward per time step of −0.16. However, Off-policy REINFORCE also achieved the highest average dialogue length of 43.24. At the other end of the spectrum comes, as expected, the Random policy performing worst w.r.t. all metrics. In comparison, both Alicebot and Evibot + Alicebot perform better w.r.t. all metrics, with Evibot + Alicebot achieving the best average return and average reward per time step out of the three heuristic policies. This validates the utility of the Abstract Discourse MDP as an environment for training and evaluating policies. Overall, Off-policy REINFORCE, Q-learning AMT and Supervised AMT still appear to be the best performing models in the preliminary evaluation. Finally, we compare Q-learning AMT with Supervised AMT w.r.t. the action taken in states from episodes simulated in the Abstract Discourse MDP. As shown in Figure 9, the two policies diverge w.r.t. several response models. When Supervised AMT would have selected topic-independent, generic Alicebot and Elizabot responses, Q-learning AMT often selects BoWFactGenerator, Initiatorbot and VHREDWashingtonPost responses. For example, there were 347 instances where Supervised AMT selected Alicebot, but where Q-learning AMT selected BoWFactGenerator. Similarly, where Supervised AMT would have preferred generic VHREDSubtitle responses, Q-learning AMT often selects responses from BoWFactGenerator, InitiatorBot and VHREDRedditSports. This supports our previous analysis showing that Q-learning AMT has learned a more risk tolerant strategy, which involves response models with semantically richer content.In the next section, we evaluate these policies with real-world users.To evaluate the dialogue manager policies described in the previous section, we carry out A/B testing experiments. During each A/B testing experiment, we evaluate several policies for selecting the response model. When Alexa users start a conversation with the system, they are automatically assigned to a random policy and afterwards their dialogues and final scores are recorded.A/B testing allows us to accurately compare different dialogue manager policies by keeping all other system factors constant (or almost constant). This is in contrast to evaluating the system performance over time, when the system is continuously being modified. In such a situation, it is often difficult to evaluate the improvement or degradation of performance w.r.t. particular system modifications.However, even during our A/B testing experiments, the distribution over Alexa users still changes through time. Different types of users will be using the system depending on the time of day, weekday and holiday season. In addition, the user expectations towards our system change over time as they interact with other socialbots in the competition. In other words, we must consider the Alexa user distribution as following a non-stationary stochastic process. Therefore, we take two steps to reduce confounding factors and correlations between users. First, during each A/B testing experiment, we evaluate all policies of interest simultaneously. This ensures that we have approximately the same number of users interacting with each policy w.r.t. time of day and weekday. This minimizes the effect of changes in the user distribution on the final user scores within that period. However, since the user distribution changes between the A/B testing experiments, we still cannot accurately compare policy performance across A/B testing experiments. Second, we discard scores from returning users (i.e. users who have already evaluated the system once). Users who are returning to the system are likely to be influenced by their previous interactions with the system. For example, users who previously had a positive experience with the system may be biased towards giving high scores in their next interaction. Further, the users who return to the system are likely to belong to a particular subpopulation of users. This particular group of users may inherently have more free time and be more willing to engage with socialbots than other users. Discarding returning user scores ensures that the evaluation is not biased towards this subpopulation of users. By discarding scores from returning users, we also ensure that the evaluation counts every user exactly once. Finally, it should be noted that we ignore dialogues where the Alexa user did not give a score. This inevitably biases our evaluation, since users who do not provide a score are likely to have been dissatisfied with the system or to have been expecting different functionality (e.g. non-conversational activities, such as playing music, playing games or taking quizzes). One potential remedy is to have all dialogues evaluated by a third-party (e.g. by asking human annotators on Amazon Mechanical Turk to evaluate the dialogue), but that is beyond the scope of these experiments.The first A/B testing experiment was carried out between July 29th, 2017 and August 6th, 2017. We tested six dialogue manager policies: Evibot + Alicebot, Supervised AMT, Supervised Learned Reward, Off-policy REINFORCE, Off-policy REINFORCE Learned Reward and Q-learning AMT. For Off-policy REINFORCE and Off-policy REINFORCE Learned Reward, we use the greedy variant defined in eq. (5).This experiment occurred early in the Amazon Alexa Prize competition. This means that Alexa users have few expectations towards our system (e.g. expectations that the system can converse on a particular topic, or that the system can engage in non-conversational activities, such as playing word games or taking quizzes). Further, the period July 29th -August 6th overlaps with the summer holidays in the United States. This means that we might expect more children to interact with system than during other seasons.The results are given in Table 6. 25 The table shows the average Alexa user scores, average dialogue length, average percentage of positive user utterances and average percentage of negative user utterances. In total, over a thousand user ratings were collected after discarding returning users. Ratings were collected after the end of the semi-finals competition, where all ratings  had been transcribed by human annotators. Each policy was evaluated by about two hundred unique Alexa users.As expected from our preliminary evaluation, we observe that Q-learning AMT and Off-policy REINFORCE perform best among all policies w.r.t. user scores. Q-learning AMT obtained an average user score of 3.15, which is significantly higher than all other policies at a 95% statistical significance level w.r.t. a one-tailed two-sample t-test. In comparison, the average user score for all the teams in the competition during the semi-finals was only 2.92. Interestingly, Off-policy REINFORCE achieved the longest dialogues with an average length of 37.51. This suggests Off-policy REINFORCE yields highly engaging conversations. In comparison, in the semi-finals, the average dialogue length of all teams was 22 and of the finalist teams was 26. We also observe that Off-policy REINFORCE had a slightly higher percentage of user utterances with negative sentiment compared to Q-learning AMT. This potentially indicates that the longer dialogues also include some frustrated interactions (e.g. users who repeat the same questions or statements in the hope that the system will return a more interesting response next time). The remaining policies achieved average Alexa user scores between 2.74 and 2.86, with the heuristic policy Evibot + Alicebot obtaining 2.86. This suggests that the other policies have not learned to select responses more appropriately than the Evibot + Alicebot heuristic.In conclusion, the results indicate that the risk tolerant learned by the Q-learning AMT policy performs best among all policies. This shows that learning a policy through simulations in an Abstract Discourse MDP may serve as a fruitful path towards developing open-domain socialbots. In addition, the performance of Off-policy REINFORCE indicates that optimizing the policy directly towards Alexa user scores could also potentially yield improvements. However, further investigation is required.In an effort to further understand how the policies differ from each other, we carry out an analysis of the policies performance as a function of dialogue length. Although, we have recorded only a limited amount of data for dialogues with a particular length, this analysis could help illuminate directions for future experiments. Table 8 shows the average Alexa user scores w.r.t. four dialogue length intervals for the six policies. The estimates are based on between 30-70 Alexa user ratings for each policy and interval combination. First, we observe that Q-learning AMT performs better than all other policies for all intervals except the medium-short interval (10 − 19, or 5 − 10 back-and-forth turns). Further, its high performance for the long intervals (20 − 39 and ≥ 40) would suggest that Q-learning AMT performs excellent in long dialogues. The other learned policies Supervised AMT, Off-policy REINFORCE and Off-policy REINFORCE Learned Reward also appear to perform excellent in long dialogues. On the other hand, the heuristic Evibot + Alicebot policy and the Supervised Learned Reward policy appear to perform poorly in long dialogues, but that is not surprising given their low overall performance. In particular, Supervised Learned Reward seems to be performing well only for very short dialogues. This potentially indicates that the policy fails to either maintain user engagement or memorize longer-term context. However, further investigation is required.We carry out an analysis of the topical specificity and coherence of the different policies. This analysis aims to quantify how much each policy stays on topic (e.g. whether the policy selects responses on the current topic or on new topics) and how specific its content is (e.g. how frequently the policy selects generic, topic-independent responses). This analysis is carried out at the utterance level, where we are fortunate to have more recorded data.The results are shown in Table 9. For topic specificity, we measure the average number of noun phrases per user utterance and the average number of noun phrases per system utterance. 26 The more topic specific the user is, the higher we would expect the first metric to be. Similarly, the more topic specific the system is the higher we would expect the second metric to be. For topic coherence, we measure the word overlap between the user's utterance and the system's response, as well as word overlap between the user's utterance and the system's response at the next turn. The more the policy prefers to stay on topic, the higher we would expect these two metrics to be.As shown in the table, Q-learning AMT has obtained significantly higher scores w.r.t. both word overlap metrics and the average number of noun phrases per system utterance. This indicates that the Q-learning AMT policy has the highest topical coherency among all six policies, and that it generates the most topic specific (semantically rich) responses. This is in line with our previous analysis, where we found that Q-learning follows a highly risk tolerant strategy. Next in line, comes Supervised AMT, which also appears to maintain high topic specificity and coherence. In fact, Supervised AMT obtained the highest metric w.r.t. number of noun phrases per user utterance, which indicates that this policy is encouraging the user to give more topic specific responses. Afterwards comes Off-policy REINFORCE and Off-policy REINFORCE Learned Reward, which tend to select responses with significantly less noun phrases and less word overlap. This is also in line with our previous analysis, where we found that Off-policy REINFORCE follows a risk averse strategy. Finally, the heuristic policy Evibot + Alicebot selects responses with very few noun phrases and least word overlap among all policies. This indicates that the heuristic policy might be the least topic coherent policy, and that it mainly selects generic, topic-independent responses.Initiatorbot Evaluation This experiment also allowed us to analyze the outcomes of different conversation starter phrases given by the Initiatorbot. We carried out this analysis by computing the average Alexa user score for each of the 40 possible phrases. We found that phrases related to news (e.g. "Do you follow the news?"), politics (e.g. "Do you want to talk about politics?") and travelling (e.g. "Tell me, where do you like to go on vacation?") performed poorly across all policies. On the other hand, phrases related to animals (e.g. "Do you have pets?" and "What is the cutest animal you can think of?"), movies (e.g. "Let's talk about movies. What's the last movie you watched?") and Table 9: First A/B testing experiment topical specificity and coherence of the six different policies. The columns are average number of noun phrases per user utterance (User NPs), average number of noun phrases per system utterance (System NPs), average number of overlapping words between the user's utterance and the system's response (Word overlap t → t + 1), and average number of overlapping words between the user's utterance and the system's response in the next turn (Word overlap t → t + 3). 95% confidence intervals are also shown. Stop words are excluded.User  food (e.g. "Let's talk about food. What is your favorite food?") performed well across all policies. For example, conversations where the Initiatorbot asked questions related to news and politics had an average Alexa user score of only 2.91 for the top two systems (Off-policy REINFORCE and Q-learning AMT). Mean while, conversations where the Initiatorbot asked questions about animals, food and movies the corresponding average Alexa user score was 3.17. We expected the conversation topic to affect user engagement, however it is surprising that these particular topics (animals, food and movies) were the most preferred ones. One possible explanation is that our system does not perform well on news, politics and travelling topics. However, the system already had several response models dedicated to discussing news and politics: six sequence-to-sequence models extracting responses from Reddit news and Reddit politics, two models extracting responses from Washington Post user comments and the BoWTrump model extracting responses from Donald J. Trump's Twitter profile. In addition, Evibot is capable of answering many factual questions about news and politics and BoWFactGenerator contains hundreds of facts related to news and politics. As such, there may be another more plausible explanation for users' preferences towards topics, such as animals, movies and food. One likely explanation is the age group of the users. While inspecting our conversational transcripts, we observed that many users interacting with the system appeared to be children or teenagers. It would hardly come as a surprise if this user population would prefer to talk about animals, movies and foods rather than news, politics and travels.The second A/B testing experiment was carried out between August 6th, 2017 and August 15th, 2017. We tested two dialogue manager policies: Off-policy REINFORCE and Q-learning AMT. As before, we use the greedy variant of Off-policy REINFORCE defined in eq. (5).This experiment occurred at the end of the Amazon Alexa Prize competition semi-finals. This means that many Alexa users have already interacted with other socialbots in the competition, and therefore are likely to have developed expectations towards the systems. These expectations are likely to involve conversing on a particular topic or engaging in non-conversational activities, such as playing games). Further, the period August 6th -August 15th overlaps with the end of the summer holidays and the beginning of the school year in the United States. This means that we should expect less children to interact with the system than in the previous A/B testing experiment. The results are given in Table 10. In total, about eight hundred user ratings were collected after discarding returning users. As such, each policy was evaluated by about six hundred unique Alexa users. As before, all ratings were transcribed by human annotators.We observe that both Off-policy REINFORCE and Q-learning AMT perform better than the policies in the previous experiment. However, in this experiment, Off-policy REINFORCE achieved an average Alexa user score of 3.06 while Q-learning AMT achieved a lower score of only 2.92. Nonetheless, Off-policy REINFORCE is not statistically significantly better. In this experiment, there is also no significant difference between the two policies w.r.t. percentage of positive and negative user utterances.As discussed earlier, the performance difference compared to the previous A/B testing experiment could be due to the change in user profiles and user expectations. At this point in time, more of the Alexa users have interacted with socialbots from other teams. Mean while, all socialbots have been evolving. Therefore, user expectations towards our system are likely to be higher now. Further, since the summer holidays have ended, less children and more adults are expected to interact with our system. It is plausible that these adults also have higher expectations towards the system, and even more likely that they are less playful and less tolerant towards mistakes. Given this change in user profiles and expectations, the risk tolerant strategy learned by the Q-learning AMT policy is likely to fare poorly compared to the risk averse strategy learned by Off-policy REINFORCE.The third A/B testing experiment was carried out between August 15th, 2017 and August 21st, 2017. Due to the surprising results in the previous A/B testing experiment, we decided to continue testing the two dialogue manager policies Off-policy REINFORCE and Q-learning AMT. As before, we use the greedy variant of Off-policy REINFORCE defined in eq. (5).This experiment occurred after the end of the Amazon Alexa Prize competition semi-finals. As discussed before, this means that it is likely that many Alexa users have already developed expectations towards the systems. Further, the period August 15th -August 21st lies entirely within the beginning of the school year in the United States. This means that we should expect less children to interact with the system than in the previous A/B testing experiment.The results are given in Table 11. In total, about six hundred user ratings were collected after discarding returning users. As such, each policy was evaluated by about three hundred unique Alexa users. Unlike the previous two experiments, due to the semi-finals having ended, these ratings were not transcribed by human annotators.We observe again that both Off-policy REINFORCE and Q-learning AMT perform better than the other policies evaluated in the first experiment. However, in this experiment, Off-policy REINFORCE only achieved an average Alexa user score of 3.03 while Q-learning AMT achieved the higher score of 3.06. As before, neither policy is statistically significantly better than the other. Nevertheless, as in the first experiment, Q-learning AMT achieved a higher percentage of positive utterances and a lower percentage of negative utterances than Off-policy REINFORCE. In this experiment, Q-learning AMT also obtains the longest dialogues on average. Overall, this experiment indicates that Q-learning AMT is the better policy.As before, the difference in performance compared to the previous A/B testing experiments is likely due to the change in user profiles and user expectations. The fact that Q-learning AMT now performs slightly better than Off-policy REINFORCE might be explained by many different causes. First, despite the confidence intervals and statistical tests presented earlier, it is of course possible that the previous A/B testing experiments did not have enough statistical power to accurately discriminate whether Q-learning AMT or Off-policy REINFORCE obtains the highest average user score. Second, it is possible that the topics users want to discuss now are simply better handled by Q-learning AMT. Third, it is possible that adult users might only have a weak preference toward the risk averse Q- learning AMT policy, and that there is still a significant amount of children and teenagers interacting with the system even though the summer holidays have ended. Finally, it is possible that the user population has grown tired of Off-policy REINFORCE, which follows a risk averse strategy by responding with less semantic content.The two dialogue manager policies Q-learning AMT and Off-policy REINFORCE have demonstrated substantial improvements over all other policies, including policies learned using supervised learning and heuristic policies. As discussed earlier, the Q-learning AMT policy achieved an average Alexa user score substantially above the average score of all teams in the Amazon Alexa Prize competition semi-finals, without relying on non-conversational activities. In addition, it also achieved a higher number of dialogue turns than both the average of all teams in the semi-finals and the average of all finalist teams in the semi-finals. The policy Off-policy REINFORCE similarly obtained a high number of dialogue, suggesting that the resulting conversations are far more engaging. The results demonstrate the advantages of the overall ensemble approach, where many different models generate natural language responses and the dialogue manager policy selects one response among them. The results also highlight the advantages of learning the policy using reinforcement learning techniques. By optimizing the policy to maximize either real-world user scores or to maximize rewards in the Abstract Discourse MDP (with a proxy reward function) we have demonstrated that significant gains can be achieved w.r.t. both real-world user scores and number of dialogue turns.Dialogue Manager Architecture: Any open-domain conversational agent will have to utilize many different types of modules, such as modules for looking up information, modules for daily chitchat discussions, modules for discussing movies, and so on. In this respect, our system architecture is related to some of the recent general-purpose dialogue system frameworks ( , Miller et al. 2017, Truong et al. 2017). These systems abstract away the individual modules into black boxes sharing the same interface, similar to the response models in our ensemble. This, in turn, enables them to be controlled by an executive component (e.g. a dialogue manager).Much work has applied reinforcement learning to training or improving dialogue systems. The idea that dialogue can be formulated as a sequential decision making problem based on a Markov decision process (MDP) appeared already in the 1990s for goal-oriented dialogue systems ( Singh et al. 1999, 2002, Williams &amp; Young 2007, Young et al. 2013, Paek 2006, Henderson et al. 2008, Pieraccini et al. 2009, Su et al. 2015).One line of research in this area has focused on learning dialogue systems through simulations using abstract dialogue states and actions (Eckert et al. 1997, Levin et al. 2000, Chung 2004, Cuayáhuitl et al. 2005, Georgila et al. 2006, Schatzmann et al. 2007, Heeman 2009, Traum et al. 2008, Georgila &amp; Traum 2011, Lee &amp; Eskenazi 2012, Khouzaimi et al. 2017, López-Cózar 2016, Su et al. 2016, Fatemi et al. 2016). The approaches here differ based on how the simulator itself is created or estimated, and whether or not the simulator is also considered an agent, which is trying to optimize its own reward. For example, Levin et al. (2000) tackle the problem of building a flight booking dialogue system. They estimate a user simulator model by counting transition probabilities between dialogue states and user actions (similar to an n-gram model), which is then used to train a reinforcement learning policy. In their setting, the states and actions are all abstract discrete variables, which minimizes the amount of natural language understanding and generation the policy has to learn. As another example, Georgila &amp; Traum (2011) tackle the problem of learning dialogue policies for negotiation games, where each party in the dialogue is an agent with its own reward function. In their setting, each policy is in effect also a user simulator, and is trained by playing against other policies using model-free on-policy reinforcement learning. As a more recent example, Yu et al. (2016) build a open-domain, chitchat dialogue system using reinforcement learning. In particular, Yu et al. (2016) propose to learn a dialogue manager policy through model-free off-policy reinforcement learning based on simulations with the template-based system A.L.I.C.E. (Wallace 2009) with a reward function learned from crowdsourced annotations. This is shown to yield substantial improvements w.r.t. both the overall appropriateness of each system response and the conversational depth of the dialogues (e.g. how long the system remains on topic).Researchers have also recently started to investigate learning generative neural network policies operating directing on raw text through user simulations ( Li et al. 2016, Das et al. 2017, Lewis et al. 2017, Liu &amp; Lane 2017, Lewis et al. 2017. In contrast to earlier work, these policies require both a deeper understanding of natural language and an ability to generate natural language. For example, Li et al. (2016) propose to train a generative sequence-to-sequence neural network using maximum log-likelihood, and then fine-tune it with a multi-objective function. The multi-objective function includes, among other things, a reinforcement learning signal based on self-play Monte Carlo rollouts (i.e. simulated trajectories are generated by sampling from the model, similar to ( Silver et al. 2016)) using a hand-crafted reward function. Lewis et al. (2017) apply model-free reinforcement learning for learning a system capable of negotiation in a toy domain from crowdsourced data. They demonstrate that it's feasible to learn an effective policy by training a generative sequence-to-sequence neural network on crowdsourced data, and that the policy can be further improved using on-policy reinforcement learning through self-play and Monte Carlo rollouts. Both Li et al. (2016) and Lewis et al. (2017) use self-play. Self-play is a viable option for training their policies because their problems are symmetric in the policy space (e.g. any policy performing well on one side of the negotiation game will also perform well on the other side). In contrast, self-play is unlikely to be an effective training method in our case, because the interactions are highly asymmetric: human users speak differently to our system than they would to humans and, further, they expect different answers. Liu &amp; Lane (2017) use model-free on-policy reinforcement learning to improve a system in a restaurant booking toy domain. For training the system policy, they employ a user simulator trained on real-world human-human dialogues. In particular, under the constraint that both the system and the user share the exact same reward function, they demonstrate that reinforcement learning can be used to improve both the system policy and the user simulator. In a related vein,  learn an end-to-end neural network system for playing a quiz game using off-policy reinforcement learning, where the environment is a game simulator. They demonstrate that combining reinforcement learning with dialogue state tracking labels yields superior performance.In all the work reviewed so far, user simulators have been defined as rule-based models (e.g. A.L.I.C.E.), parametric models (e.g. n-gram models, generative neural networks), or a combination of the two. In most cases, given a user simulator, the collected training data is discarded and the policy is learned directly from simulations with the user simulator. In contrast, the Abstract Discourse MDP that we propose is a non-parametric approach, which repeatedly uses the collected training data during policy training.Reinforcement learning has also been applied to teaching agents to communicate with each other in multi-agent environments (Foerster et al. 2016, Sukhbaatar et al. 2016, Lazaridou, Pham &amp; Baroni 2016, Lazaridou, Peysakhovich &amp; Baroni 2016, Mordatch &amp; Abbeel 2017 7 Future WorkOne important direction for future research is personalization, i.e. building a model of each user's personality, opinions and interests. This will allow the system to provide a better user experience by adapting the response models to known attributes of the user. We are in the process of implementing a state machine that given a user id, retrieves the relevant information attributes of the user from a database. If a particular user attribute is missing, then the state machine will ask the user for the relevant information and store it in the database. One important user attribute is the user's name. If no name is found in the database, the state machine may ask the user what they would like to be called and afterwards extracts the name from the user's response. If a personal name is detected, it is stored in the database to be available for other modules to insert into their responses. Name detection proceeds as follows. First we match the response against a small collection of templates, such as "my name is ..." or "call me ...". Then we use part-of-speech (POS) tags of the resulting matches to detect the end boundary of the name. To avoid clipping the name too early due to wrong POS tags, we also match words against a list of common names in the 1990 US Census data 27 .In the future, we plan to explore learning user embeddings from previous interactions with each user, since we know from previous experiments that text information alone contains a significant amount of information about the speaker's identity . Learning an embedding for each user will allow the system to become more personalized, by providing our response models with additional context beyond the immediate dialogue history.: It is well known that speech recognition errors have a significant impact on the user experience in dialogue systems ( Raux et al. 2006). Furthermore, speech recognition errors are likely to have a particularly averse effect on our system, because our system encourages open-ended, unrestricted conversations. Unlike many goal-driven and rule-based systems, our system does not take control of the dialogue or direct the user to respond with a keyword from a set of canned responses. 28 Because the users are more likely to give open-ended responses, the system is also more likely to suffer from speech recognition errors. As we discussed in Section 4, we did indeed observe a negative correlation between the confidences of the speech recognition system and the Alexa user scores. Moreover, it is likely that speech recognition errors have a stronger systematic effect on some of the policies evaluated in Section 5.To mitigate the issues of speech recognition errors, we plan to evaluate the system with different policies through a text-based evaluation on Amazon Mechanical Turk. This would also help reduce other problems, such as errors due to incorrect turn-taking (e.g. when the system barges in on the user, who is still speaking) ( Ward et al. 2005).We have proposed a new large-scale ensemble-based dialogue system framework for the Amazon Alexa Prize competition. Our system leverages a variety of machine learning techniques, including deep learning and reinforcement learning. We have developed a new set of deep learning models for natural language retrieval and generation, including recurrent neural networks, sequence-to-sequence models and latent variable models. In addition, we have developed a novel reinforcement learning procedure and evaluated it against existing reinforcement learning methods in A/B testing experiments with real-world users. These innovations have enabled us to make substantial improvements upon our baseline system. On a scale 1 − 5, our best performing system reached an average user score of 3.15, with a minimal amount of hand-crafted states and rules and without engaging in non-conversational activities (such as playing games or quizzes). The performance is substantially above the average of all teams in the competition semi-finals, which was only 2.92. Furthermore, the same system averaged a high 14.5 − 16.0 turns per conversation, which is substantially above both the average of all teams and the average of finalist teams in the competition semi-finals, suggesting that our system is one of the most engaging systems in the competition. Since nearly all our system components are trainable machine learning models, the system is likely to improve greatly with more interactions and additional data.were donated by the NVIDIA Corporation. The authors acknowledge NSERC, Canada Research Chairs, CIFAR, IBM Research, Nuance Foundation, Microsoft Maluuba and Druide Informatique Inc. for funding.
