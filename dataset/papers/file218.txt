This paper studies the fundamental problem of learning and inference in the generator network ( Goodfellow et al., 2014), which is a generative model that has become popular recently. Specifically, we propose an alternating back-propagation al- gorithm for learning and inference in this model.The generator network is a non-linear generalization of factor analysis. Factor analysis is a prototype model in unsuper- vised learning of distributed representations. There are two directions one can pursue in order to generalize the factor analysis model. One direction is to generalize the prior model or the prior assumption about the latent factors. This led to methods such as independent component analysis (Hyvärinen, Karhunen, and Oja, 2004), sparse coding (Olshausen and Field, 1997), non-negative matrix factorization ( Lee and Seung, 2001), matrix factorization and completion for recom- mender systems (Koren, Bell, and Volinsky, 2009), etc.The other direction to generalize the factor analysis model is to generalize the mapping from the continuous latent fac- tors to the observed signal. The generator network is an example in this direction. It generalizes the linear mapping in factor analysis to a non-linear mapping that is defined by † Equal contributions.The factor analysis model can be learned by the Rubin-Thayer EM algorithm (Rubin and Thayer, 1982;Dempster, Laird, and Rubin, 1977), where both the E-step and the M-step are based on multivariate linear regression. Inspired by this algo- rithm, we propose an alternating back-propagation algorithm for learning the generator network that iterates the following two-steps:(1) Inferential back-propagation: For each training exam- ple, infer the continuous latent factors by Langevin dynamics or gradient descent.(2) Learning back-propagation: Update the parameters given the inferred latent factors by gradient descent.The Langevin dynamics (Neal, 2011) is a stochastic sam- pling counterpart of gradient descent. The gradient computa- tions in both steps are powered by back-propagation. Because of the ConvNet structure, the gradient computation in step (1) is actually a by-product of the gradient computation in step (2) in terms of coding.Given the factors, the learning of the ConvNet is a su- pervised learning problem (Dosovitskiy, Springenberg, and Brox, 2015) that can be accomplished by the learning back- propagation. With factors unknown, the learning becomes an unsupervised problem, which can be solved by adding the inferential back-propagation as an inner loop of the learning process. We shall show that the alternating back-propagation algorithm can learn realistic generator models of natural im- ages, video sequences, and sounds.The alternating back-propagation algorithm follows the tradition of alternating operations in unsupervised learning, such as alternating linear regression in the EM algorithm for factor analysis, alternating least squares algorithm for matrix factorization (Koren, Bell, and Volinsky, 2009;Kim and Park, 2008), and alternating gradient descent algorithm for sparse coding (Olshausen and Field, 1997). All these unsupervised learning algorithms alternate an inference step and a learning step, as is the case with alternating back-propagation.The inferential back-propagation solves an inverse problem by an explaining-away process, where the latent factors com- pete with each other to explain each training example. The following are the advantages of the explaining-away infer- ence of the latent factors:(1) The latent factors may follow sophisticated prior mod- els. For instance, in textured motions ( Wang and Zhu, 2003) or dynamic textures ( Doretto et al., 2003), the latent factors may follow a dynamic model such as vector auto-regression. By inferring the latent factors that explain the observed ex- amples, we can learn the prior model.(2) The observed data may be incomplete or indirect. For instance, the training images may contain occluded objects. In this case, the latent factors can still be obtained by explain- ing the incomplete or indirect observations, and the model can still be learned as before.is the generative adversarial network (GAN) ( Goodfellow et al., 2014;Denton et al., 2015;Radford, Metz, and Chintala, 2016), where the assisting network is a discriminator network that plays an adversarial role against the generator network.Unlike alternating back-propagation, VAE does not per- form explicit explain-away inference, while GAN avoids inferring the latent factors altogether. In comparison, the al- ternating back-propagation algorithm is simpler and more basic, without resorting to an extra network. While it is dif- ficult to compare these methods directly, we illustrate the strength of alternating back-propagation by learning from incomplete and indirect data, where we only need to explain whatever data we are given. This may prove difficult or less convenient for VAE and GAN.Meanwhile, alternating back-propagation is complemen- tary to VAE and GAN training. It may use VAE to initialize the inferential back-propagation, and as a result, may im- prove the inference in VAE. The inferential back-propagation may help infer the latent factors of the observed examples for GAN, thus providing a method to test if GAN can explain the entire training set.The generator network is based on a top-down ConvNet. One can also obtain a probabilistic model based on a bottom- up ConvNet that defines descriptive features ( Xie et al., 2016;Lu, Zhu, and Wu, 2016).2.1 Factor analysis and beyondWe venture to propose that a main advantage of a generative model is to learn from incomplete or indirect data, which are not uncommon in practice. The generative model can then be evaluated based on how well it recovers the unobserved original data, while still learning a model that can generate new data. Learning the generator network from incomplete data can be considered a non-linear generalization of matrix completion.We also propose to evaluate the learned generator network by the reconstruction error on the testing data.and is a D-dimensional error vector or the observa- tional noise. We assume that Z ∼ N(0, I d ), where I d stands for the d-dimensional identity matrix. We also assume that ∼ N(0, σ 2 I D ), i.e., the observational errors are Gaussian white noises. There are three perspectives to view W . (1) Basis vectors. , where wThe main contribution of this paper is to propose the alter- nating back-propagation algorithm for training the generator network. Another contribution is to evaluate the generative models by learning from incomplete or indirect training data. Existing training methods for the generator network avoid explain-away inference of latent factors. Two methods have recently been devised to accomplish this. Both methods in- volve an assisting network with a separate set of parameters in addition to the original network that generates the sig- nals. One method is variational auto-encoder (VAE) (Kingma and Welling, 2014;Rezende, Mohamed, and Wierstra, 2014;Mnih and Gregor, 2014), where the assisting network is an in- ferential or recognition network that seeks to approximate the posterior distribution of the latent factors. The other method j is the j-th row of W . Then y j = j , Z + j , where y j and j are the j-th components of Y and respectively. Each y j is a loading of the d factors where w j is a vector of loading weights, indicating which factors are important for determin- ing y j . W is called the loading matrix.The factor analysis model can be learned by the Rubin- Thayer EM algorithm, which involves alternating regressions of Z on Y in the E-step and of Y on Z in the M-step, with both steps powered by the sweep operator (Rubin and Thayer, 1982;Liu, Rubin, and Wu, 1998).The factor analysis model is the prototype of many sub- sequent models that generalize the prior model of Z. (1) Independent component analysis (Hyvärinen, Karhunen, and Oja, 2004), d = D, = 0, and z k are assumed to follow independent heavy tailed distributions. (2) Sparse coding (Olshausen and Field, 1997), d &gt; D, and Z is assumed to be a redundant but sparse vector, i.e., only a small number of z k are non-zero or significantly different from zero. (3) Non-negative matrix factorization ( Lee and Seung, 2001), it is assumed that z k ≥ 0. (4) Recommender system (Koren, Bell, and Volinsky, 2009), Z is a vector of a customer's de- sires in different aspects, and w j is a vector of product j's desirabilities in these aspects.algorithm (Dempster, Laird, and Rubin, 1977), the complete- data model is given byIn addition to generalizing the prior model of the latent fac- tors Z, we can also generalize the mapping from Z to Y . In this paper, we consider the generator network model (Goodfellow et al., 2014) that retains the assumptions that d &lt; D, Z ∼ N(0, I d ), and ∼ N(0, σ 2 I D ) as in traditional fac- tor analysis, but generalizes the linear mapping W Z to a non-linear mapping f (Z; W ), where f is a ConvNet, and W collects all the connection weights and bias terms of the ConvNet. Then the model becomesThe observed-data model is obtained by integrating out Z:For the training data {Y i }, the complete-data log- likelihood is L(W,, where we assume σ 2 is given. Learning and inference can be ac- complished by maximizing the complete-data log-likelihood, which can be obtained by the alternating gradient descent algorithm that iterates the following two steps: (1) Inference step: update Z i by running l steps of gradient descent. (2) Learning step: update W by one step of gradient descent.A more rigorous method is to maximize the observed-data log-likelihood, which isThe reconstruction error is ||Y − f (Z; W )|| 2 . We may as- sume more sophisticated models for such as colored noise or non-Gaussian texture. If Y is binary, we can emit Y by a probability map P = 1/[1 + exp(−f (Z; W ))], where the sigmoid transformation and Bernoulli sampling are carried out pixel-wise. If Y is multi-level, we may assume multi- nomial logistic emission model or some ordinal emission model.Although f (Z; W ) can be any non-linear mapping, the ConvNet parameterization of f (Z; W ) makes it particularly close to the original factor analysis. Specifically, we can write the top-down ConvNet as follows:The observed-data log- likelihood takes into account the uncertainties in inferring Z i . See Appendix for an in-depth understanding.The gradient of L(W ) can be calculated according to the following well-known fact that underlies the EM algorithm:The expectation with respect to p(Z|Y, W ) can be approxi- mated by drawing samples from p(Z|Y, W ) and then com- puting the Monte Carlo average. The Langevin dynamics for sampling Z ∼ p(Z|Y, W ) iterates where f l is element-wise non-linearity at layer l, W l is the matrix of connection weights, b l is the vector of bias terms at layer l, andThe top-down ConvNet (2) can be considered a recursion of the original factor analysis model, where the factors at the layer l − 1 are obtained by the linear superpo- sition of the basis vectors or basis functions that are column vectors of W l , with the factors at the layer l serving as the co- efficients of the linear superposition. In the case of ConvNet, the basis functions are shift-invariant versions of one another, like wavelets. See Appendix for an in-depth understanding of the model.3 Alternating back-propagationIf we observe a training set of data vectors {Y i , i = 1, ..., n}, then each Y i has a corresponding Z i , but all the Y i share the same ConvNet W . Intuitively, we should infer {Z i } and learn W to minimize the reconstruction error2 plus a regularization term that corresponds to the prior on Z.More formally, the model can be written as Z ∼ p(Z) andAdopting the language of the EM where τ denotes the time step for the Langevin sampling, s is the step size, and U τ denotes a random vector that follows N(0, I d ). The Langevin dynamics (5) is an explain-away process, where the latent factors in Z compete to explain away the current residual Y − f (Z τ ; W ).To explain Langevin dynamics, its continuous time ver- sion for samplingThe dynamics has π as its station- ary distribution, because it can be shown that for any well- behaved testing function h, ifThe stochastic gradient algorithm of (Younes, 1999) can be used for learning, where in each iteration, for each Z i , only a single copy of Z i is sampled from p(Z i |Y i , W ) by running a finite number of steps of Langevin dynamics starting from the current value of Z i , i.e., the warm start. With {Z i } sampled in this manner, we can update the parameter W based on the gradient L (W ), whose Monte Carlo approximation is:is close to the prior N(0, I d ). If σ 2 is very small, then the posterior may be multi-modal, but the evolving energy land- scape of p(Z i |Y i , W ) may help alleviate the trapping of the local modes. In practice, we tune the value of σ 2 instead of estimating it. The Langevin dynamics can be extended to Hamiltonian Monte Carlo (Neal, 2011) or more sophisticated versions ( Girolami and Calderhead, 2011)Algorithm 1 describes the details of the learning and sam- pling algorithm.Require:(1) training examples {Y i , i = 1, ..., n} (2) number of Langevin steps l (3) number of learning iterations T Ensure:(1) learned parameters W (2) inferred latent factors {Z i , i = 1, ..., n}Inferential back-propagation: For each i, run l steps of Langevin dynamics to samplewith warm start, i.e., starting from the current Z i , each step follows equation (5).The code in our experiments is based on the MatConvNet package of ( Vedaldi and Lenc, 2015). The training images and sounds are scaled so that the inten- sities are within the range [−1, 1]. We adopt the structure of the generator network of (Radford, Metz, and Chintala, 2016;Dosovitskiy, Springenberg, and Brox, 2015), where the top- down network consists of multiple layers of deconvolution by linear superposition, ReLU non-linearity, and up-sampling, with tanh non-linearity at the bottom-layer (Radford, Metz, and Chintala, 2016) to make the signals fall within [−1, 1]. We also adopt batch normalization (Ioffe and Szegedy, 2015).We fix σ = .3 for the standard deviation of the noise vector We use l = 10 or 30 steps of Langevin dynamics within each learning iteration, and the Langevin step size s is set at .1 or .3. We run T = 600 learning iterations, with learning rate .0001, and momentum .5. The learning algorithm produces the learned network parameters W and the inferred latent factors Z for each signal Y in the end. The synthesized signals are obtained by f (Z; W ), where Z is sampled from the prior distribution N(0, I d ).Learning back-propagation:, where L (W ) is computed according to equation (6), with learning rate γ t .Let t ← t + 1 7: until t = T If the Gaussian noise U τ in the Langevin dynamics (5) is removed, then the above algorithm becomes the alternating gradient descent algorithm. It is possible to update both W and {Z i } simultaneously by joint gradient descent.Both the inferential back-propagation and the learn- ing back-propagation are guided by the residual The factors Z at the top layer form aimage Z is then transformed to Y by the top-down Con- vNet. We use d = 7 2 in the learning stage for all the texture experiments. In order to obtain the synthesized image, we randomly sample a 14 × 14 Z from N(0, I), and then expand the learned network W to generate the 448 × 448 synthesized image f (Z; W ).The training network is as follows. Starting from 7 × 7 image Z, the network has 5 layers of deconvolution with 5×5 kernels (i.e., linear superposition of 5 × 5 basis functions), with an up-sampling factor of 2 at each layer (i.e., the basis functions are 2 pixels apart). The number of channels in the first layer is 512 (i.e., 512 translation invariant basis functions), and is decreased by a factor 2 at each layer. The Langevin steps l = 10 with step size s = .1.  The latent factors Z form a sequence that follows N(0, I d ), with d = 6. The top-down network consists of 4 layers of deconvolution with kernels of size 1 × 25, and up-sampling factor of 10. The number of channels in the first layer is 256, and decreases by a factor of 2 at each layer. For synthesis, we start from a longer Gaussian white noise sequence Z with d = 12 and generate the synthesized sound by expanding the learned network. Figure 2 shows the waveforms of the observed sound signal in the first row and the synthesized sound signal in the second row.Experiment 3. Modeling object patterns. We model object patterns using the network structure that is essentially the same as the network for the texture model, except that we include a fully connected layer under the latent factors Z, In the first experiment, we learn a model where Z has two components, i.e., Z = (z 1 , z 2 ), and d = 2. The training data are 11 images of 6 tigers and 5 lions. After training the model, we generate images using the learned top-down ConvNet for 2 , where we discretize both z 1 and z 2 into 9 equally spaced values. The left panel of Figure 3 displays the synthesized images on the 9 × 9 panel.In the second experiment, we learn a model with d = 100 from 1000 face images randomly selected from the CelebA dataset ( Liu et al., 2015). The left panel of Figure 4 displays the images generated by the learned model. The middle panel displays the interpolation results. The images at the four cor- ners are generated by the Z vectors of four images randomly selected from the training set. The images in the middle are obtained by first interpolating the Z's of the four corner im- ages using the sphere interpolation (Dinh, Sohl-Dickstein, and Bengio, 2016) and then generating the images by the learned ConvNet.We also provide qualitative comparison with Deep Con- volutional Generative Adversarial Net (DCGAN) (Goodfellow et al., 2014;Radford, Metz, and Chintala, 2016). The right panel of Figure 3 shows the generated results for the lion-tiger dataset using 2-dimensional Z. The right panel of Figure 4 displays the generated results trained on 1000 aligned faces from celebA dataset, with d = 100. We use the code from https://github.com/carpedm20/ DCGAN-tensorflow, with the tuning parameters as in (Radford, Metz, and Chintala, 2016). We run T = 600 iterations as in our method.Experiment 4. Modeling dynamic patterns. We model a textured motion ( Wang and Zhu, 2003) or a dynamic tex- ture ( Doretto et al., 2003) by a non-linear dynamic system Y t = f (Z t ; W ) + t , and Z t+1 = AZ t + η t , where we as- sume the latent factors follow a vector auto-regressive model, where A is a d×d matrix, and η t ∼ N(0, Q) is the innovation. This model is a direct generalization of the linear dynamic system of ( Doretto et al., 2003), where Y t is reduced to Z t by principal component analysis (PCA) via singular value decomposition (SVD). We learn the model in two steps. (1) Treat {Y t } as independent examples and learn W and infer {Z t } as before. (2) Treat {Z t } as the training data, learn A and Q as in ( Doretto et al., 2003). After that, we can synthe- size a new dynamic texture. We start from Z 0 ∼ N(0, I d ), and then generate the sequence according to the learned model (we discard a burn-in period of 15 frames). Figure  5 shows some experiments, where we set d = 20. The first row is a segment of the sequence generated by our model, and the second row is generated by the method of ( Doretto et al., 2003), with the same dimensionality of Z. It is possible to generalize the auto-regressive model of Z t to recurrent net- work. We may also treat the video sequences as 3D images, and learn generator networks with 3D spatial-temporal filters or basis functions. puted by summing over all the pixels. For a partially observed image, we compute it by summing over only the observed pixels. Then we can continue to use the alternating back- propagation algorithm to infer Z and learn W . With inferred Z and learned W , the image can be automatically recovered by f (Z; W ). In the end, we will be able to accomplish the following tasks: (T1) Recover the occluded pixels of training images. (   Experiment 5. Learning from incomplete data. Our method can learn from images with occluded pixels. This task is inspired by the fact that most of the images contain occluded objects. It can be considered a non-linear generalization of matrix completion in recommender system.Our method can be adapted to this task with minimal mod- ification. The only modification involves the computation of − f (Z; W ) 2 . For a fully observed image, it is com- We want to emphasize that in our experiments, all the training images are partially occluded. Our experiments are different from (1) de-noising auto-encoder ( Vincent et al., 2008), where the training images are fully observed, and noises are added as a matter of regularization, (2) in-painting or de-noising, where the prior model or regularization has al- ready been learned or given. (2) is about task (T3) mentioned above, but not about tasks (T1) and (T2).Learning from incomplete data can be difficult for GAN and VAE, because the occluded pixels are different for differ- ent training images.We evaluate our method on 10,000 images randomly se- lected from CelebA dataset. We design 5 experiments, with two types of occlusions: (1) 3 experiments are about salt and pepper occlusion, where we randomly place 3 × 3 masks on the 64 × 64 image domain to cover roughly 50%, 70% and 90% of pixels respectively. These 3 experiments are denoted P.5, P.7, and P.9 respectively (P for pepper). (2) 2 experiments are about single region mask occlusion, where we randomly place a 20×20 or 30×30 mask on the 64×64 image domain. These 2 experiments are denoted M20 and M30 respectively (M for mask). We set d = 100. Table 1 displays the recovery errors of the 5 experiments, where the error is defined as per pixel difference (relative to the range of the pixel values) between the original image and the recovered image on the occluded pixels. We emphasize that the recovery errors are not training errors, because the intensities of the occluded pixels are not observed in training. Figure 6 displays recovery results. In experiment P.9, 90% of pixels are occluded, but we can still learn the model and recover the original images.  Table 3: Reconstruction errors on testing images, after learn- ing from training images using our method (ABP) and PCA.   Experiment 6. Learning from indirect data. We can learn the model from the compressively sensed data (Candès, Romberg, and Tao, 2006). We generate a set of white noise images as random projections. We then project the train- ing images on these white noise images. We can learn the model from the random projections instead of the origi- nal images. We only need to replace − f (Z; W ) 2 by − Sf (Z; W ) 2 , where S is the given white noise sens- ing matrix, and SY is the observation. We can treat S as a fully connected layer of known filters below f (Z; W ), so that we can continue to use alternating back-propagation to infer Z and learn W , thus recovering the image by f (Z; W ). In the end, we will be able to (T1) Recover the original images from their projections during learning. (T2) Synthesize new images from the learned model. (T3) Recover testing images from their projections based on the learned model. Our ex- periments are different from traditional compressed sensing, which is task (T3), but not tasks (T1) and (T2). Moreover, the image recovery in our work is based on non-linear dimension reduction instead of linear sparsity.We evaluate our method on 1000 face images randomly selected from CelebA dataset. These images are projected onto K = 1000 white noise images with each pixel randomly sampled from N(0, .5 2 ). After this random projection, each image of size 64 × 64 × 3 becomes a K-dimensional vector. We show the recovery errors for different latent dimensions d in Table 2, where the recovery error is defined as the per pixel difference (relative to the range of the pixel values) between the original image and the recovered image. Figure 7 shows some recovery results.Experiment 7. Model evaluation by reconstruction error on testing data. After learning the model from the training images (now assumed to be fully observed), we can evaluate the model by the reconstruction error on the testing images. We randomly select 1000 face images for training and 300 images for testing from CelebA dataset. After learning, we infer the latent factors Z for each testing image using inferen- tial back-propagation, and then reconstruct the testing image by f (Z; W ) using the inferred Z and the learned W . In the inferential back-propagation for inferring Z, we initialize Z ∼ N(0, I d ), and run 300 Langevin steps with step size .05. Table 3 shows the reconstruction errors of alternating back- propagation learning (ABP) as compared to PCA learning for different latent dimensions d. Figure 8 shows some recon- structed testing images. For PCA, we learn the d eigenvectors from the training images, and then project the testing images on the learned eigenvectors for reconstruction.Experiments 5-7 may be used to evaluate generative mod- els in general. Experiments 5 and 6 appear new, and we have not found comparable methods that can accomplish all three tasks (T1), (T2), and (T3) simultaneously.This paper proposes an alternating back-propagation algo- rithm for training the generator network. We recognize that the generator network is a non-linear generalization of the factor analysis model, and develop the alternating back- propagation algorithm as the non-linear generalization of the alternating regression scheme of the Rubin-Thayer EM algorithm for fitting the factor analysis model. The alternat- ing back-propagation algorithm iterates the inferential back- propagation for inferring the latent factors and the learning back-propagation for updating the parameters. Both back- propagation steps share most of their computing steps in the chain rule calculations.Our learning algorithm is perhaps the most canonical al- gorithm for training the generator network. It is based on maximum likelihood, which is theoretically the most accu- rate estimator. The maximum likelihood learning seeks to explain and charge the whole dataset uniformly, so that there is little concern of under-fitting or biased fitting.As an unsupervised learning algorithm, the alternating back-propagation algorithm is a natural generalization of the original back-propagation algorithm for supervised learn- ing. It adds an inferential back-propagation step to the learn-ing back-propagation step, with minimal overhead in cod- ing and affordable overhead in computing. The inferential back-propagation seeks to perform accurate explaining-away inference of the latent factors. It can be worthwhile for tasks such as learning from incomplete or indirect data, or learning models where the latent factors themselves follow sophisti- cated prior models with unknown parameters. The inferential back-propagation may also be used to evaluate the generators learned by other methods on tasks such as reconstructing or completing testing data.Our method or its variants can be applied to non-linear matrix factorization and completion. It can also be applied to problems where some components or aspects of the factors are supervised. Y = W δ Z + b δ + for an overall bias term that depends on δ. So the distribution of Y is essentially piecewise Gaussian.The generator model can be considered an explicit imple- mentation of the local linear embedding (Roweis and Saul, 2000), where Z is the embedding of Y . In local linear em- bedding, the mapping between Z and Y is implicit. In the generator model, the mapping from Z to Y is explicit. With ReLU ConvNet, the mapping is piecewise linear, which is consistent with local linear embedding, except that the parti- tion of the linear pieces by δ(Z; W ) in the generator model is learned automatically.The inferential back-propagation is a Langevin dynamics on the energy functionIf Z be- longs to the piece defined by δ, then the inferential back- propagation seeks to approximate Y by the basis W δ via a ridge regression. Because Z keeps changing during the Langevin dynamics, δ(Z; W ) may also be changing, and the algorithm searches for the optimal reconfigurable basis W δ to approximate Y . We may solve Z by second-order methods such as iterated ridge regression, which can be computation- ally more expensive than the simple gradient descent.6.2 EM, density mapping, and density shifting 6 AppendixSuppose the training data {Y i , i = 1, ..., n} come from a data distribution P data (Y ). To understand how the alternat- ing back-propagation algorithm or its EM idealization maps the prior distribution of the latent factors p(Z) to the data distribution P data (Y ) by the learned g(Z; W ), we define, and Z (L) = Z. The element-wise non-linearity f l in modern ConvNet is usually the two-piece linearity, such as rectified linear unit (ReLU) (Krizhevsky, Sutskever, and Hinton, 2012) or the leaky ReLU (Maas, Hannun, and Ng, 2013;Xu et al., 2015). Each ReLU unit corresponds to a binary switch. For the case of non-leaky ReLU, following the analysis of (Pascanu, Montufar, and Bengio, 2013), we can writeFor the case of leaky ReLU, the 0 values on the diagonal are replaced by a leaking factor (e.g., .2). δ = (δ l , l = 1, ..., L) forms a classification of Z ac- cording to the network W . Specifically, the factor space of Z is divided into a large number of pieces by the hy- perplanes W l Z (l) + b l = 0, and each piece is indexed by an instantiation of δ. We can write δ = δ(Z; W ) to make explicit its dependence on Z and W . On the piece indexed by δ, f (Z; W ) = W δ Z + b δ . Assuming b l = 0, ∀l, for simplicity, we have W δ = δ 1 W 1 ...δ L W L . Thus each piece defined by δ = δ(Z; W ) corresponds to a linear factor analysis Y = W δ Z + whose basis W δ is a multiplica- tive recomposition of the basis functions at multiple layers (W l , l = 1, ..., L), and the recomposition is controlled by the binary switches at multiple layers δ = (δ l , l = 1, ..., L). Hence the top-down ConvNet amounts to a reconfigurable basis W δ for representing Y , and the model is a piecewise linear factor analysis. If we retain the bias term, we will havewhere P data (Z; W ) = p(Z|Y, W )P data (Y )dY is ob- tained by averaging the posteriors p(Z|Y ; W ) over the ob- served data Y ∼ P data . That is, P data (Z; W ) can be consid- ered the data prior. The data prior P data (Z; W ) is close to the true prior p(Z) in the sense thatThe right hand side of (8) is minimized at the maximum likelihood estimatê W , hence the data prior P data (Z; ˆ W ) atˆW atˆ atˆW should be especially close to the true prior p(Z). In other words, atˆWatˆ atˆW , the posteriors p(Z|Y, ˆ W ) of all the data points Y ∼ P data tend to pave the true prior p(Z).From Rubin's multiple imputation point of view ( Rubin, 2004) of the EM algorithm, the E-step of EM infers Z The EM algorithm is a process of density shifting, so that P data (Z; W ) shifts towards p(Z), thus g(Z; W ) maps p(Z) to P data (Y ).If σ 2 is unknown, it can be obtained by averaging the diagonal elements of Σ. The computation can again be done by the sweep operator on S, with S ZZ being the pivotal matrix.The E-step is based on the multivariate linear regression of Z on Y given W . The M-step updates W by the multivariate linear regression of Y on Z. Both steps can be accomplished by the sweep operator. We use the notation S and S for the Gram matrices to highlight the analogy between the two steps. The EM algorithm can then be considered alternating linear regression or alternating sweep operation, which serves as a prototype for alternating back-propagation.The alternating back-propagation algorithm is inspired by Rubin-Thayer EM algorithm for factor analysis, where both the observed data model p(Y |W ) and the posterior distri- bution p(Z|Y, W ) are available in closed form. The EM al- gorithm for factor analysis can be interpreted as alternating linear regression (Rubin and Thayer, 1982;Liu, Rubin, and Wu, 1998).In the factor analysis model Z ∼ N(0, Dinh, L.; Sohl-Dickstein, J.; and Bengio, S. 2016. Density estimation using real nvp. CoRR abs/1605.08803.Doretto, G.; Chiuso, A.; Wu, Y.; and Soatto, S. 2003. Dy- namic textures. IJCV 51(2):91-109. The above computation can be carried out by the sweep operator on S, with S Y Y being the pivotal matrix. Suppose we have observations {Y i , i = 1, ..., n}. In the E-step, we compute Girolami, M., and Calderhead, B. 2011. Riemann manifold langevin and hamiltonian monte carlo methods. Journal of the Royal Statistical Society: B 73(2):123-214. Goodfellow, I.; Pouget-Abadie, J.; Mirza, M.; Xu, B.;WardeFarley, D.;Ozair, S.;Courville, A.;and Bengio, Y. 2014. Generative adversarial nets. In NIPS, 2672-2680.In the M-step, we compute Hyvärinen, A.;Karhunen, J.;andOja, E. 2004. Independent component analysis. John Wiley &amp; Sons. Ioffe, S., andSzegedy, C. 2015. Batch normalization: Accel- erating deep network training by reducing internal covari- ate shift. In ICML. Krizhevsky, A.; Sutskever, I.; and Hinton, G. E. 2012. Im- agenet classification with deep convolutional neural net- works. In NIPS, 1097-1105.
