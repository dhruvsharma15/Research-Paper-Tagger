Neural architecture search (NAS) has been successfully ap- plied to design model architectures for image classifica- tion and language models (Zoph &amp; Le, 2017;Zoph et al., 2018;Cai et al., 2018;Liu et al., 2017;. In NAS, an RNN controller is trained in a loop: the controller first samples a candidate architecture, i.e. a child model, and then trains it to convergence to measure its performance on the task of desire. The controller then uses the perfor- mance as a guiding signal to find more promising architec- tures. This process is repeated for many iterations. De- We empirically show that not only is sharing parame- ters among child models possible, but it also allows for very strong performance. Specifically, on CIFAR-10, our method achieves a test error of 2.89%, compared to 2.65% by NAS. On Penn Treebank, our method achieves a test per- plexity of 55.8, which significantly outperforms NAS's test perplexity of 62.4 (Zoph &amp; Le, 2017) and which is a new state-of-the-art among Penn Treebank's approaches that do not utilize post-training processing. Importantly, in all of our experiments, for which we use a single Nvidia GTX 1080Ti GPU, the search for architectures takes less than 16 hours. Compared to NAS, this is a reduction of GPU-hours by more than 1000x. Due to its efficiency, we name our method Efficient Neural Architecture Search (ENAS). Central to the idea of ENAS is the observation that all of the graphs which NAS ends up iterating over can be viewed as sub-graphs of a larger graph. In other words, we can represent NAS's search space using a single directed acyclic graph (DAG). Figure 2 illustrates a generic exam- ple DAG, where an architecture can be realized by taking a subgraph of the DAG. Intuitively, ENAS's DAG is the su-  To create a recurrent cell, the controller RNN samples N blocks of decisions. Here we illustrate the ENAS mecha- nism via a simple example recurrent cell with N = 4 com- putational nodes (visualized in Figure 1). Let x t be the input signal for a recurrent cell (e.g. word embedding), and h t−1 be the output from the previous time step. We sample as follows.perposition of all possible child models in a search space of NAS, where the nodes represent the local computations and the edges represent the flow of information. The lo- cal computations at each node have their own parameters, which are used only when the particular computation is ac- tivated. Therefore, ENAS's design allows parameters to be shared among all child models, i.e. architectures, in the search space. In the following, we facilitate the discussion of ENAS with an example that illustrates how to design a cell for recur- rent neural networks from a specified DAG and a controller (Section 2.1). We will then explain how to train ENAS and how to derive architectures from ENAS's controller (Sec- tion 2.2). Finally, we will explain our search space for de- signing convolutional architectures (Sections 2.3 and 2.4). To design recurrent cells, we employ a DAG with N nodes, where the nodes represent local computations, and the edges represent the flow of information between the N nodes. ENAS's controller is an RNN that decides: 1) which edges are activated and 2) which computations are per- formed at each node in the DAG. This design of our search space for RNN cells is different from the search space for RNN cells in Zoph &amp; Le (2017), where the authors fix the topology of their architectures as a binary tree and only learn the operations at each node of the tree. In contrast, our search space allows ENAS to design both the topology 5. For the output, we simply average all the loose ends, i.e. the nodes that are not selected as inputs to any other nodes. In our example, since the indices 3 and 4 were never sampled to be the input for any node, the recurrent cell uses their average (h3 + h4)/2 as its output. In other words, ht = (h3 + h4)/2.In the example above, we note that for each pair of nodes j &lt; ℓ, there is an independent parameter matrix W (h) ℓ,j . As shown in the example, by choosing the previous indices, the controller also decides which parameter matrices are used. Therefore, in ENAS, all recurrent cells in a search space share the same set of parameters.Our search space includes an exponential number of con- figurations. Specifically, if the recurrent cell has N nodes and we allow 4 activation functions (namely tanh, ReLU, identity, and sigmoid), then the search space has 4 N × N ! configurations. In our experiments, N = 12, which means there are approximately 10 15 models in our search space.mize the expected reward E m∼π(m;θ) [R(m, ω)]. We em- ploy the Adam optimizer (Kingma &amp; Ba, 2015), for which the gradient is computed using REINFORCE (Williams, 1992), with a moving average baseline to reduce variance.Our controller network is an LSTM with 100 hidden units (Hochreiter &amp; Schmidhuber, 1997). This LSTM sam- ples decisions via softmax classifiers, in an autoregressive fashion: the decision in the previous step is fed as input em- bedding into the next step. At the first step, the controller network receives an empty embedding as input.The reward R(m, ω) is computed on the validation set, rather than on the training set, to encourage ENAS to select models that generalize well rather than models that overfit the training set well. In our language model experiment, the reward function is c/valid ppl, where the perplexity is computed on a minibatch of validation data. In our image classification experiments, the reward function is the accu- racy on a minibatch of validation images.In ENAS, there are two sets of learnable parameters: the parameters of the controller LSTM, denoted by θ, and the shared parameters of the child models, denoted by ω. The training procedure of ENAS consists of two interleaving phases. The first phase trains ω, the shared parameters of the child models, on a whole pass through the training data set. For our Penn Treebank experiments, ω is trained for about 400 steps, each on a minibatch of 64 examples, where the gradient ∇ ω is computed using back-propagation through time, truncated at 35 time steps. Meanwhile, for CIFAR-10, ω is trained on 45, 000 training images, sepa- rated into minibatches of size 128, where ∇ ω is computed using standard back-propagation. The second phase trains θ, the parameters of the controller LSTM, for a fixed num- ber of steps, typically set to 2000 in our experiments. These two phases are alternated during the training of ENAS. More details are as follows.Deriving Architectures. We discuss how to derive novel architectures from a trained ENAS model. We first sam- ple several models from the trained policy π(m, θ). For each sampled model, we compute its reward on a single minibatch sampled from the validation set. We then take only the model with the highest reward to re-train from scratch. It is possible to improve our experimental results by training all the sampled models from scratch and se- lecting the model with the highest performance on a sep- arated validation set, as done by other works (Zoph &amp; Le, 2017;Zoph et al., 2018;Liu et al., 2017;. However, our method yields similar performance whilst being much more economical.Training the shared parameters ω of the child models.In this step, we fix the controller's policy π(m; θ) and perform stochastic gradient descent (SGD) on ω to mini- mize the expected loss function E m∼π [L(m; ω)]. Here, L(m; ω) is the standard cross-entropy loss, computed on a minibatch of training data, with a model m sampled from π(m; θ). The gradient is computed using the Monte Carlo estimatewhere m i 's are sampled from π(m; θ) as described above. Eqn 1 provides an unbiased estimate of the gradientHowever, this estimate has a higher variance than the standard SGD gradient, where m is fixed. Nevertheless -and this is perhaps surprising -we find that M = 1 works just fine, i.e. we can update ω us- ing the gradient from any single model m sampled from π(m; θ). As mentioned, we train ω during a entire pass through the training data. Training the controller parameters θ. In this step, we fix ω and update the policy parameters θ, aiming to maxi- We now discuss the search space for convolutional architec- tures. Recall that in the search space of the recurrent cell, the controller RNN samples two decisions at each decision block: 1) what previous node to connect to and 2) what activation function to use. In the search space for convolu-tional models, the controller RNN also samples two sets of decisions at each decision block: 1) what previous nodes to connect to and 2) what computation operation to use. These decisions construct a layer in the convolutional model.The decision of what previous nodes to connect to al- lows the model to form skip connections ( He et al., 2016a;Zoph &amp; Le, 2017). Specifically, at layer k, up to k−1 mutu- ally distinct previous indices are sampled, leading to 2 the current node and 2) two operations to apply to the two sampled nodes. The 5 available operations are: identity, separable convolution with kernel size 3 × 3 and 5 × 5, and average pooling and max pooling with kernel size 3 × 3. At each node, after the previous nodes and their corresponding operations are sampled, the operations are applied on the previous nodes, and their results are added.k−1 possible decisions at layer k. We provide an illustrative ex- ample of sampling a convolutional network in Figure 3. In this example, at layer k = 4, the controller samples pre- vious indices {1, 3}, so the outputs of layers 1 and 3 are concatenated along their depth dimension and sent to layer 4.Meanwhile, the decision of what computation operation to use sets a particular layer into convolution or average pool- ing or max pooing. The 6 operations available for the con- troller are: convolutions with filter sizes 3 × 3 and 5 × 5, depthwise-separable convolutions with filter sizes 3×3 and 5×5 (Chollet, 2017), and max pooling and average pooling of kernel size 3 × 3. As for recurrent cells, each operation at each layer in our ENAS convolutional network has a dis- tinct set of parameters.Making the described set of decisions for a total of L times, we can sample a network of L layers. Since all decisions are independent, there are 6 L × 2 L(L−1)/2 networks in the search space. In our experiments, L = 12, resulting in 1.6 × 10 29 possible networks.Rather than designing the entire convolutional network, one can design smaller modules and then connect them to- gether to form a network ( Zoph et al., 2018). Figure 4 illus- trates this design, where the convolutional cell and reduc- tion cell architectures are to be designed. We now discuss how to use ENAS to search for the architectures of these cells. As before, we illustrate the mechanism of our search space with an example, here with B = 4 nodes (refer to Figure 5). Details are as follows. 1. Nodes 1, 2 are input nodes, so no decisions are needed for them. Let h1, h2 be the outputs of these nodes.We utilize the ENAS computational DAG with B nodes to represent the computations that happen locally in a cell.In this DAG, node 1 and node 2 are treated as the cell's inputs, which are the outputs of the two previous cells in the final network (see Figure 4). For each of the remaining B − 2 nodes, we ask the controller RNN to make two sets of decisions: 1) two previous nodes to be used as inputs to 2. At node 3: the controller samples two previous nodes and two operations. In Figure 5 Top Left, it samples node 2, node 2, separable conv 5x5, and identity. This means that h3 = sep conv 5x5(h2) + id(h2).3. At node 4: the controller samples node 3, node 1, avg pool 3x3, and sep conv 3x3. This means that h4 = avg pool 3x3(h3) + sep conv 3x3(h1).4. Since all nodes but h4 were used as inputs to at least another node, the only loose end, h4, is treated as the cell's output.If there are multiple loose ends, they will be concatenated along the depth dimension to form the cell's output.A reduction cell can also be realized from the search space we discussed, simply by: 1) sampling a computational graph from the search space, and 2) applying all opera- tions with a stride of 2. A reduction cell thus reduces the spatial dimensions of its input by a factor of 2. Follow- ing Zoph et al. (2018), we sample the reduction cell con- ditioned on the convolutional cell, hence making the con- troller RNN run for a total of 2(B − 2) blocks. Finally, we estimate the complexity of this search space. At node i (3 ≤ i ≤ B), the controller can select any two nodes from the i − 1 previous nodes, and any two opera- tions from 5 operations. As all decisions are independent, there are (5 × (B − 2)!)2 possible cells. Since we inde- pendently sample for a convolutional cell and a reduction cell, the final size of the search space is (5 × (B − 2)!) 4 . With B = 7 as in our experiments, the search space can realize 1.3 × 10 11 final networks, making it significantly smaller than the search space for entire convolutional net- works (Section 2.3).2,1 ) and ⊗ denotes elementwise multipli- cation.The shared parameters of the child models ω are trained us- ing SGD with a learning rate of 20.0, decayed by a factor of 0.96 after every epoch starting at epoch 15, for a total of 150 epochs. We clip the norm of the gradient ∇ ω at 0.25. We find that using a large learning rate whilst clip- ping the gradient norm at a small threshold makes the up- dates on ω more stable. We utilize three regularization tech- niques on ω: an ℓ 2 regularization weighted by 10 −7 ; varia- tional dropout (Gal &amp; Ghahramani, 2016); and tying word embeddings and softmax weights (Inan et al., 2017). More details are in Appendix A.We first present our experimental results from employ- ing ENAS to design recurrent cells on the Penn Treebank dataset and convolutional architectures on the CIFAR-10 dataset. We then present an ablation study which asserts the role of ENAS in discovering novel architectures.Dataset and Settings. Penn Treebank ( Marcus et al., 1994) is a well-studied benchmark for language model. We use the standard pre-processed version of the dataset, which is also used by previous works, e.g. Zaremba et al. (2014).Results. Running on a single Nvidia GTX 1080Ti GPU, ENAS finds a recurrent cell in about 10 hours. In Table 1, we present the performance of the ENAS cell as well as other baselines that do not employ post-training processing. The ENAS cell achieves a test perplexity of 55.8, which is on par with the existing state-of-the-art of 56.0 achieved by Mixture of Softmaxes (MoS) ( Yang et al., 2018). Note that we do not apply MoS to the ENAS cell. Importantly, ENAS cell outperforms NAS (Zoph &amp; Le, 2017) by more than 6 perplexity points, whilst the search process of ENAS, in terms of GPU hours, is more than 1000x faster.Since the goal of our work is to discover cell architectures, we only employ the standard training and test process on Penn Treebank, and do not utilize post-training techniques such as neural cache ( Grave et al., 2017) and dynamic eval- uation ( Krause et al., 2017). Additionally, as Collins et al. (2017) have established that RNN models with more param- eters can learn to store more information, we limit the size of our ENAS cell to 24M parameters. We also do not tune our hyper-parameters extensively like Melis et al. (2017), nor do we train multiple architectures and select the best one based on their validation perplexities like Zoph &amp; Le (2017). Therefore, ENAS is not at any advantage, com- pared to Zoph &amp; Le (2017); Yang et al. (2018); Melis et al. (2017), and its improved performance is only due to the cell's architecture. Our ENAS cell, visualized in Figure 6, has a few interest- ing properties. First, all non-linearities in the cell are ei- ther ReLU or tanh, even though the search space also has two other functions: identity and sigmoid. Second, we sus- pect this cell is a local optimum, similar to the observations made by Zoph &amp; Le (2017). When we randomly pick some nodes and switch the non-linearity into identity or sigmoid, the perplexity increases up to 8 points. Similarly, when we randomly switch some ReLU nodes into tanh or vice versa, the perplexity also increases, but only up to 3 points. Third, as shown in Figure 6, the output of our ENAS cell is an average of 6 nodes. This behavior is similar to that of Mix- ture of Contexts (MoC) ( Yang et al., 2018). Not only does ENAS independently discover MoC, but it also learns to balance between i) the number of contexts to mix, which increases the model's expressiveness, and ii) the depth of the recurrent cell, which learns more complex transforma- tions ( Zilly et al., 2017).The policy parameters θ are initialized uniformly in [−0.1, 0.1], and trained with Adam at a learning rate of 0.00035. Similar to the procedure in Section 3.1, we ap- ply a tanh constant of 2.5 and a temperature of 5.0 to the controller's logits, and add the controller entropy to the re- ward, weighted by 0.1. Additionally, in the macro search space, we enforce the sparsity in the skip connections by adding to the reward the KL divergence between: 1) the skip connection probability between any two layers and 2) our chosen probability ρ = 0.4, which represents the prior belief of a skip connection being formed. This KL diver- gence term is weighted by 0.8. More training details are in Appendix B.Dataset. The CIFAR-10 dataset (Krizhevsky, 2009) con- sists of 50, 000 training images and 10, 000 test images. We use the standard data pre-processing and augmentation techniques, i.e. subtracting the channel mean and dividing the channel standard deviation, centrally padding the train- ing images to 40 × 40 and randomly cropping them back to 32 × 32, and randomly flipping them horizontally.Search spaces. We apply ENAS to two search spaces: 1) the macro search space over entire convolutional models (Section 2.3); and 2) the micro search space over convolu- tional cells (Section 2.4).Results. Table 2 summarizes the test errors of ENAS and other approaches. In this table, the first block presents the results of DenseNet ( Huang et al., 2016), one of the highest-performing architectures that are designed by human experts. When trained with a strong reg- ularization technique, such as Shake-Shake (Gastaldi, 2016), and a data augmentation technique, such as CutOut (DeVries &amp; Taylor, 2017), DenseNet impressively achieves the test error of 2.56%.Training details. The shared parameters ω are trained with Nesterov momentum (Nesterov, 1983), where the learning rate follows the cosine schedule with l max = 0.05, l min = 0.001, T 0 = 10, and T mul = 2 (Loshchilov &amp; Hutter, 2017). Each architecture search is run for 310 epochs. We initialize ω with He initialization ( He et al., 2015). We also apply an ℓ 2 weight decay of 10 −4 . We train the architec- tures recommended by the controller using the same set- tings.The second block of Table 2 presents the performances of approaches that attempt to design an entire convolu- tional network, along with the the number of GPUs and the time these methods take to discover their final models. As shown, ENAS finds a network architecture, which we visualize in Figure 7, and which achieves 4.23% test error. This test error is better than the error of 4.47%, achieved by the second best NAS model (Zoph &amp; Le, 2017). If we keep the architecture, but increase the number of filters in the network's highest layer to 512, then the test error decreases to 3.87%, which is not far away from NAS's best model, whose test error is 3.65%. Impressively, ENAS takes about 7 hours to find this architecture, reducing the number of   GPU-hours by more than 50,000x compared to NAS.The third block of Table 2 presents the performances of approaches that attempt to design one more more modules and then connect them together to form the final networks. ENAS takes 11.5 hours to discover the convolution cell and the reduction cell, which are visualized in Figure 8. With the convolutional cell replicated for N = 6 times (c.f. Figure 4), ENAS achieves 3.54% test error, on par with the 3.41% error of NASNet-A ( Zoph et al., 2018). With CutOut (DeVries &amp; Taylor, 2017), ENAS's error decreases to 2.89%, compared to 2.65% by NASNet-A.In addition to ENAS's strong performance, we also find that the models found by ENAS are, in a sense, the lo- cal minimums in their search spaces. In particular, in the model that ENAS finds from the marco search space, if we replace all separable convolutions with normal convo- lutions, and then adjust the model size so that the number of parameters stay the same, then the test error increases by 1.7%. Similarly, if we randomly change several connec- tions in the cells that ENAS finds in the micro search space, the test error increases by 2.1%. This behavior is also ob- served when ENAS searches for recurrent cells (c.f. Sec- tion 3.1), as well as in Zoph &amp; Le (2017 Disabling ENAS Search. In addition to random search, we attempt to train only the shared parameters ω without updating the controller. We conduct this study for our macro search space (Section 2.3), where the effect of an untrained random controller is similar to dropout with a rate of 0.5 on the skip connections, and to drop-path on the operations ( Zoph et al., 2018;Larsson et al., 2017). At convergence, the model has the error rate of 8.92%. On the validation set, an ensemble of 250 Monte Carlo configura- tions of this trained model can only reach 5.49% test error. We therefore conclude that the appropriate training of the ENAS controller is crucial for good performance.There is a growing interest in improving the efficiency of NAS. Concurrent to our work are the promising ideas of using performance prediction ( Baker et al., 2017b;Deng et al., 2017), using iterative search method for archi- tectures of growing complexity ( Liu et al., 2017), and us- ing hierarchical representation of architectures ( Liu et al., 2018). Table 2 shows that ENAS is significantly more effi- cient than these other methods, in GPU hours. A question regarding ENAS's importance is whether ENAS is actually capable of finding good architectures, or if it is the design of the search spaces that leads to ENAS's strong empirical performance.is inspired by the concept of weight inheritance in neu- ral model evolution ( Real et al., 2017;. Addition- ally, ENAS's choice of representing computations using a DAG is inspired by the concept of stochastic compu- tational graph ( Schulman et al., 2015), which introduces nodes with stochastic outputs into a computational graph. ENAS's utilizes such stochastic decisions in a network to make discrete architectural decisions that govern sub- sequent computations in the network, trains the decision maker, i.e. the controller, and finally harvests the decisions to derive architectures.Comparing to Guided Random Search. We uniformly sample a recurrent cell, an entire convolutional network, and a pair of convolutional and reduction cells from their search spaces and train them to convergence using the same settings as the architectures found by ENAS. For the macro space over entire networks, we sample the skip connec- tions with an activation probability of 0.4, effectively bal- ancing ENAS's advantage from the KL divergence term in its reward (see Section 3.2). Our random recurrent cell achieves the test perplexity of 81.2 on Penn Treebank, which is far worse than ENAS's perplexity of 55.8. Our ran- dom convolutional network reaches 5.86% test error, and our two random cells reache 6.77% on CIFAR-10, whileClosely related to ENAS is SMASH ( Brock et al., 2018), which designs an architecture and then uses a hypernet- work ( Ha et al., 2017) to generate its weight. Such us- age of the hypernetwork in SMASH inherently restricts the weights of SMASH's child architectures to a low-rank space. This is because the hypernetwork generates weights for SMASH's child models via tensor products ( Ha et al., 2017), which suffer from a low-rank restriction as for ar- bitrary matrices A and B, one always has the inequality: rank(A · B) ≤ min {rank(A), rank(B)}. Due to this limit, SMASH will find architectures that perform well in the re- stricted low-rank space of their weights, rather than archi- tectures that perform well in the normal training setups, where the weights are no longer restricted. Meanwhile, ENAS allows the weights of its child models to be arbitrary, effectively avoiding such restriction. We suspect this is the reason behind ENAS's superior empirical performance to SMASH. In addition, it can be seen from our experiments that ENAS can be flexibly applied to multiple search spaces and disparate domains, e.g. the space of RNN cells for the text domain, the macro search space of entire networks, and the micro search space of convolutional cells for the image domain.Chollet, Francois. Xception: Deep learning with depthwise separable convolutions. In CVPR, 2017.Collins, Jasmine, Sohl-Dickstein, Jascha, and Sussillo, David. Capacity and trainability in recurrent neural net- works. In ICLR, 2017.Deng, Boyang, Yan, Junjie, and Lin, Dahua. Peephole: Predicting network performance before training. Arxiv, 1705Arxiv, .10823, 2017 NAS is an important advance that automatizes the design- ing process of neural networks. However, NAS's com- putational expense prevents it from being widely adopted.In this paper, we presented ENAS, a novel method that speeds up NAS by more than 1000x, in terms of GPU hours. ENAS's key contribution is the sharing of parame- ters across child models during the search for architectures. This insight is implemented by searching for a subgraph within a larger graph that incorporates architectures in a search space. We showed that ENAS works well on both CIFAR-10 and Penn Treebank datasets.DeVries, Terrance and Taylor, Graham W. Improved regu- larization of convolutional neural networks with cutout. Arxiv, 1708.04552, 2017.Gal, Yarin and Ghahramani, Zoubin. A theoretically grounded application of dropout in recurrent neural net- works. In NIPS, 2016.Gastaldi, Xavier. Shake-shake regularization of 3-branch residual networks. In ICLR Workshop Track, 2016.
