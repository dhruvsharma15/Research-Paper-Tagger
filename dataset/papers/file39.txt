Building a task-oriented dialogue system such as a hotel booking or a technical support service is difficult because it is application-specific and there is usually limited availability of training data. To mitigate this problem, recent machine learning ap- proaches to task-oriented dialogue system design have cast the problem as a partially observable Markov Decision Process (POMDP) ( Young et al., 2013) with the aim of using reinforcement learn- ing (RL) to train dialogue policies online through interactions with real users (Gaši´cGaši´c et al., 2013). However, the language understanding ( Henderson et al., 2014;Yao et al., 2014) and language gener- ation ( Wen et al., 2016) mod- ules still rely on supervised learning and therefore need corpora to train on. Furthermore, to make RL tractable, the state and action space must be carefully designed ( Young et al., 2013;Young et al., 2010), which may restrict the expressive power and learnability of the model. Also, the reward functions needed to train such models are difficult to design and hard to measure at run-time ( Su et al., 2016).At the other end of the spectrum, sequence to sequence learning ( Sutskever et al., 2014) has in- spired several efforts to build end-to-end trainable, non-task-oriented conversational systems ( Vinyals and Le, 2015;Shang et al., 2015;Serban et al., 2015b). This family of approaches treats dialogue as a source to target sequence transduction problem, applying an encoder network ( Cho et al., 2014) to encode a user query into a distributed vector rep- resenting its semantics, which then conditions a decoder network to generate each system response. These models typically require a large amount of data to train. They allow the creation of effective chatbot type systems but they lack any capability for supporting domain specific tasks, for example, being able to interact with databases ( Sukhbaatar et al., 2015;Yin et al., 2015) and aggregate useful information into their responses.In this work, we propose a neural network-based model for task-oriented dialogue systems by bal- ancing the strengths and the weaknesses of the two research communities: the model is end-to-end trainable 1 but still modularly connected; it does not directly model the user goal, but nevertheless, it still learns to accomplish the required task by pro- viding relevant and appropriate responses at each turn; it has an explicit representation of database (DB) attributes (slot-value pairs) which it uses to achieve a high task success rate, but has a dis- tributed representation of user intent (dialogue act) Figure 1: The proposed end-to-end trainable dialogue system framework to allow ambiguous inputs; and it uses delexicalisa- tion 2 and a weight tying strategy ( Henderson et al., 2014) to reduce the data required to train the model, but still maintains a high degree of freedom should larger amounts of data become available. We show that the proposed model performs a given task very competitively across several metrics when trained on only a few hundred dialogues.In order to train the model for the target appli- cation, we introduce a novel pipe-lined data col- lection mechanism inspired by the Wizard-of-Oz paradigm (Kelley, 1984) to collect human-human dialogue corpora via crowd-sourcing. We found that this process is simple and enables fast data collection online with very low development costs.most probable values in the belief state to form a query to the DB, and the search result, along with the intent representation and belief state are trans- formed and combined by a policy network to form a single vector representing the next system action. This system action vector is then used to condition a response generation network ) which generates the required system output token by token in skeletal form. The final system response is then formed by substitut- ing the actual values of the database entries into the skeletal sentence structure. A more detailed description of each component is given below.We treat dialogue as a sequence to sequence map- ping problem (modelled by a sequence-to-sequence architecture (Sutskever et al., 2014)) augmented with the dialogue history (modelled by a set of belief trackers (Henderson et al., 2014)) and the current database search outcome (modelled by a database operator), as shown in Figure 1. At each turn, the system takes a sequence of tokens 2 from the user as input and converts it into two inter- nal representations: a distributed representation generated by an intent network and a probability distribution over slot-value pairs called the belief state ( Young et al., 2013) generated by a set of be- lief trackers. The database operator then selects the The intent network can be viewed as the en- coder in the sequence-to-sequence learning frame- work ( Sutskever et al., 2014) whose job is to en- code a sequence of input tokens w t 0 , w t 1 , ...w t N into a distributed vector representation z t at every turn t. Typically, a Long Short-term Memory (LSTM) network (Hochreiter and Schmidhuber, 1997) is used and the last time step hidden layer z N t is taken as the representation,Alternatively, a convolutional neural network (CNN) can be used in place of the LSTM as the encoder ( Kalchbrenner et al., 2014;Kim, 2014),2 Delexicalisation: we replaced slots and values by generic tokens (e.g. keywords like Chinese or Indian are replaced by &lt;v.food&gt; in Figure 1) to allow weight sharing. and here we investigate both. Since all the slot- value specific information is delexicalised, the en- coded vector can be viewed as a distributed intent . However, if a value cannot be delexicalised in the input, its ngram-like embeddings will all be padded with zeros. We pad zero vectors (in gray) before each convolution operation to make sure the representation at each layer has the same length. The output of each tracker p t s is a distribution over values of a particular slot s.representation which replaces the hand-coded di- alogue act representation (Traum, 1999) in tradi- tional task-oriented dialogue systems.Belief tracking (also called Dialogue State track- ing) provides the core of a task-oriented spoken dialogue system (SDS) (Henderson, 2015). Cur- rent state-of-the-art belief trackers use discrimi- native models such as recurrent neural networks (RNN) ( Mikolov et al., 2010;Wen et al., 2013) to directly map ASR hypotheses to belief states (Henderson et al., 2014;Mrkši´cMrkši´c et al., 2016). Although in this work we focus on text-based dialogue sys- tems, we retain belief tracking at the core of our system because: (1) it enables a sequence of free- form natural language sentences to be mapped into a fixed set of slot-value pairs, which can then be used to query a DB. This can be viewed as a simple version of a semantic parser (Berant et al., 2013); (2) by keeping track of the dialogue state, it avoids learning unnecessarily complicated long-term de- pendencies from raw inputs; (3) it uses a smart weight tying strategy that can greatly reduce the data required to train the model, and (4) it provides an inherent robustness which simplifies future ex- tension to spoken systems.Using each user input as new evidence, the task of a belief tracker is to maintain a multinomial dis- tribution p over values v ∈ V s for each informable slot s, and a binary distribution for each requestable slot 3 . Each slot in the ontology G 4 has its own specialised tracker, and each tracker is a Jordan- type (recurrence from output to hidden layer) (Jordan, 1989) RNN 5 with a CNN feature extractor, as shown in Figure 2. Like Mrkši´c , we tie the RNN weights together for each value v but vary features f t v when updating each pre-softmax activation g t v . The update equations for a given slot s are,where vector w s , matrix W s , bias terms b s and b s , and scalar g ∅,s are parameters. p t ∅ is the probability that the user has not mentioned that slot up to turn t and can be calculated by substituting g ∅,s for g t v in the numerator of Equation 5. In order to model the discourse context at each turn, the feature vector f t v,cnn is the concatenation of two CNN derived features, one from processing the user input u t at turn t and the other from processing the machine response m t−1 at turn t − 1,where every token in u t and m t−1 is represented by an embedding of size N derived from a 1-hot input vector. In order to make the tracker aware when delexicalisation is applied to a slot or value, the slot-value specialised CNN operator CNN (·) s,v (·) ex- tracts not only the top level sentence representation but also intermediate n-gram-like embeddings de- termined by the position of the delexicalised token in each utterance. If multiple matches are observed, the corresponding embeddings are summed. On the other hand, if there is no match for a particular slot or value, the empty n-gram embeddings are padded with zeros. In order to keep track of the position of delexicalised tokens, both sides of the sentence are padded with zeros before each convolution opera- tion. The number of vectors is determined by the filter size at each layer. The overall process of ex- tracting several layers of position-specific features is visualised in Figure 2.The belief tracker described above is based on Henderson et al. (2014) with some modifica- tions: (1) only probabilities over informable and requestable slots and values are output, (2) the re- current memory block is removed, since it appears to offer no benefit in this task, and (3) the n-gram feature extractor is replaced by the CNN extrac- tor described above. By introducing slot-based belief trackers, we essentially add a set of interme- diate labels into the system as compared to train- ing a pure end-to-end system. Later in the paper we will show that these tracker components are critical for achieving task success. We will also show that the additional annotation requirement that they introduce can be successfully mitigated using a novel pipe-lined Wizard-of-Oz data collec- tion framework.value vector x t over DB entities where a 1 indi- cates that the corresponding entity is consistent with the query (and hence it is consistent with the most likely belief state). In addition, if x is not entirely null, an associated entity pointer is main- tained which identifies one of the matching entities selected at random. The entity pointer is updated if the current entity no longer matches the search criteria; otherwise it stays the same. The entity referenced by the entity pointer is used to form the final system response as described in Section 2.4.Policy network The policy network can be viewed as the glue which binds the system modules together. Its output is a single vector o t represent- ing the system action, and its inputs are comprised of z t from the intent network, the belief state p t s , and the DB truth value vector x t . Since the genera- tion network only generates appropriate sentence forms, the individual probabilities of the categor- ical values in the informable belief state are im- material and are summed together to form a sum- mary belief vector for each slotˆpslotˆ slotˆp t s represented by three components: the summed value probabilities, the probability that the user said they "don't care" about this slot and the probability that the slot has not been mentioned. Similarly for the truth value vector x t , the number of matching entities mat- ters but not their identity. This vector is therefore compressed to a 6-bin 1-hot encodingˆxencodingˆ encodingˆx t , which represents different degrees of matching in the DB (no match, 1 match, ... or more than 5 matches). Finally, the policy network output is generated by a three-way matrix transformation,where matrices W zo , W po , and W xo are param- eters andˆpandˆ andˆp t = s∈Gˆps∈Gˆ s∈Gˆp t s is a concatenation of all summary belief vectors.Database Operator Based on the output p t s of the belief trackers, the DB query q t is formed by,The generation network uses the action vector o t to condition a language generator ( ). This generates template-like sentences token by token based on the language model prob- abilities, j+1 |wwhere S I is the set of informable slots. This query is then applied to the DB to create a binary truthwhere LSTM j (·) is a conditional LSTM operator for one output step j, w t j is the last output token (i.e. a word, a delexicalised slot name or a delexicalised slot value), and h t j−1 is the hidden layer. Once the output token sequence has been generated, the generic tokens are replaced by their actual values: (1) replacing delexicalised slots by random sam- pling from a list of surface forms, e.g. &lt;s.food&gt; to food or type of food, and (2) replacing delexicalised values by the actual attribute values of the entity currently selected by the DB pointer. This is simi- lar in spirit to the Latent Predictor Network ( Ling et al., 2016) where the token generation process is augmented by a set of pointer networks (Vinyals et al., 2015) to transfer entity specific information into the response.Attentive Generation Network Instead of de- coding responses directly from a static action vec- tor o t , an attention-based mechanism ( Bahdanau et al., 2014;Hermann et al., 2015) can be used to dynamically aggregate source embeddings at each output step j. In this work we explore the use of an attention mechanism to combine the tracker belief states, i.e. o t is computed at each output step j by,where for a given ontology G,s∈G and where the attention weights α whereArguably the greatest bottleneck for statistical ap- proaches to dialogue system development is the collection of appropriate training data, and this is especially true for task-oriented dialogue sys- tems. Serban et al (Serban et al., 2015a) have catalogued existing corpora for developing con- versational agents. Such corpora may be useful for bootstrapping, but, for task-oriented dialogue sys- tems, in-domain data is essential 6 . To mitigate this problem, we propose a novel crowdsourcing ver- sion of the Wizard-of-Oz (WOZ) paradigm (Kelley, 1984) for collecting domain-specific corpora.Based on the given ontology, we designed two webpages on Amazon Mechanical Turk, one for wizards and the other for users (see Figure 4 and 5 for the designs). The users are given a task specify- ing the characteristics of a particular entity that they must find (e.g. a Chinese restaurant in the north) and asked to type in natural language sentences to fulfil the task. The wizards are given a form to record the information conveyed in the last user turn (e.g. pricerange=Chinese, area=north) and a search table showing all the available matching entities in the database. Note these forms contain all the labels needed to train the slot-based belief trackers. The table is automatically updated every time the wizard submits new information. Based on the updated table, the wizard types an appropriate system response and the dialogue continues.In order to enable large-scale parallel data collec- tion and avoid the distracting latencies inherent in conventional WOZ scenarios (Bohus and Rudnicky, 2008), users and wizards are asked to contribute just a single turn to each dialogue. To ensure coher- ence and consistency, users and wizards must re- view all previous turns in that dialogue before they contribute their turns. Thus dialogues progress in a pipe-line. Many dialogues can be active in parallel and no worker ever has to wait for a response from the other party in the dialogue. Despite the fact that multiple workers contribute to each dialogue, we observe that dialogues are generally coherent yet diverse. Furthermore, this turn-level data collection strategy seems to encourage workers to learn and correct each other based on previous turns.In this paper, the system was designed to assist users to find a restaurant in the Cambridge, UK area. There are three informable slots (food, pricerange, area) that users can use to constrain the search and six requestable slots (address, phone, postcode plus the three informable slots) that the user can ask a value for once a restaurant has been offered. There are 99 restaurants in the DB. Based on this domain, we ran 3000 HITs (Human Intelligence Tasks) in total for roughly 3 days and collected 1500 dialogue turns. After cleaning the data, we have approximately 680 dialogues in total (some of them are unfinished). The total cost for collecting the dataset was ∼ 400 USD.6 E.g. technical support for Apple computers may differ completely from that for Windows, due to the many differ- ences in software and hardware.Training Training is divided into two phases. Firstly the belief tracker parameters θ b are trained using the cross entropy errors between tracker labels y t s and predictions p t s , L 1 (θ b ) = − t s (y t s ) log p t s . For the full model, we have three informable trackers (food, pricerange, area) and seven requestable trackers (address, phone, postcode, name, plus the three informable slots).Having fixed the tracker parameters, the re- maining parts of the model θ \b are trained using the cross entropy errors from the gen- eration network language model, L 2 (θ \b ) = − t j (y t j ) log p t j , where y t j and p t j are out- put token targets and predictions respectively, at turn t of output step j. We treated each dialogue as a batch and used stochastic gradient decent with a small l2 regularisation term to train the model. The collected corpus was partitioned into a train- ing, validation, and testing sets in the ratio 3:1:1. Early stopping was implemented based on the vali- dation set for regularisation and gradient clipping was set to 1. All the hidden layer sizes were set to 50, and all the weights were randomly initialised between -0.3 and 0.3 including word embeddings. The vocabulary size is around 500 for both input and output, in which rare words and words that can be delexicalised are removed. We used three con- volutional layers for all the CNNs in the work and all the filter sizes were set to 3. Pooling operations were only applied after the final convolution layer.Decoding In order to decode without length bias, we decoded each system response m t based on the average log probability of tokens,mt where θ are the model parameters, u t is the user input, and J t is the length of the machine response. As a contrast, we also investigated the MMI cri- terion ( Li et al., 2016) to increase diversity and put additional scores on delexicalised tokens to en- courage task completion. This weighted decoding strategy has the following objective function, where λ and γ are weights selected on validation set and log p(m t ) can be modelled by a standalone LSTM language model. We used a simple heuris- tic for the scoring function R t designed to reward giving appropriate information and penalise spu- riously providing unsolicited information 7 . We applied beam search with a beamwidth equal to 10, the search stops when an end of sentence token is generated. In order to obtain language variability from the deployed model we ran decoding until we obtained 5 candidates and randomly sampled one as the system response.Tracker performance Table 1 shows the eval- uation of the trackers' performance. Due to delex- icalisation, both CNN type trackers and N-gram type trackers ( Henderson et al., 2014) achieve high precision, but the N-gram tracker has worse recall. This result suggests that compared to simple N- grams, CNN type trackers can better generalise to sentences with long distance dependencies and more complex syntactic structures.Corpus-based evaluation We evaluated the end-to-end system by first performing a corpus- based evaluation in which the model is used to pre- dict each system response in the held-out test set. Three evaluation metrics were used: BLEU score (on top-1 and top-5 candidates) ( Papineni et al., 2002), entity matching rate and objective task suc- cess rate ( . We calculated the entity matching rate by determining whether the actual selected entity at the end of each dialogue matches the task that was specified to the user. The dialogue is then marked as successful if both (1) the offered entity matches, and (2) the system answered all the associated information requests (e.g. what is the address?) from the user. We computed the BLEU scores on the template-like output sentences before lexicalising with the entity value substitution.mt λ log p(m t )/J t + γR t }  Table 2 shows the result of the corpus-based evaluation averaging over 5 randomly initialised networks. The Baseline block shows two baseline models: the first is a simple turn-level sequence to sequence model ( Sutskever et al., 2014) while the second one introduces an additional recurrence to model the dependency on the dialogue history fol- lowing Serban et al ( Serban et al., 2015b). As can be seen, incorporation of the recurrence improves the BLEU score. However, baseline task success and matching rates cannot be computed since the models do not make any provision for a database.The Variant block of Table 2 shows two variants of the proposed end-to-end model. For the first one, no requestable trackers were used, only informable trackers. Hence, the burden of modelling user re- quests falls on the intent network alone. We found that without explicitly modelling user requests, the model performs very poorly on task completion (∼ 30%), even though it can offer the correct entity most of the time(∼ 90%). More data may help here; however, we found that the incorporation of an explicit internal semantic representation in the full model (shown below) is more efficient and extremely effective. For the second variant, the LSTM intent network is replaced by a CNN. This achieves a very competitive BLEU score but task success is still quite poor (∼ 58% success). We think this is because the CNN encodes the intent by capturing several local features but lacks the global view of the sentence, which may easily result in an unexpected overfit.The Full model block shows the performance of the proposed model with different decoding strate- gies. The first row shows the result of decoding us- ing the average likelihood term (Equation 13) while the second row uses the weighted decoding strat- egy (Equation 14). As can be seen, the weighted decoding strategy does not provide a significant improvement in BLEU score but it does greatly improve task success rate (∼ 3%). The R t term contributes the most to this improvement because it injects additional task-specific information during decoding. Despite this, the most effective and ele- gant way to improve the performance is to use the attention-based mechanism (+att.) to dynamically aggregate the tracker beliefs (Section 2.4). It gives a slight improvement in BLEU score (∼ 0.01) and a big gain on task success (∼ 5%). Finally, we can improve further by incorporating weighted decod- ing with the attention models (+ att. + weighted).As an aside, we used t-SNE (der Maaten and Hinton, 2008) to produce a reduced dimension view of the action embeddings o t , plotted and labelled by the first three generated output words (full model w/o attention). The figure is shown as Figure 3. We can see clear clusters based on the system in- tent types, even though we did not explicitly model them using dialogue acts.Human evaluation In order to assess opera- tional performance, we tested our model using paid subjects recruited via Amazon Mechanical Turk. Each judge was asked to follow a given task and to rate the model's performance. We assessed the subjective success rate, and the perceived compre- hension ability and naturalness of response on a scale of 1 to 5. The full model with attention and weighted decoding was used and the system was tested on a total of 245 dialogues. As can be seen in Table 3, the average subjective success rate was 98%, which means the system was able to complete the majority of tasks. Moreover, the comprehen- sion ability and naturalness scores both averaged more than 4 out of 5. (See Appendix for some sample dialogues in this trial.)We also ran comparisons between the NN model   and a handcrafted, modular baseline system (HDC) consisting of a handcrafted semantic parser, rule- based policy and belief tracker, and a template- based generator. The result can be seen in Table 4. The HDC system achieved ∼ 95% task success rate, which suggests that it is a strong baseline even though most of the components were hand- engineered. Over the 164 dialogues tested, the NN system (NN) was considered better than the handcrafted system (HDC) on all the metrics com- pared. Although both systems achieved similar suc- cess rates, the NN system (NN) was more efficient and provided a more engaging conversation (lower turn number and higher preference). Moreover, the comprehension ability and naturalness of the NN system were also rated higher, which suggests that the learned system was perceived as being more natural than the hand-designed system.This paper has presented a novel neural network- based framework for task-oriented dialogue sys- tems. The model is end-to-end trainable using two supervision signals and a modest corpus of training data. The paper has also presented a novel crowd- sourced data collection framework inspired by the Wizard-of-Oz paradigm. We demonstrated that the pipe-lined parallel organisation of this collection framework enables good quality task-oriented dia- logue data to be collected quickly at modest cost.The experimental assessment of the NN dialogue system showed that the learned model can interact efficiently and naturally with human subjects to complete an application-specific task. To the best of our knowledge, this is the first end-to-end NN- based model that can conduct meaningful dialogues in a task-oriented application.However, there is still much work left to do. Our current model is a text-based dialogue sys- tem, which can not directly handle noisy speech recognition inputs nor can it ask the user for con- firmation when it is uncertain. Indeed, the extent to which this type of model can be scaled to much larger and wider domains remains an open question which we hope to pursue in our further work.Wizard-of-Oz data collection websites Figure 4: The user webpage. The worker who plays a user is given a task to follow. For each mturk HIT, he/she needs to type in an appropriate sentence to carry on the dialogue by looking at both the task description and the dialogue history. Figure 5: The wizard page. The wizard's job is slightly more complex: the worker needs to go through the dialogue history, fill in the form (top green) by interpreting the user input at this turn, and type in an appropriate response based on the history and the DB result (bottom green). The DB search result is updated when the form is submitted. The form can be divided into informable slots (top) and requestable slots (bottom), which contains all the labels we need to train the trackers. Table   Table 5: Additional R t term for delexicalised tokens when using weighted decoding (Equation 14). Not observed means the corresponding tracker has a highest probability on either not mentioned or dontcare value, while observed mean the highest probability is on one of the categorical values. A positive score encourages the generation of that token while a negative score discourages it. 
