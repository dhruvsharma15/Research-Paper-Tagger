D EEP learning has achieved significant success in many perception tasks including seeing (visual object recognition), reading (text understanding), and hearing (speech recognition). These are undoubtedly fundamental tasks for a functioning comprehensive artificial intelligence (AI) system. However, in order to build a real AI system, simply being able to see, read, and hear is far from enough. It should, above all, possess the ability of thinking.Take medical diagnosis as an example. Besides seeing visible symptoms (or medical images from CT) and hearing descriptions from patients, a doctor has to look for relations among all the symptoms and preferably infer the etiology of them. Only after that can the doctor provide medical advice for the patients. In this example, although the abilities of seeing and hearing allow the doctor to acquire information from the patients, it is the thinking part that defines a doctor. Specifically, the ability of thinking here could involve causal inference, logic deduction, and dealing with uncertainty, which is apparently beyond the capability of conventional deep learning methods. Fortunately, another type of models, probabilistic graphical models (PGM), excels at causal inference and dealing with uncertainty. The problem is that PGM is not as good as deep learning models at perception tasks. To address the problem, it is, therefore, a natural choice to tightly integrate deep learning and PGM within a principled probabilistic framework, which we call Bayesian deep learning (BDL) in this paper.With the tight and principled integration in Bayesian deep learning, the perception task and inference task are regarded as a whole and can benefit from each other. In the example above, being able to see the medical image could help with the doctor's diagnosis and inference. On the other hand, diagnosis and inference can in return help with understanding the medical image. Suppose the doctor may not be sure about what a dark spot in a medical image is, but if she is able to infer the etiology of the symptoms and disease, it can help him better decide whether the dark spot is a tumor or not.As another example, to achieve high accuracy in recommender systems [45], [60], we need to fully understand the content of items (e.g., documents and movies), analyze the profile and preference of users, and evaluate the similarity among users. Deep learning is good at the first subtask while PGM excels at the other two. Besides the fact that better understanding of item content would help with the analysis of user profiles, the estimated similarity among users could provide valuable information for understanding item content in return. In order to fully utilize this bidirectional effect to boost recommendation accuracy, we might wish to unify deep learning and PGM in one single principled probabilistic framework, as done in [60].Besides recommender systems, the need for Bayesian deep learning may also arise when we are dealing with control of non-linear dynamical systems with raw images as input. Consider controlling a complex dynamical system according to the live video stream received from a camera. This problem can be transformed into iteratively performing two tasks, perception from raw images and control based on dynamic models. The perception task can be taken care of using multiple layers of simple nonlinear transformation (deep learning) while the control task usually needs more sophisticated models like hidden Markov models and Kalman filters [21], [38]. The feedback loop is then completed by the fact that actions chosen by the control model can affect the received video stream in return. To enable an effective iterative process between the perception task and the control task, we need two-way information exchange between them. The perception component would be the basis on which the control component estimates its states and the control component with a dynamic model built in would be able to predict the future trajectory (images). In such cases, Bayesian deep learning is a suitable choice [62].Apart from the major advantage that BDL provides a principled way of unifying deep learning and PGM, another benefit comes from the implicit regularization built in BDL. By imposing a prior on hidden units, parameters defining a neural network, or the model parameters specifying the causal inference, BDL can to some degree avoid overfitting, especially when we do not have sufficient data. Usually, a BDL model consists of two components, a perception component that is a Bayesian formulation of a certain type of neural networks and a task-specific component that describes the relationship among different hidden or observed variables using PGM. Regularization is crucial for them both. Neural networks usually have large numbers of free parameters that need to be regularized properly. Regularization techniques like weight decay and dropout [51] are shown to be effective in improving performance of neural networks and they both have Bayesian interpretations [13]. In terms of the task-specific component, expert knowledge or prior information, as a kind of regularization, can be incorporated into the model through the prior we imposed to guide the model when data are scarce.Yet another advantage of using BDL for complex tasks (tasks that need both perception and inference) is that it provides a principled Bayesian approach of handling parameter uncertainty. When BDL is applied to complex tasks, there are three kinds of parameter uncertainty that need to be taken into account: 1) Uncertainty on the neural network parameters.2) Uncertainty on the task-specific parameters.3) Uncertainty of exchanging information between the perception component and the task-specific component. By representing the unknown parameters using distributions instead of point estimates, BDL offers a promising framework to handle these three kinds of uncertainty in a unified way. It is worth noting that the third uncertainty could only be handled under a unified framework like BDL. If we train the perception component and the task-specific component separately, it is equivalent to assuming no uncertainty when exchanging information between the two components.Of course, there are challenges when applying BDL to real-world tasks. (1) First, it is nontrivial to design an efficient Bayesian formulation of neural networks with reasonable time complexity. This line of work is pioneered by [24], [37], [40], but it has not been widely adopted due to its lack of scalability. Fortunately, some recent advances in this direction [1], [7], [19], [22], [32] seem to shed light on the practical adoption of Bayesian neural network 1 . (2) The second challenge is to ensure efficient and effective information exchange between the perception component and the task-specific component. Ideally both the first-order and second-order information (e.g., the mean and the variance) should be able to flow back and forth between the two components. A natural way is to represent the perception component as a PGM and seamlessly connect it to the task-specific PGM, as done in [15], [59], [60].In this survey, we aim to give a comprehensive overview of BDL models for recommender systems, topic models (and representation learning), and control. The rest of the survey is organized as follows: In Section 2, we provide a review of some basic deep learning models. Section 3 covers the main concepts and techniques for PGM. These two sections serve as the background for BDL, and the next section, Section 4, would survey the BDL models applied to areas like recommender systems and control. Section 5 discusses some future research issues and concludes the paper.Deep learning normally refers to neural networks with more than two layers. To better understand deep learning, here we start with the simplest type of neural networks, multilayer perceptrons (MLP), as an example to show how conventional deep learning works. After that, we will review several other types of deep learning models based on MLP.Essentially a multilayer perceptron is a sequence of parametric nonlinear transformations. Suppose we want to train a multilayer perceptron to perform a regression task which maps a vector of M dimensions to a vector of D dimensions. We denote the input as a matrix X 0 (0 means it is the 0-th layer of the perceptron). The j-th row of X 0 , denoted as X 0,j * , is an M -dimensional vector representing one data point. The target (the output we want to fit) is denoted as Y. Similarly Y j * denotes a D-dimensional row vector. The problem of learning an L-layer multilayer perceptron can be formulated as the following optimization problem:where σ(·) is an element-wise sigmoid function for a matrix and σ(x) = 11. Here we refer to Bayesian treatment of neural networks as Bayesian neural network. The other term, Bayesian deep learning, is retained to refer to complex Bayesian models with both a perception component and a task-specific component.1+exp (−x) . The purpose of imposing σ(·) is to allow nonlinear transformation. Normally other transformations like tanh(x) and max(0, x) can be used as alternatives of the sigmoid function.Here X l (l = 1, 2, . . . , L − 1) is the hidden units. As we can see, X L can be easily computed once X 0 , W l , and b l are given. Since X 0 is given by the data, we only need to learn W l and b l here. Usually this is done using backpropagation and stochastic gradient descent (SGD). The key is to compute the gradients of the objective function with respect to W l and b l . If we denote the value of the  objective function as E, we can compute the gradients using the chain rule as:the following optimization problem:where l = 1, . . . , L and the regularization terms are omitted.• denotes the element-wise product and mean(·, 1) is the matlab operation on matrices. In practice, we only use a small part of the data (e.g., 128 data points) to compute the gradients for each update. This is called stochastic gradient descent.As we can see, in conventional deep learning models, only W l and b l are free parameters, which we will update in each iteration of the optimization. X l is not a free parameter since it can be computed exactly if W l and b l are given.where λ is a regularization parameter and · F denotes the Frobenius norm. Here SDAE can be regarded as a multilayer perceptron for regression tasks described in the previous section. The input X 0 of the MLP is the corrupted version of the data and the target Y is the clean version of the data X c . For example, X c can be the raw data matrix, and we can randomly set 30% of the entries in X c to 0 and get X 0 . In a nutshell, SDAE learns a neural network that takes the noisy data as input and recovers the clean data in the last layer. This is what 'denoising' in the name means. Normally, the output of the middle layer, i.e., X 2 in Figure 1, would be used to compactly represent the data.An autoencoder (AE) is a feedforward neural network to encode the input into a more compact representation and reconstruct the input with the learned representation. In its simplest form, an autoencoder is no more than a multilayer perceptron with a bottleneck layer (a layer with a small number of hidden units) in the middle. The idea of autoencoders has been around for decades [8], [18], [25], [33] and abundant variants of autoencoders have been proposed to enhance representation learning including sparse AE [43], contrastive AE [46], and denoising AE [54]. For more details, please refer to a nice recent book on deep learning [18]. Here we introduce a kind of multilayer denoising AE, known as stacked denoising autoencoders (SDAE), both as an example of AE variants and as background for its applications on BDL-based recommender systems in Section 4.SDAE [54] is a feedforward neural network for learning representations (encoding) of the input data by learning to predict the clean input itself in the output, as shown in Figure 1. The hidden layer in the middle, i.e., X 2 in the figure, can be constrained to be a bottleneck to learn compact representations. The difference between traditional AE and SDAE is that the input layer X 0 is a corrupted version of the clean input data. Essentially an SDAE solves Convolutional neural networks (CNN) can be viewed as another variant of MLP. Different from AE, which is initially designed to perform dimensionality reduction, CNN is biologically inspired. According to [29], two types of cells have been identified in the cat's visual cortex. One is simple cells that respond maximally to specific patterns within their receptive field, and the other is complex cells with larger receptive field that are considered locally invariant to positions of patterns. Inspired by these findings, the two key concepts in CNN are then developed: convolution and max-pooling.Convolution: In CNN, a feature map is the result of the convolution of the input and a linear filter, followed by some element-wise nonlinear transformation. The input here can be the raw image or the feature map from the previous layer. Specifically, with input X, weights W k , bias b k , the k-th feature map H k can be obtained as follows:Note that in the equation above we assume one single input feature map and multiple output feature maps. In practice, CNN often has multiple input feature maps as well due to its deep structure. A convolutional layer with 4 input feature maps and 2 output feature maps is shown in Figure 2. Max-Pooling: Usually, a convolutional layer in CNN is followed by a max-pooling layer, which can be seen as a type of nonlinear downsampling. The operation of max-pooling is simple. For example, if we have a feature map of size 6 × 9, the result of max-pooling with a 3 × 3 region would be a downsampled feature map of size Figure 4. If we use hyperbolic tangent nonlinearity (tanh), the computation of output o t will be as follows: Fig. 3. On the left is a conventional feedforward neural network with one hidden layer, where x is the input, z is the hidden layer, and o is the output, W and V are the corresponding weights (biases are omitted here). On the right is a recurrent neural network with input {xt} T t=1 , hidden states {ht} T t=1 , and output {ot} T t=1 .where Y, W, and V denote the weight matrices for input-to-hidden, hidden-to-hidden, and hidden-to-output connections, respectively, and b and c are the corresponding biases. If the task is to classify the input data at each time step, we can compute the classification probability as p t = softmax(o t ) where Fig. 4. An unrolled RNN which is equivalent to the one in Figure 3(right).Here each node (e.g., x 1 , h 1 , or o 1 ) is associated with one particular time instance.2 × 3. Each entry of the downsampled feature map is the maximum value of the corresponding 3 × 3 region in the 6 × 9 feature map. Max-pooling layers can not only reduce computational cost by ignoring the non-maximal entries but also provide local translation invariance. Putting it all together: Usually to form a complete and working CNN, the input would alternate between L convolutional layers and L max-pooling layers before going into an MLP for tasks like classification or regression. One famous example is the LeNet-5 [34], which alternates between 2 convolutional layers and 2 max-pooling layers before going into a fully connected MLP for target tasks.Similar to feedforward networks, to train an RNN, a generalized back-propagation algorithm called back-propagation through time (BPTT) [18] can be used. Essentially the gradients are computed through the unrolled network as shown in Figure 4 with shared weights and biases for all time steps.When we read an article, we would normally take in one word at a time and try to understand the current word based on previous words. This is a recurrent process that needs short-term memory. Unfortunately conventional feedforward neural networks like the one shown in Figure  3(left) fail to do so. For example, imagine we want to constantly predict the next word as we read an article. Since the feedforward network only computes the output o as Vq (Wx), where the function q(·) denotes element-wise nonlinear transformation, it is unclear how the network could naturally model the sequence of words to predict the next word.The problem with the vanilla RNN introduced above is that the gradients propagated over many time steps are prone to vanish or explode, which makes the optimization notoriously difficult. In addition, the signal passing through the RNN decays exponentially, making it impossible to model long-term dependencies in long sequences. Imagine we want to predict the last word in the paragraph 'I have many books ... I like reading'. In order to get the answer, we need 'long-term memory' to retrieve information (the word 'books') at the start of the text. To address this problem, the long short-term memory model (LSTM) is designed as a type of gated RNN to model and accumulate information over a relatively long duration. The intuition behind LSTM is that when processing a sequence consisting of several subsequences, it is sometimes useful for the neural network to summarize or forget the old states before moving on to process the next subsequence [18]. Using t = 1 . . . T j to index the words in the sequence, the formulation of LSTM is as follows (we drop the item index j for notational simplicity):To solve the problem, we need a recurrent neural network [18] instead of a feedforward one. As shown in Figure 3(right), the computation of the current hidden states h t depends on the current input x t (e.g., the t-th word) and the previous hidden states h t−1 . This is why there is a loop in the RNN. It is this loop that enables short-term memory in RNNs. The h t in the RNN represents what the network knows so far at the t-th time step. To see the computation more clearly, we can unroll the loop and represent the RNNwhere x t is the word embedding of the t-th word, W w is a K W -by-S word embedding matrix, and e t is the 1-of-S representation, stands for the element-wise product operation between two vectors, σ(·) denotes the sigmoid function, s t is the cell state of the t-th word, and b, Y, and W denote the biases, input weights, and recurrent weights respectively. The forget gate units h f t and the input gate units h i t in Equation (5) can be computed using their corresponding weights and biases Note that in the LSTM, information of the processed sequence is contained in the cell states s t and the output states h t , both of which are column vectors of length K W . Similar to [12], [53], we can use the output state and cell state at the last time step (h Tj and s Tj ) of the first LSTM as the initial output state and cell state of the second LSTM. This way the two LSTMs can be concatenated to form an encoder-decoder architecture, as shown in Figure 5.Note that there is a vast literature on deep learning and neural networks. The introduction in this section intends to serve only as the background of Bayesian deep learning. Readers are referred to [18] for a comprehensive survey and more details.The generative process above gives the story of how the random variables are generated. In the graphical model in Figure 6, the shaded node denotes observed variables while the others are latent variables (θ and z) or parameters (α and β). As we can see, once the model is defined, learning algorithms can be applied to automatically learn the latent variables and parameters.Due to its Bayesian nature, PGM like LDA is easy to extend to incorporate other information or to perform other tasks. For example, after LDA, different variants of topic models based on it have been proposed. [5], [56] are proposed to incorporate temporal information and [4] extends LDA by assuming correlations among topics. [26] extends LDA from the batch mode to the online setting, making it possible to process large datasets. On recommender systems, [55] extends LDA to incorporate rating information and make recommendations. This model is then further extended to incorporate social information [44], [57], [58].Probabilistic Graphical Models (PGM) use diagrammatic representations to describe random variables and relationships among them. Similar to a graph that contains nodes (vertices) and links (edges), PGM has nodes to represent random variables and links to express probabilistic relationships among them.There are essentially two types of PGM, directed PGM (also known as Bayesian networks) and undirected PGM (also known as Markov random fields). In this survey we mainly focus on directed PGM 2 . For details on undirected PGM, readers are referred to [3].A classic example of PGM would be latent Dirichlet allocation (LDA), which is used as a topic model to analyze the generation of words and topics in documents. Usually PGM comes with a graphical representation of the model and a generative process to depict the story of how the random variables are generated step by step. Figure 6 shows the graphical model for LDA and the corresponding generative process is as follows:Strictly speaking, the process of finding the parameters (e.g., α and β in Figure 6) is called learning and the process of finding the latent variables (e.g., θ and z in Figure 6) given the parameters is called inference. However, given only the observed variables (e.g. w in Figure 6), learning and inference are often intertwined. Usually the learning and inference of LDA would alternate between the updates of latent variables (which correspond to inference) and the updates of the parameters (which correspond to learning). Once the learning and inference of LDA is completed, we would have the parameters α and β. If a new document comes, we can now fix the learned α and β and then perform inference alone to find the topic proportions θ j of the new document. Learnable Variance of the graphical model in PMF is equivalent to factorization of a large matrix into two low-rank matrices with L2 regularization. MAP, as efficient as it is, gives us only point estimates of latent variables (and parameters). In order to take the uncertainty into account and harness the full power of Bayesian models, one would have to resort to Bayesian treatments like variational inference and Markov chain Monte Carlo (MCMC). For example, the original LDA uses variational inference to approximate the true posterior with factorized variational distributions [6]. Learning of the latent variables and parameters then boils down to minimizing the KL-divergence between the variational distributions and the true posterior distributions. Besides variational inference, another choice for a Bayesian treatment is to use MCMC. For example, MCMC algorithms like [42] have been proposed to learn the posterior distributions of LDA. With the background on deep learning and PGM, we are now ready to introduce the general framework and some concrete examples of BDL. Specifically, in this section we will list some recent BDL models with applications on recommender systems, topic models, and control. A summary of these models is shown in Table 1.formulation of a deep learning model. Ω h is used to denote the set of hinge variables (e.g. J in Figure 7). These variables directly interact with the perception component from the task-specific component. Table 1 shows the set of hinge variables Ω h for each listed BDL models. The set of task variables (e.g. G, I, and H in Figure 7), i.e., variables in the task-specific component without direct relation to the perception component, is denoted as Ω t . The I.I.D. Requirement: Note that hinge variables are always in the task-specific component. Normally, the connections between hinge variables Ω h and the perception component (e.g., C → J and F → J in Figure 7) should be i.i.d. for convenience of parallel computation in the perception component. For example, each row in J is related to only one corresponding row in C and one in F. Although it is not mandatory in BDL models, meeting this requirement would significantly increase the efficiency of parallel computation in model training.Joint Distribution Decomposition: If the edges between the two components point towards Ω h , the joint distribution of all variables can be written as:As mentioned in Section 1, BDL is a principled probabilistic framework with two seamlessly integrated components: a perception component and a task-specific component.PGM for BDL: Figure 7 shows the PGM of a simple BDL model as an example. The part inside the red rectangle on the left represents the perception component and the part inside the blue rectangle on the right is the task-specific component. Typically, the perception component would be a probabilistic formulation of a deep learning model with multiple nonlinear processing layers represented as a chain structure in the PGM. While the nodes and edges in the perception component are relatively simple, those in the task-specific component often describe more complex distributions and relationships among variables (like in LDA).Three Sets of Variables: There are three sets of variables in a BDL model: perception variables, hinge variables, and task variables. In this paper, we use Ω p to denote the set of perception variables (e.g., A, B, and C in Figure 7), which are the variables in the perception component. Usually Ω p would include the weights and neurons in the probabilisticIf the edges between the two components originate from Ω h , the joint distribution of all variables can be written as:Apparently, it is possible for BDL to have some edges between the two components pointing towards Ω h and some originating from Ω h , in which case the decomposition of the joint distribution would be more complex.Variance Related to Ω h : As mentioned in Section 1, one of the motivations for BDL is to model the uncertainty of exchanging information between the perception component and the task-specific component, which boils down to modeling the uncertainty related to Ω h . For example, this kind of uncertainty is reflected in the variance of the conditional density p(Ω h |Ω p ) in Equation (6) 4 . According to the degree of flexibility, there are three types of variance 4. For models with the joint likelihood decomposed as in Equation (7), the uncertainty is reflected in the variance of p(Ωp|Ω h ).for Ω h (for simplicity we assume the joint likelihood of BDL is Equation (6), Ω p = {p}, Ω h = {h}, and p(Ω h |Ω p ) = N (h|p, s) in our example):• Zero-Variance: Zero-Variance (ZV) assumes no uncertainty during the information exchange between the two components. In the example, zero-variance means directly setting s to 0.• Hyper-Variance: Hyper-Variance (HV) assumes that uncertainty during the information exchange is defined through hyperparameters. In the example, HV means that s is a hyperparameter that is manually tuned.• Learnable Variance: Learnable Variance (LV) uses learnable parameters to represent uncertainty during the information exchange. In the example, s is the learnable parameter. As shown above, we can see that in terms of model flexibility, LV &gt; HV &gt; ZV. Normally, if the models are properly regularized, an LV model would outperform an HV model, which is superior to a ZV model. In Table 1, we show the types of variance for Ω h in different BDL models. Note that although each model in the table has a specific type, one can always adjust the models to devise their counterparts of other types. For example, while CDL in the table is an HV model, we can easily adjust p(Ω h |Ω p ) in CDL to devise its ZV and LV counterparts. In [60], they compare the performance of an HV CDL and a ZV CDL and finds that the former performs significantly better, meaning that sophisticatedly modeling uncertainty between two components is essential for performance.Learning Algorithms: Due to the nature of BDL, practical learning algorithms need to meet these criteria: 1) They should be online algorithms in order to scale well for large datasets. 2) They should be efficient enough to scale linearly with the number of free parameters in the perception component. Criterion (1) implies that conventional variational inference or MCMC methods are not applicable. Usually an online version of them is needed [27]. Most SGD-based methods do not work either unless only MAP inference (as opposed to Bayesian treatments) is performed. Criterion (2) is needed because there are typically a large number of free parameters in the perception component. This means methods based on Laplace approximation [37] are not realistic since they involve the computation of a Hessian matrix that scales quadratically with the number of free parameters.[55], which is crucial for accurate recommendation. [47] uses low-rank matrix factorization in the last weight layer of a deep network to significantly reduce the number of model parameters and speed up training, but it is for classification instead of recommendation tasks. On music recommendation, [41], [61] directly use conventional CNN or deep belief networks (DBN) to assist representation learning for content information, but the deep learning components of their models are deterministic without modeling the noise and hence they are less robust. The models achieve performance boost mainly by loosely coupled methods without exploiting the interaction between content information and ratings. Besides, the CNN is linked directly to the rating matrix, which means the models will perform poorly due to serious overfitting when the ratings are sparse.Despite the successful applications of deep learning on natural language processing and computer vision, very few attempts have been made to develop deep learning models for CF. [49] uses restricted Boltzmann machines instead of the conventional matrix factorization formulation to perform CF and [17] extends this work by incorporating user-user and item-item correlations. Although these methods involve both deep learning and CF, they actually belong to CF-based methods because they do not incorporate content information like CTRTo address the challenges above, a hierarchical Bayesian model called collaborative deep learning (CDL) as a novel tightly coupled method for RS is introduced in [60]. Based on a Bayesian formulation of SDAE, CDL tightly couples deep representation learning for the content information and collaborative filtering for the rating (feedback) matrix, allowing two-way interaction between the two. Experiments show that CDL significantly outperforms the state of the art.In the following text, we will start with the introduction of the notation used during our presentation of CDL. After that we will review the design and learning of CDL.Notation and Problem Formulation: Similar to the work in [55], the recommendation task considered in CDL takes implicit feedback [28] as the training and test data. The entire collection of J items (articles or movies) is represented by a J-by-B matrix X c , where row j is the bag-of-words vector X c,j * for item j based on a vocabulary of size B. With I users, we define an I-by-J binary rating matrix R = [R ij ] I×J . For example, in the dataset citeulike-a [55], [57], [60] R ij = 1 if user i has article j in his or her personal library and R ij = 0 otherwise. Given part of the ratings in R and the content information X c , the problem is to predict the other ratings in R. Note that although CDL in its current from focuses on movie recommendation (where plots of movies are considered as content information) and article recommendation like [55] in this section, it is general enough to handle other recommendation tasks (e.g., tag recommendation).The matrix X c plays the role of clean input to the SDAE while the noise-corrupted matrix, also a J-by-B matrix, is denoted by X 0 . The output of layer l of the SDAE is denoted by X l which is a J-by-K l matrix. Similar to X c , row j of X l is denoted by X l,j * . W l and b l are the weight matrix and bias vector, respectively, of layer l, W l, * n denotes column n of W l , and L is the number of layers. For convenience, we use W + to denote the collection of all layers of weight matrices and biases. Note that an L/2-layer SDAE corresponds to an L-layer network.Generalized Bayesian SDAE: Following the introduction of SDAE in Section 2.2, if we assume that both the clean input X c and the corrupted input X 0 are observed, similar to [2], [3], [9], [37], we can define the following generative process of generalized Bayesian SDAE: Here λ w , λ n , λ u , λ s , and λ v are hyperparameters and C ij is a confidence parameter similar to that for CTR [55] (C ij = a if R ij = 1 and C ij = b otherwise). Note that the middle layer X L/2 serves as a bridge between the ratings and content information. This middle layer, along with the latent offset j , is the key that enables CDL to simultaneously learn an effective feature representation and capture the similarity and (implicit) relationship between items (and users). Similar to the generalized SDAE, for computational efficiency, we can also take λ s to infinity.Note that if λ s goes to infinity, the Gaussian distribution in Equation (8) will become a Dirac delta distribution [52] centered at σ(X l−1,j * W l + b l ), where σ(·) is the sigmoid function. The model will degenerate to be a Bayesian formulation of SDAE. That is why we call it generalized SDAE.Note that the first L/2 layers of the network act as an encoder and the last L/2 layers act as a decoder. Maximization of the posterior probability is equivalent to minimization of the reconstruction error with weight decay taken into consideration.Collaborative Deep Learning: Using the Bayesian SDAE as a component, the generative process of CDL is defined as follows:The graphical model of CDL when λ s approaches positive infinity is shown in Figure 8, where, for notational simplicity, we use x 0 , x L/2 , and x L in place ofNote that according the definition in Section 4.1, here the perception variables Ω p = {{W l }, {b l }, {X l }, X c }, the hinge variables Ω h = {V}, and the task variables Ω t = {U, R}. 1) For each layer l of the SDAE network, a) For each column n of the weight matrix W l , draw W l, * n ∼ N (0, λ Learning: Based on the CDL model above, all parameters could be treated as random variables so that fully Bayesian methods such as Markov chain Monte Carlo (MCMC) or variational approximation methods [30] may be applied. However, such treatment typically incurs high computational cost. Consequently, CDL uses an EM-style algorithm for obtaining the MAP estimates, as in [55].Like in CTR [55], maximizing the posterior probability is equivalent to maximizing the joint log-likelihood of U, V, {X l }, X c , {W l }, {b l }, and R given λ u , λ v , λ w , λ s , and λ n :and then set the latent item vector:3) Draw a latent user vector for each user i:5. Note that while generation of the clean input Xc from X L is part of the generative process of the Bayesian SDAE, generation of the noise-corrupted input X 0 from Xc is an artificial noise injection process to help the SDAE learn a more robust feature representation.to zero, leading to the following update rules: Fig. 9. NN representation for degenerated CDL.T is a column vector containing all the ratings of user i, and C ij reflects the confidence controlled by a and b as discussed in [28]. C j and R j are defined similarly for item j.Given U and V, we can learn the weights W l and biases b l for each layer using the back-propagation learning algorithm. The gradients of the likelihood with respect to W l and b l are as follows:If λ s goes to infinity, the likelihood becomes:where the encoder function f e (·, W + ) takes the corrupted content vector X 0,j * of item j as input and computes the encoding of the item, and the function f r (·, W + ) also takes X 0,j * as input, computes the encoding and then reconstructs the content vector of item j. For example, if the number of layers L = 6, f e (X 0,j * , W + ) is the output of the third layer while f r (X 0,j * , W + ) is the output of the sixth layer.By alternating the update of U, V, W l , and b l , we can find a local optimum for L . Several commonly used techniques such as using a momentum term may be applied to alleviate the local optimum problem. Prediction: Let D be the observed test data. Similar to [55], CDL uses the point estimates of u i , W + and j to calculate the predicted rating:From the perspective of optimization, the third term in the objective function (9) above is equivalent to a multi-layer perceptron using the latent item vectors v j as the target while the fourth term is equivalent to an SDAE minimizing the reconstruction error. Seeing from the view of neural networks (NN), when λ s approaches positive infinity, training of the probabilistic graphical model of CDL in Figure 8(left) would degenerate to simultaneously training two neural networks overlaid together with a common input layer (the corrupted input) but different output layers, as shown in Figure 9. Note that the second network is much more complex than typical neural networks due to the involvement of the rating matrix.When the ratio λ n /λ v approaches positive infinity, it will degenerate to a two-step model in which the latent representation learned using SDAE is put directly into the CTR. Another extreme happens when λ n /λ v goes to zero where the decoder of the SDAE essentially vanishes. On the right of Figure 8 is the graphical model of the degenerated CDL when λ n /λ v goes to zero. As demonstrated in the experiments, the predictive performance will suffer greatly for both extreme cases [60].For u i and v j , block coordinate descent similar to [28], [55] is used. Given the current W + , we compute the gradients of L with respect to u i and v j and then set themwhere E[·] denotes the expectation operation. In other words, we approximate the predicted rating as:Note that for any new item j with no rating in the training data, its offset * j will be 0. In the following text, we provide several extensions of CDL from different perspectives.Besides the MAP estimates, a sampling-based algorithm for the Bayesian treatment of CDL is also proposed in [60]. This algorithm turns out to be a Bayesian and generalized version of the well-known back-propagation (BP) learning algorithm. We list the key conditional densities as follows:For W+: We denote the concatenation of W l, * n and b  closed-form solutions directly. In this sense, mSDAE is more computationally efficient than SDAE.As mentioned in [35], using mSDAE instead of the Bayesian SDAE could lead to more efficient learning algorithms. For example, in [35], the objective when using a one-layer mSDAE can be written as follows: Note that for the last layer (l = L) the second Gaussian would be N (X c,j * |X l,j * , λ where X 0,j * is the collection of k different corrupted versions of X 0,j * (a k-by-B matrix) and X c,j * is the k-time repeated version of X c,j * (also a k-by-B matrix). P 1 is the transformation matrix for item latent factors.The solution for W 1 would be:Similarly, we have wherec X c . A solver for the expectation in the equation above is provided in [10]. Note that this is a linear and one-layer case which can be generalized to the nonlinear and multi-layer case using the same techniques as in [9], [10].As we can see, in marginalized CDL, the perception variables Ω p = {X 0 , X c , W 1 }, the hinge variables Ω h = {V}, and the task variablesInterestingly, if λ s goes to infinity and adaptive rejection Metropolis sampling (which involves using the gradients of the objective function to approximate the proposal distribution) is used, the sampling for W + turns out to be a Bayesian generalized version of BP. Specifically, as Figure 10 shows, after getting the gradient of the loss function at one point (the red dashed line on the left), the next sample would be drawn in the region under that line, which is equivalent to a probabilistic version of BP. If a sample is above the curve of the loss function, a new tangent line (the black dashed line on the right) would be added to better approximate the distribution corresponding to the loss function. After that, samples would be drawn from the region under both lines. During the sampling, besides searching for local optima using the gradients (MAP), the algorithm also takes the variance into consideration. That is why it is called Bayesian generalized back-propagation.CDL assumes a collaborative filtering setting to model the ratings directly. However, the output of recommender systems is often a ranked list, which means it would be more natural to use ranking rather than ratings as the objective. With this motivation, collaborative deep ranking (CDR) is proposed [64] to jointly perform representation learning and collaborative ranking. The corresponding generative process is as follows:1) For each layer l of the SDAE network, a) For each column n of the weight matrixand then set the latent item vector to be:In SDAE, corrupted input goes through encoding and decoding to recover the clean input. Usually, different epochs of training use different corrupted versions as input. Hence generally, SDAE needs to go through enough epochs of training to see sufficient corrupted versions of the input. Marginalized SDAE (mSDAE) [10] seeks to avoid this by marginalizing out the corrupted input and obtaining .3) For each user i, a) Draw a latent user vector for each user i:For each pair-wise preference (j, k) ∈ P i , whereFollowing the generative process above, the log-likelihood in Equation (9) becomes:i,j,k Similar algorithms can be used to learn the parameters in CDR. As reported in [64], using the ranking objective leads to significant improvement in the recommendation performance.Following the definition in Section 4.1, CDR's perception variables Ω p = {{W l }, {b l }, {X l }, X c }, the hinge variables Ω h = {V}, and the task variables Ω t = {U, ∆}. and its variants can simultaneously extract an effective deep feature representation from content and capture the similarity and implicit relationship between items (and users). The learned representation may also be used for tasks other than recommendation. Unlike previous deep learning models which use a simple target like classification [31] and reconstruction [54], CDL-based models use CF as a more complex target in a probabilistic framework.As mentioned in Section 1, information exchange between two components is crucial for the performance of BDL. In the CDL-based models above, the exchange is achieved by assuming Gaussian distributions that connect the hinge variables and the variables in the perception component (drawing the hinge variableModels like [60], [64] focus the deep learning component on modeling the item content. Besides the content information from the items, attributes of users sometimes contain much more important information. It is therefore desirable to extend CDL to model user attributes as well [35]. We call this variant symmetric CDL. For example, using an extra mSDAE on the user attributes gives the following joint log-likelihood:is a perception variable), which is simple but effective and efficient in computation. Among the five CDL-based models in Table 1, three of them are HV models and the others are LV models, according to the definition of Section 4.1. Since it has been verified that the HV CDL significantly outperforms its ZV counterpart [60], we can expect extra performance boost from the LV counterparts of the three HV models.Besides efficient information exchange, the designs of the models also meet the i.i.d. requirement on the distribution concerning hinge variables discussed in 4.1 and are hence easily parallelizable. In some models to be introduced later, we will see alternative designs to enable efficient and i.i.d. information exchange between the two components of BDL.In this section, we review some examples of using BDL for topic models. These models combine the merits of PGM (which naturally incorporates the probabilistic relationships among variables) and NN (which learns deep representations efficiently), leading to significant performance boost. where, the hinge variables Ω h = {V, U}, and the task variables Ω t = {P 1 , P 2 , R}.CDL is the first hierarchical Bayesian model to bridge the gap between state-of-the-art deep learning models and RS. By performing deep learning collaboratively, CDL c,j * ∈ R B denoting the content (attributes) of item j. Besides, we use I K to denote a K-dimensional identity matrix and S = [s 1 , s 2 , · · · , s J ] to denote the relational latent matrix with s j representing the relational properties of item j.From the perspective of SDAE, the J-by-B matrix X c represents the clean input to the SDAE and the noise-corrupted matrix of the same size is denoted by X 0 . Besides, we denote the output of layer l of the SDAE, a J-by-K l matrix, by X l . Row j of X l is denoted by X l,j * , W l and b l are the weight matrix and bias vector of layer l, W l, * n denotes column n of W l , and L is the number of layers. As a shorthand, we refer to the collection of weight matrices and biases in all layers as W + . Note that an L/2-layer SDAE corresponds to an L-layer network.Model Formulation: Here we will use the Bayesian SDAE introduced before as a building block for the relational stacked denoising autoencoder (RSDAE) model.As mentioned in [59], RSDAE is formulated as a novel probabilistic model which can seamlessly integrate layeredj A ij and A is the adjacency matrix representing the relational information with binary entries indicating the links (or relations) between items. A jj = 1 indicates that there is a link between item j and item j andrepresentation learning and the relational information available. This way, the model can simultaneously learn the feature representation from the content information and the relation between items. The graphical model of RSDAE is shown in Figure 11 and the generative process is listed as follows:s I K ) and the Gaussian N (s j , λ r I K ), which is also a Gaussian [14].According to the generative process above, maximizing the posterior probability is equivalent to maximizing the joint log-likelihood of {X l }, X c , S, {W l }, and {b l } given λ s , λ w , λ l , λ r , and λ n : T 1) Draw the relational latent matrix S from a matrix variate normal distribution [20]:2) For layer l of the SDAE where l = 1, 2, . . . ,Similar to the generalized SDAE, taking λ s to infinity, the joint log-likelihood becomes:of the SDAE network, draw the representation vector for item j from the product of two Gaussians (PoG) [14]:corresponds to log p(S) in the matrix variate distribution in Equation (15). Besides, by simplewhere S k * denotes the k-th row of S. As we can see, maximizingis the dimensionality of the learned representation vector for each item, S denotes the K × J relational latent matrix in which column j is the relational latent vector s j for item j. Note that N K,J (0, (13) is a matrix variate normal distribution defined as in [20]:is equivalent to making s j closer to s j if item j and item j are linked (namely A jj = 1). In RSDAE, the perception variables Ω p = {{X l }, X c , {W l }, {b l }}, the hinge variables Ω h = {S}, and the task variables Ω t = {A}.Learning Relational Representation and Topics: [59] provides an EM-style algorithm for MAP estimation. Here we review some of the key steps as follows.In terms of the relational latent matrix S, we first fix all rows of S except the k-th one S k * and then update S k * . Specifically, we take the gradient of L with respect to S k * , set it to 0, and get the following linear system:where the operator ⊗ denotes the Kronecker product of two matrices [20], tr(·) denotes the trace of a matrix, and A naive approach is to solve the linear system by settingthe complexity is O(J 3 ) for one single update. Similar to [36], the steepest descent method [50] is used to iteratively update S k * :[15], the generative process can be summarized as follows:T As discussed in [36], the use of steepest descent method dramatically reduces the computation cost in each iteration fromx pnk ∼ Pois(φ pk θ kn h(1) kn )K Given S, we can learn W l and b l for each layer using the back-propagation algorithm. By alternating the update of S, W l , and b l , a local optimum for L can be found. Also, techniques such as including a momentum term may help to avoid being trapped in a local optimum.where L is the number of layers in SBN, which corresponds to Equation (19) and (20). x pnk is the count of word p that comes from topic k in document n.In this model, the perception variables Ω p = {{H (l) }, {W l }, {b l }}, the hinge variables Ω h = {X}, and the task variablesand b l is the bias vector containing entries of bThe Poisson distribution with support over nonnegative integers is known as a natural choice to model counts. It is, therefore, desirable to use it as a building block for topic models [6]. With this motivation, [66] proposed a model, dubbed Poisson factor analysis (PFA), for latent nonnegative matrix factorization via Poisson distributions.in Equation (20). Learning Using Bayesian Conditional Density Filtering: Efficient learning algorithms are needed for Bayesian treatments of deep PFA. [15] proposed to use an online version of MCMC called Bayesian conditional density filtering (BCDF) to learn both the global parametersThe key conditional densities used for the Gibbs updates are as follows:Poisson Factor Analysis: PFA assumes a discrete P -by-N matrix X containing word counts of N documents with a vocabulary size of P [15], [66]. In a nutshell, PFA can be described using the following equation:wherex pnk , and ζ pnk ∝ φ pk θ kn . For where Φ (of size P -by-K where K is the number of topics) denotes the factor loading matrix in factor analysis with the k-th column φ k encoding the importance of each word in topic k. The K-by-N matrix Θ is the factor score matrix with the n-th column θ n containing topic proportions for document n. The K-by-N matrix H is a latent binary matrix with the n-th column h n defining a set of topics associated with document n. Different priors correspond to different models. For example, Dirichlet priors on φ k and θ n with an all-one matrix H would recover LDA [6] while a beta-Bernoulli prior on h n leads to the NB-FTM model in [65]. In [15], a deep-structured prior based on sigmoid belief networks (SBN) [39] (an MLP variant with binary hidden units) is imposed on h n to form a deep PFA model for topic modeling.kn where l &gt; 1, the same techniques as in [16] can be used.Learning Using Stochastic Gradient Thermostats: An alternative way of learning deep PFA is through the use of stochastic gradient Nóse-Hoover thermostats (SGNHT), which is more accurate and scalable. SGNHT is a generalization of the stochastic gradient Langevin dynamics (SGLD) [63] and the stochastic gradient Hamiltonian Monte Carlo (SGHMC) [11]. Compared with the previous two, it introduces momentum variables into the system, helping the system to jump out of local optima. Specifically, the following stochastic differential equations (SDE) can be used:Deep Poisson Factor Analysis: In the deep PFA model) is the negative log-posterior of the model. t indexes time and W denotes the standard Wiener process. ξ is the thermostats variable to make sure the system has a constant temperature. D is the injected variance which is a constant. To speed up convergence, the SDE is generalized to:and naively modifying this model to be its ZV counterpart would violate the i.i.d. requirement in Section 4.1.where I is the identity matrix,, and M is the dimensionality of the parameters.Similar to the deep PFA above, the restricted Boltzmann machine (RBM) [23] can be used in place of SBN [15]. If RBM is used, Equation (19) and (20) would be defined using the energy [23]:As mentioned in Section 1, Bayesian deep learning can also be applied to the control of nonlinear dynamical systems from raw images. Consider controlling a complex dynamical system according to the live video stream received from a camera. One way of solving this control problem is by iteration between two tasks, perception from raw images and control based on dynamic models. The perception task can be taken care of using multiple layers of simple nonlinear transformation (deep learning) while the control task usually needs more sophisticated models like hidden Markov models and Kalman filters [21], [38]. To enable an effective iterative process between the perception task and the control task, we need two-way information exchange between them. The perception component would be the basis on which the control component estimates its states and on the other hand, the control component with a dynamic model built in would be able to predict the future trajectory (images) by reversing the perception process [62].For the learning, similar algorithms as the deep PFA with SBN can be used. Specifically, the sampling process would alternate between {{φ k }, {γ k }, γ 0 } and {{W (l) }, {c (l) }}. For the former, similar conditional density as the SBN-based DPFA is used. For the latter, they use the contrastive divergence algorithm.Following [62], we consider the stochastic optimal control of an unknown dynamical system as follows:In BDL-based topic models, the perception component is responsible for inferring the topic hierarchy from documents while the task-specific component is in charge of modeling the word generation, topic generation, word-topic relation, or inter-document relation. The synergy between these two components comes from the bidirectional interaction between them. On one hand, knowledge on the topic hierarchy would facilitate accurate modeling of words and topics, providing valuable information for learning inter-document relation. On the other hand, accurately modeling the words, topics, and inter-document relation could help with the discovery of topic hierarchy and learning of compact document representations. As we can see, the information exchange mechanism in some BDL-based topic models is different from that in Section 4.2. For example, in the SBN-based DPFA model, the exchange is natural since the bottom layer of SBN, H (1) , and the relationship between H(1) and Ω h = {X} are both inherently probabilistic, as shown in Equation (20) and (21), which means additional assumptions on the distribution are not necessary. The SBN-based DPFA model is equivalent to assuming that H in PFA (see Equation (18)) is generated from a Dirac delta distribution (a Gaussian distribution with zero variance) centered at the bottom layer of the SBN, H(1) . Hence both DPFA models in Table 1 are ZV models, according to the definition in Section 4.1. It is worth noting that RSDAE is an HV model (see Equation (14), where S is the hinge variable and the others are perception variables), where t indexes the time steps and z t ∈ R nz is the latent states. u t ∈ R nu is the applied control at time t and ξ denotes the system noise. Equivalently, the equation above can be written as P (z t+1 |z t , u t ) = N (z t+1 |f (z t , u t ), Σ ξ ). Hence we need a mapping function to map the corresponding raw image x t (observed input) into the latent space:where ω is the corresponding system noise. Similarly the equation above can be rewritten as z t ∼ N (m(x t ), Σ ω ). If the function f is given, finding optimal control for a trajectory of length T in a dynamical system amounts to minimizing the following cost:t0 where c T (z T , u T ) is the terminal cost and c(z t , u t ) is the instantaneous cost. z 1:T = {z 1 , . . . , z T } and u 1:T = {u 1 , . . . , u T } are the state and action sequences, respectively. For simplicity we can let c T (z T , u T ) = c(z T , u T ) and use the following quadratic cost:where R z ∈ R nz×nz and R u ∈ R nu×nu are the weighting matrices. z goal is the target latent state that should be inferred from the raw images (observed input). Given the function f , z 1:T (current estimates of the optimal trajectory), and u 1:T (the corresponding controls), the dynamical system can be linearized as:where A(z t ) = ∂f (zt,ut) ∂zt and B(z t ) = ∂f (zt,ut) ∂ut are local Jacobians. o(z t ) is the offset.To minimize the function in Equation (23), we need three key components: an encoding model to encode x t into z t , a transition model to infer z t+1 given (z t , u t ), and a reconstruction model to reconstruct x t+1 from the inferred z t+1 .Encoding Model: An encoding model Q φ (Z|X) = N (µ t , diag(σ where P (Z) is the prior distribution for Z. With the equations above, stochastic gradient variational Bayes can be used to learn the parameters.According to the generative process in Equation (27)-(29) and the definition in Section 4.1, the perception variables Ω p = {h enc + φ (·), W p , x t , µ t , σ t , p t , h dec θ (·)}, where W + p is shorthand for {W µ , b µ , W σ , b σ , W p , b p }. The hinge variables Ω h = {z t , z t+1 } and the task variables Ω t = {A t , B t , o t , u t , C t , ω t , W t )), where the mean µ t ∈ R nz and the diagonal covariance Σ t = diag(σ 2 t ) ∈ R nz×nz , encodes the raw images x t into latent states z t . Here,where h φ (x t ) enc is the output of the encoding network with x t as its input.Transition Model: A transition model like Equation (24) infers z t+1 from (z t , u t ). If we use Q ψ ( Z|Z, u) to denote the approximate posterior distribution to generate z t+1 , the generative process of the full model would be:where Equation (29) is the reconstruction model to be discussed later, C t = A t Σ t A T 2 t + H t , and H t is the covariance matrix of the estimated system noise (ω t ∼ N (0, H t )). The key here is to learn A t , B t and o t , which are parameterized as follows:As mentioned in Section 1, BDL-based control models consist of two components, a perception component to see the live video and a control (task-specific) component to infer the states of the dynamical system. Inference of the system is based on the mapped states and the confidence of mapping from the perception component, and in return, the control signals sent by the control component would affect the live video received by the perception component. Only when the two components work interactively within a unified probabilistic framework can the model reach its full potential and achieve the best control performance.In terms of information exchange between the two components, the BDL-based control model discussed above uses a different mechanism from Section 4.2 and Section 4.3: it uses neural networks to separately parameterize the mean and covariance of hinge variables (e.g., in the encoding model, the hinge variable z t ∼ N (µ t , diag ), where µ t and σ t are perception variables parameterized as in Equation (25) and (26)), which is more flexible (with more free parameters) than models like CDL and CDR in Section 4.2, where Gaussian distributions with fixed variance are also used. Note that this BDL-based control model is an LV model as shown in Table 1, and since the covariance is assumed to be diagonal, the model still meets the i.i.d. requirement in Section 4.1. ψ (z t ) is the output of the transition network. Reconstruction Model: As mentioned in Equation (29), the posterior distribution P θ (X|Z) reconstructs the raw images x t from the latent states z t . In Equation (29), the parameters for the Bernoulli distribution p t = W p h 5 CONCLUSIONS AND FUTURE RESEARCH dec θ (z t )+ b p where h dec θ (z t ) is the output of a third network, called the decoding network or the reconstruction network. Putting it all together, Equation (27)- (29) show the generative process of the full model.With D = {(x 1 , u 1 , x 2 ), . . . , (x T −1 , u T −1 , x T )} as the training set, the loss function is as follows:where the first term is the variational bound on the marginalized log-likelihood for each data point:In this survey, we identified a current trend of merging probabilistic graphical models and neural networks (deep learning) and reviewed recent work on Bayesian deep learning, which strives to combine the merits of PGM and NN by organically integrating them in a single principled probabilistic framework. To learn parameters in BDL, several algorithms have been proposed, ranging from block coordinate descent, Bayesian conditional density filtering, and stochastic gradient thermostats to stochastic gradient variational Bayes. Bayesian deep learning gains its popularity both from the success of PGM and from the recent promising advances on deep learning. Since many real-world tasks involve both perception and inference, BDL is a natural choice to harness the perception ability from NN and the (causal and logical) inference ability from PGM. Although current applications of BDL focus on recommender systems, topic models, and stochastic optimal control, in the future, we can expect an increasing number of other applications like link prediction, community detection, active learning, Bayesian reinforcement learning, and many other complex tasks that need interaction between perception and causal inference. Besides, with the advances of efficient Bayesian neural networks (BNN), BDL with BNN as an important component is expected to be more and more scalable.
