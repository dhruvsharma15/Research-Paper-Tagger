Optical character recognition (OCR) is most commonly used to recognize natural language from an image; how- ever, as early as the work of Anderson (1967), there has been research interest in converting images into structured language or markup that defines both the text itself and its presentational semantics. The primary target for this research is OCR for mathematical expressions, and how to handle presentational aspects such as sub and super- script notation, special symbols, and nested fractions (Belaid &amp; Haton, 1984;Chan &amp; Yeung, 2000). The most ef- fective systems combine specialized character segmenta- tion with grammars of the underlying mathematical layout language (Miller &amp; Viola, 1998). A prime example of this approach is the INFTY system that is used to convert printed mathematical expressions to LaTeX and other markup for- mats ( Suzuki et al., 2003). Other, mostly proprietary sys- However, we note that tasks such as image captioning dif- fer from the traditional mathematical OCR task in two re- spects: first, unlike image captioning, the traditional OCR task assumes a left-to-right ordering, so neural systems ad- dressing this problem have primarily relied on Connection- ist Temporal Classification (CTC) ( Graves et al., 2006) or stroke-based approaches. Second, the image captioning task theoretically allows for systems to focus their atten- tion anywhere, and thus does not directly test a system's ability to maintain consistent tracking with its attention. 1 Harvard University 2 University of Eastern Finland. Corre- spondence to: Yuntian Deng &lt;dengyuntian@seas.harvard.edu&gt;.In this work, we explore the use of attention-based image- to-text models ( Xu et al., 2015) for the problem of generat- ing structured markup. We consider whether a supervised model can learn to produce correct presentational markup from an image, without requiring a textual or visual gram- mar of the underlying markup language. Our model incor- porates a multi-layer convolutional network over the image with an attention-based recurrent neural network decoder. To adapt this model to the OCR problem and capture the document's layout, we also incorporate a new source en- coder layer in the form of a multi-row recurrent model as part of the encoder. Our modeling contributions are twofold. First, we show that assumptions like the left-to-right ordering inherent in CTC-based models are not required for neural OCR, since general-purpose encoders can provide the necessary track- ing for accurate attention (example shown in Figure 1). Second, in order to reduce attention computation overhead, we introduce a novel two-layer hard-soft approach to at- tention, which we call coarse-to-fine attention, inspired by coarse-to-fine inference (Raphael, 2001) from graphi- cal models.1 Sparse memory and conditional computation with neural networks have also been explored with various levels of success in several previous works Shazeer et al., 2017;Rae et al., 2016;Andrychowicz &amp; Kurach, 2016). We demonstrate here that this coarse-to- fine method, when trained with REINFORCE, significantly reduces the overhead of attention, and leads to only a small drop in accuracy. produce over 30% exact match output. All data, mod- els, and evaluation scripts are publicly available at http: //lstm.seas.harvard.edu/latex/.To make these experiments possible, we also construct a new public dataset, IM2LATEX-100K, which consists of a large collection of rendered real-world mathematical ex- pressions collected from published articles 2 . This dataset provides a challenging test-bed for the image-to-markup task based on reconstructing mathematical markup from rendered images, originally written by scientists. A model is trained to generate LaTeX markup with the goal of ren- dering to the exact source image.We define the image-to-markup problem as converting a rendered source image to target presentational markup that fully describes both its content and layout. The source, x, consists of an image. The target, y, consists of a sequence of tokens y 1 , y 2 , · · · , y T where T is the length of the out- put, and each y is a token in the markup language. The rendering is defined by a possibly unknown, many-to-one, compile function, compile. In practice this function may be quite complicated, e.g a browser, or ill-specified, e.g. the LaTeX language.The supervised task is to learn to approximately invert the compile function using supervised examples of its behav- ior. We assume that we are given instances (x, y), with possibly differing dimensions and that, compile(y) ≈ x, for all training pairs (x, y) (assuming possible noise).Experiments compare the output of the model with sev- eral research and commercial baselines, as well as abla- tions of these models. The full system for mathematical expression generation is able to reproduce the same im- age on more than 75% of real-world test examples. Ad- ditionally, the use of a multi-row encoder leads to a sig- nificant increase in performance. We also experiment with training on a simulated handwritten version of the dataset to recognize handwritten textual expressions. Even with only a small in-domain training set, the model is able to At test time, the system is given a raw input x rendered from ground-truth y. It generates a hypothesisˆyhypothesisˆ hypothesisˆy that can then be rendered by the black-box functionˆxfunctionˆ functionˆx = compile(ˆ y). Evaluation is done betweenˆxbetweenˆ betweenˆx and x, i.e. the aim is to produce similar rendered images whilê y may or may not be similar to the ground-truth markup y.Contrary to most past work on neural OCR, our model uses a full grid encoder over the input image, so that it can support non left-to-right order in the generated markup. The base model is adapted from the encoder of Xu et al. (2015) developed for image captioning. Notably, though, our model also includes a row encoder which helps the per- formance of the system.Image-to-Markup Generation with Coarse-to-Fine AttentionRow Encoder In image captioning, the CNN features are used as is. For OCR, however, it is important for the en- coder to localize the relative positions within the source image. In past work this localization has been handled by CTC, which in effect partitions the source into regions. We instead implicitly allow the encoder to localize its input by running RNNs over each of the rows of CNN features. This extension turns out to be crucial for performance.Encoder˜ Encoder˜V x Formally, a recurrent neural network (RNN) is a parameter- ized function RNN that recursively maps an input vector and a hidden state to a new hidden state. At time t, the hid- den state is updated with an input v t in the following man- ner: h t = RNN(h t−1 , v t ; θ), with h 0 an initial state. In practice there are many different variants of RNN; how- ever, long short-term memory networks (LSTMs) (Hochreiter &amp; Schmidhuber, 1997) have been shown to be very ef- fective for most NLP tasks. For simplicity we will describe the model as an RNN, but all experiments use LSTM net- works.Figure 2: Network structure. Given an input image, a CNN is applied to extract a feature map˜Vmap˜ map˜V. For each row in the feature map, we employ an RNN to encode spatial layout information. The encoded fine features V are then used by an RNN decoder with a visual attention mechanism to produce final outputs. For clarity we only show the RNN encoding at the first row and the decoding at one step. In Section 4, we consider variants of the model where another CNN and row encoder are applied to the feature map to extract coarse features V , which are used to select a support region in the fine-grained features, as indicated by the blue masks.In this model, the new feature grid V is created from˜V from˜ from˜V by running an RNN across each row of that input. Recursively for all rows h ∈ {1, . . . , H} and columns w ∈ {1, . . . , W }, the new features are defined asIn order to capture the sequential order information in vertical direction, we use a trainable initial hidden state V h,0 for each row, which we refer to as positional embeddings.The model first extracts image features using a convolu- tional neural network (CNN) and arranges the features in a grid. Each row is then encoded using a recurrent neural network (RNN). These encoded features are then used by an RNN decoder with a visual attention mechanism. The decoder implements a conditional language model over the vocabulary, and the whole model is trained to maximize the likelihood of the observed markup. The full structure is illustrated in Figure 2.Decoder The target markup tokens {y t } are then gener- ated by a decoder based only on the grid V. The decoder is trained as a conditional language model to give the prob- ability of the next token given the history and the annota- tions. This language model is defined on top of a decoder RNN,Convolutional Network The visual features of an image are extracted with a multi-layer convolutional neural net- work interleaved with max-pooling layers. This network architecture is now standard; we model it specifically af- ter the network used by Shi et al. (2015) for OCR from images (specification is given in Table 1 The context vector c t is used to capture the context in- formation from the annotation grid. We describe how to compute c t in the next section.The accuracy of the model is dependent on being able to track the next current position of the image for generat- ing markup, which is conveyed through an attentive context vector c t . Formally, we define a latent categorical variable z t ∈ {1, · · · , H} × {1, · · · , W } to denote which cell the model is attending to. If we assume access to an attention distribution z t ∼ p(z t ), then the context is defined as an expectation of source side features:. However to compute the p(z t ) even with this hierarchical attention, still requires O(HW ) as in standard attention.In practice, the attention distribution is parameterized as part of the model. We consider three forms of attention: standard, hierarchical, and coarse-to-fine.Standard Attention In standard attention ( Bahdanau et al., 2014), we use a neural network to approximate the attention distribution p(z t ):Coarse-to-Fine Attention Ideally we could consider a reduced set of possible coarse cells in hierarchical attention to reduce time complexity. Borrowing the name coarse-to- fine inference (Raphael, 2001) we experiment with meth- ods to construct a coarse attention p(zwhere a(·) is a neural network to produce unnormalized attention weights. Note there are different choices for a -we follow past empirical work and uset ) with a sparse sup- port to reduce the number of fine attention cells we con- sider. We use two different approaches for training this sparse coarse distribution.For the first approach we use sparsemax attention (Martins &amp; Astudillo, 2016) where instead of using a softmax for p(z Figure 1 shows an example of the attention distribution at each step of the model. Note several key properties about the attention distribution for the image-to-text problem. 1) It is important for the grid to be relatively small for atten- tion to localize around the current symbol. For this reason we use a fine grid with a large H and W . 2) In practice, the support of the distribution is quite small as a single markup symbol is in a single region. 3) As noted above, attention is run every time step and requires an expectation over all cells. Therefore the decoding complexity of such an at- tention mechanism is O(T HW ), which can be prohibitive when applied to large images. t ) at the coarse-level, we substitute a Euclidean pro- jection onto the simplex. The sparsemax function is de- fined as, sparsemax(p) = argmin q∈∆ K−1 2 , where ∆ K−1 is the probability simplex and K denotes the num- ber of classes. The sparsemax function can be computed efficiently and as a projection and can be shown to produce a sparser output than the standard softmax. If there are K + nonzero entries returned by sparsemax, then the attention time complexity for one step is. In practice, we find K + to be suitably small.For the second approach we use "hard" attention for z t , an approach which has been shown to work in several im- age tasks ( Xu et al., 2015;Mnih et al., 2014;Ba et al., 2015). Here we take a hard sample from p(z Hierarchical Attention When producing a target symbol from an image, we can infer the rough region where it is likely to appear from the last generated symbol with high probability. In addition to the fine grid, we therefore also impose a grid over the image, such that each cell belongs to a larger region. When producing the markup, we first attend to the coarse grid to get the relevant coarse cell(s), and then attend to the inside fine cells to get the context vector, a method known as hierarchical attention. t ) as opposed to considering the full distribution. Due to this stochas- ticity, the objective is no longer differentiable. However, stochastic networks can be trained using the REINFORCE algorithm (Williams, 1992). We pose the problem in the framework of reinforcement learning by treating z t as our agent's stochastic action at time t and the log-likelihood of the symbol produced as the reward r t . We aim to max- imize the total expected reward E z t [ T t=1 r t ], or equiva- lently minimize the negative expected reward as our loss.For this problem, define V as a coarse grid of size H × W , which we construct by running additional convolution and pooling layers and row encoders on top of˜Vof˜ of˜V. We also introduce a latent attention variable z For parameters θ that precede the nondifferentiable z ∂ log p(z t in the stochastic computation graph, we backpropagate a gradient of the form r t · . This gives us an unbiased esti- mate of the loss function gradient ( Schulman et al., 2015). Since our decoder RNN takes previous context vectors as input at each time step, each action z t followed by a fine-level cell z t only from within it.We parameterize p(z t influences later re- wards r t , r t+1 , . . . , r T . Hence, we assume a multiplicative discount rate of γ for future rewards, and we use the reward˜r reward˜ reward˜r t = T s=t γ s r s in place of r t .t ) and p(z t |z t ) as part of the model. For p(z t ), we employ a standard attention mechanism over V to approximate the probability in time O(H W ). For the conditional p(z t |z t ), we also employ a standard atten- tion mechanism to get as before, except that we only con- sider the fine-level cells within coarse-level cell zIn practice, this gradient estimator is noisy and slow to con- verge. Following Xu et al. (2015), we include a moving average reward baseline for each timestep t that we update as b t ← βb t + (1 − β)˜ r t , where β is a tunable learning rate. We subtract these baselines from our rewards to reduce the tions), validation set (9,319 equations) and test set (10,354 equations) for a standardized experimental setup. The La- TeX formulas range from 38 to 997 characters, with mean 118 and median 98. Finally we note that naturally occurring LaTeX contains many different expressions that produce identical output. We therefore experiment with an optional normalization step to eliminate spurious ambiguity (prior to training). For normalization, we wrote a LaTeX parser 5 to convert the markup to an abstract syntax tree. We then apply a set of safe normalizing tree transformation to eliminate common spurious ambiguity, such as fixing the order of sub-super- scripts and transforming matrices to arrays. Surprisingly we find this additional step gives only a small accuracy gain, and is not necessary for strong results.To experiment on this task we constructed a new public dataset, IM2LATEX-100K, which collects a large-corpus of real-world mathematical expressions written in LaTeX. This dataset provides a difficult test-bed for learning how to reproduce naturally occurring rendered LaTeX markup.Corpus The IM2LATEX-100K dataset provides 103,556 different LaTeX math equations along with rendered pic- tures. We extract formulas by parsing LaTeX sources of papers from tasks I and II of the 2003 KDD cup (Gehrke et al., 2003), which contain over 60,000 papers.We extract formulas from the LaTeX sources with regular expressions, and only keep matches whose number of char- acters fall in the range from 40 to 1024 to avoid single sym- bols or text sentences. With these settings we extract over 800,000 different formulas, out of which around 100,000 are rendered in a vanilla LaTeX environment. Rendering is done with pdflatex 3 and formulas that fail to compile are ex- cluded. The rendered PDF files are then converted to PNG format 4 . The final dataset we provide contains 103,556 im- ages of resolution 1654 × 2339, and the corresponding La- TeX formulas.Synthetic Data for Handwriting Recognition Our main results focus on rendered markup, but we also considered the problem of recognizing handwritten math. As there is very little labeled data for this task, we also synthetized a handwritten corpus of the IM2LATEX-100K dataset. We created this data set by replacing all individual symbols with handwritten symbols taken from Detexify's training data 6 . We use the same set of formulas as in the original dataset, but when rendering each symbol we randomly pick a corresponding handwritten symbol from Detexify. An example of synthesized handwriting is shown in Figure 3. Note that although the images in this dataset look like hand- written formulas, they do not capture certain aspects such as varying baselines (Nagabhushan &amp; Alaei, 2010). We use this dataset as a pretraining step for handwritten formulas recognition on a small labeled dataset.The dataset is separated into training set (83,883 equa- Experiments compare the proposed model, which we re- fer to as IM2TEX to classical OCR baselines, neural mod- els, and model ablations on the image-to-LaTeX task. We also compare the proposed model against commer- cial, OCR-based mathematical expression recognition sys- tem InftyReader. InftyReader is an implementation of the INFTY system of ( Suzuki et al., 2003), combining symbol recognition and structural analysis phases.The CNN specifications are summarized in Table 1. Note that H = For neural models, a natural comparison is to standard im- age captioning approaches ( Xu et al., 2015), and CTC- based approaches (Shi et al., 2016). We simulate the image captioning setup with a model CAPTION which removes the row encoder, i.e. replacing V with˜Vwith˜ with˜V, and increases the number of CNN filters such that the number of param- eters is the same. For CTC we use the implementation of Shi et al. (2016), designed for natural image OCR. W = 4. The model uses single-layer LSTMs for all RNNs. We use a bi-directional RNN for the encoder. The hidden state of the encoder RNN is of size 256, decoder RNN of 512, and token embeddings of size 80. The model with standard at- tention has 9.48 million parameters, and the models with hierarchical or coarse-to-fine attention have 15.85 million parameters due to the additional convolution layers and row encoders. We use mini-batch stochastic gradient descent to learn the parameters.To better understand the role of attention in the model, we run several baseline experiments with different atten- tion styles. To examine if fine-level features are necessary, we experiment with a standard attention system with the coarse feature maps only (coarse-only) and also with a two- layer hierarchical model. Additionally we experiment with different coarse-to-fine (C2F) mechanisms: hard reinforce- ment learning, and sparsemax.For the standard attention models, we use batch size of 20. The initial learning rate is set to 0.1, and we halve it once the validation perplexity does not decrease. We train the model for 12 epochs and use the validation perplexity to choose the best model. For the hierarchical and coarse- to-fine attention models, we use batch size of 6. For hard attention, we use the pretrained weights of hierarchical to initialize the parameters. Then we use initial learning rate 0.005, average reward baseline learning rate β = 0.01, re- ward discount rate γ = 0.5.Finally, we run additional experiments comparing our ap- proach to other models for handwritten mathematical ex- pressions on the CROHME 2013 and 2014 shared tasks. The training set is same for both years, consisting of 8,836 training expressions (although teams also used external data). The dataset is in a different domain from our ren- dered images and is designed for stroke-based OCR. To handle these differences, we employ two extensions: (1) We convert the data to images by rendering the strokes and also augment data by randomly resizing and rotating symbols, (2) We also employ the simulated IM2LATEX- 100K handwriting dataset to pretrain a large out-of-domain model and then fine-tune it on this CROHME dataset.The complete model is trained end-to-end to maximize the likelihood of the training data. Beyond the training data, the model is given no other information about the markup language or the generating process. To generate markup from unseen images, we use beam search with beam size 5 at test time. No further hard constraints are employed.The system is built using Torch (Collobert et al., 2011) based on the OpenNMT system ( Klein et al., 2017). Exper- iments are run on a 12GB Nvidia Titan X GPU (Maxwell).Original images are cropped to only the formula area, and padded with 8 pixels to the top, left, right and bottom. For efficiency we downsample all images to half of their origi- nal sizes. To facilitate batching, we group images into sim- ilar sizes and pad with whitespace.8 All images of larger sizes, LaTeX formulas with more than 150 tokens, or those that cannot be parsed are ignored during training and vali- dation, but included during testing.Our core evaluation method is to check the accuracy of the rendered markup output imagê x compared to the true im- age x. The main evaluation reports exact match render- ing between the gold and predicted images, and we ad- ditionally check the exact match accuracy with the origi- nal image as well as the value after eliminating whitespace columns. 7 We also include standard intrinsic text gener- ation metrics, conditional language model perplexity and BLEU score ( Papineni et al., 2002), on both tokenized and normalized gold data.The main experimental results, shown at the top of Table 2, compare different systems on the image-to-markup task. The INFTY system is able to do quite well in terms of text accuracy, but performs poorly on exact match image met- rics. The poor results of the neural CTC system validate our expectation that the strict left-to-right order assump- tion is unsuitable in this case. Our reimplementation of im-   age captioning CAPTION does better, pushing the number above 50%. Our standard attention system IM2TEX with RNN encoder increases this value above 75%, achieving high accuracy on this task. The LaTeX normalizer provides a few points of accuracy gain and achieves high normalized BLEU. This indicates that the decoder LM is able to learn well despite the ambiguities in real-world LaTeX.indicating that fine attention is crucial to performance. On the other hand, the high performance of hierarchical indi- cates that two layers of soft-attention do not hurt the per- formance of the model. Table 4 shows the average number of cells being attended to at both the coarse and fine layers by each of the models. Both the hard REINFORCE system and sparsemax reduce lookups at a small cost in accuracy. Hard is the most aggressive, selecting a single coarse cell. Sparsemax achieves higher accuracy, at the cost of select- ing multiple coarse cells. Depending on the application, these are both reasonable alternatives to reduce the number of lookups in standard attention.We next compare the different hierarchical and coarse-to- fine extensions to the system. We first note that the use of the coarse-only system leads to a large drop in accuracy,Our final experiments look at the CROHME 2013 and 2014 datasets, which were designed as a stroke recognition task, but are the closest existing dataset to our task. For this dataset we first train with our synthetic handwriting dataset and then fine-tune on the CROHME training set. We find our models achieve comparable performance to all best sys- tems excepting MyScript, a commercial system with ac- cess to additional in-domain data. Note that our synthetic dataset does not contain variation in baselines, font sizes,  or other noise, which are common in real data. We expect increased performance from the system when trained with well-engineered data. For these datasets we also use the hi- erarchical and coarse-to-fine models, and find that they are similarly effective. Interestingly, contrary to the full data for some problems hard performs better than sparsemax. Analysis To better understand the contribution of each part of the standard IM2TEX model, we run ablation exper- iments removing different features from the model, which are shown in Table 3. The simplest model is a basic (non- conditional) NGRAM LM on LaTeX which achieves a per- plexity of around 8. Simply switching to an LSTM-LM re- duces the value to 5, likely due to its ability to count paren- theses and nesting-levels. These values are quite low, in- dicating strong regularity just in the LaTeX alone. Adding back the image data with a CNN further reduces the per- plexity down to 1.18. Adding the encoder LSTM adds a small gain to 1.12, but makes a large difference in final ac- curacy. Adding the positional embeddings (trainable initial states for each row) provides a tiny gain. Hard attention leads to a small increase in perplexity. We also consider the effect of training data on performance. Figure 4 shows accuracy of the system with different training set size us- ing standard attention. As with many neural systems, the model is quite data hungry. In order for the model to reach ≥ 50% accuracy, at least 16k training examples are needed.order to reduce the attention complexity, we propose a coarse-to-fine attention layer, which selects a region by us- ing a coarse view of the image, and use the fine-grained cells within. These contributions provide a new view on the task of structured text OCR, and show data-driven models can be effective without any knowledge of the language. The coarse-to-fine attention mechanism is general and di- rectly applicable to other domains, including applying the proposed coarse-to-fine attention layer to other tasks such as document summarization, or combining the proposed model with neural inference machines such as memory net- works.Finally Figure 5 illustrates several common errors. Qual- itatively the system is quite accurate on difficult LaTeX constructs. Typically the structure of the expression is pre- served with one or two symbol recognition errors. We find that the most common presentation-affecting errors come from font or sizing issues, such as using small parentheses instead of large ones, using standard math font instead of escaping or using mathcal. 
