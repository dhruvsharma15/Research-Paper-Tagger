T ODAY computer vision technologies are used with great success in many application areas, solving real-world problems in entertainment systems, robotics and surveil- lance [1]. More and more researchers and engineers are tackling action and object recognition problems with the help of brain-inspired algorithms, featuring many stages of feature detectors and classifiers, with lots of parameters that are opti- mized using the wealth of data that has recently become avail- able. These "deep learning" techniques are achieving record- breaking results on very challenging problems and datasets, outperforming either more mature concepts trying to model the specific problem at hand [2], [3], [4], [5], [6] or joining forces with traditional approaches by improving intermediate steps [7], [8]. Convolutional Networks (ConvNets) are a prime example of this powerful, yet conceptually simple paradigm [9], [10]. They can be applied to various data sources and perform best when the information is spatially or temporally well-localized, but still has to be seen in a more global context such as in images.As a testimony of the success of deep learning approaches, several research programs have been launched, even by major global industrial players (e.g. Facebook, Google, Baidu, Mi- crosoft, IBM), pushing towards deploying services based on brain-inspired machine learning to their customers within a arXiv: 1512 The authors would like to thank David Gschwend, Christoph Mayer and Samuel Willi for their contributions during design and testing of Origami. production environment [3], [8], [11]. These companies are mainly interested in running such algorithms on powerful compute clusters in large data centers.With the increasing number of imaging devices the im- portance of digital signal processing in imaging continues to grow. The amount of on-and near-sensor computation is rising to thousands of operations per pixel, requiring powerful energy-efficient digital signal processing solutions, often co- integrated with the imaging circuitry itself to reduce overall system cost and size [12]. Such embedded vision systems that extract meaning from imaging data are enabled by more and more energy-efficient, low-cost integrated parallel processing engines (multi-core DSPs, GPUs, platform FPGAs). This per- mits a new generation of distributed computer vision systems, which can bring huge value to a vast range of applications by reducing the costly data transmission, forwarding only the desired information [1], [13].Many opportunities for challenging research and innovative applications will pan out from the evolution of advanced embedded video processing and future situational awareness systems. As opposed to conventional visual monitoring sys- tems (CCTVs, IP cameras) that send the video data to a data center to be stored and processed, embedded smart cameras process the image data directly on board. This can significantly reduce the amount of data to be transmitted and the required human intervention -the sources of the two most expensive aspects of video surveillance [14]. Embedding convolutional network classifiers in distributed computer vision systems, seems a natural direction of evolution, However, deep neural networks are commonly known for their demand of computing power, making it challenging to bring this computational load within the power envelope of embedded systems -in fact, most state-of-the-art neural networks are currently not only trained, but also evaluated on workstations with powerful GPUs to achieve reasonable performance.Nevertheless, there is strong demand for mobile vision solutions ranging from object recognition to advanced human- machine interfaces and augmented reality. The market size is estimated to grow to many billions of dollars over the next few years with an annual growth rate of more than 13% [15]. This has prompted many new commercial solutions to become available recently, specifically targeting the mobile sector [16], [17], [18].In this paper we present:• The architecture of a novel convolutional network ac- celerator, which is scalable to TOP/s performance while remaining area-and energy-efficient and keeping I/O throughput within the limits of economical packages and low power budgets. This extends our work in [19].• An implementation of this architecture with optimized precision using fixed-point evaluations constrained for an accelerator-sized ASIC.• Silicon measurements of the taped-out ASIC, providing experimental characterization of the silicon.• A thorough comparison to and discussion of previous work. Organization of the paper: Section II shortly introduces convolutional networks and highlights the need for accelera- tion. Previous work is investigated in Section III, discussing available software, FPGA and ASIC implementations and explaining the selection of our design objectives. In Section IV we present our architecture and its properties. The implemen- tation aspects are shown in Section V. We present our results in Section VI and discuss and compare them in Section VII. We conclude the paper in Section VIII. linear unit (ReLU) [2], [4], [5], which designates the function x → max(0, x). The activation function introduces non- linearity into neural networks, giving them the potential to be more powerful than linear methods. Typical filter sizes range from 5 × 5 to 9 × 9, sometimes even 11 × 11 [2], [4], [21].The feature extractor with the convolutional layers is usually followed by a classification step with fully-connected neural network layers interspersed with activation functions, reducing the dimensionality from several hundred or even thousands down to the number of classes. In case of scene labeling these fully-connected layers are just applied on a per-pixel basis with inputs being the values of all the channels at any given pixel pixel [22].II. CONVOLUTIONAL NETWORKS Most convolutional networks (ConvNets) are built from the same basic building blocks: convolution layers, activation lay- ers and pooling layers. One sequence of convolution, activation and pooling is considered a stage, and modern, deep networks often consist of multiple stages. The convolutional network itself is used as a feature extractor, transforming raw data into a higher-dimensional, more meaningful representation. ConvNets particularly preserve locality through their limited filter size, which makes them very suitable for visual data (e.g., in a street scene the pixels in the top left corner contain little information on what is going on in the bottom right corner of an image, but if there are pixels showing the sky all around some segment of the image, this segment is certainly not a car). The feature extraction is then followed by a classifier, such as a normal neural network or a support vector machine.A stage of a ConvNet can be captured mathematically asConvolutional networks and deep neural networks in general are advancing into more and more domains of computer vision and are becoming increasingly more accurate in their traditional application area of object recognition and detection. ConvNets are now able to compute highly accurate optical flow [5], [6], [23], super-resolution [20] and more. The newer networks are usually deeper and require more computational effort, and those for the newly tapped topics have already been very deep from the beginning. Research is done on various platforms and computing devices are evolving rapidly, making time measurements meaningless. The deep learning community has thus started to measure the complexity of deep learning networks in a way that is more independent of the underlying computing platform, counting the additions and multiplications of the synapses of these networks. For a convolutional layer with n in input feature maps of size h in × w in , a filter kernel size of h k × w k , and n out output feature maps, this number amounts to where = 1 . . . 3 indexes the stages and where we start with x (1) being the input image. The key operation on which we focus is the convolution, which expands towhere o indexes the output channels C ( out and c indexes the input channels C ( in . The pixel is identified by the tuple (j, i) and S k denotes the support of the filters. In recently published networks [20], [21], [3], the pooling operation determines the maximum in a small neighborhood for each channel, often on 2 × 2 areas and with a stride of 2 × 2. x = pool max,2×2 (v):The activation function is applied point-wise for every pixel and every channel. A currently popular choice is the rectified where n out is the number of output channels |C out |, n in is the number of |C in |, h in × w in is the size of the image and h k ×w k is the size of the filter in spatial domain. The factor of two is because the multiplications and additions are counted as separate operations in this measure, which is the most common in neural network literature [24], [25], [26], [27].However, this way of measuring complexity still does not allow to perfectly determine how a network performs on different platforms. Accelerators might need to be initialized or have to suspend computation to load new filter values, often performing better for some artificially large or small problems. For this reason we distinguish between the throughput obtained with a real network (actual throughput or just throughput), measurements obtained with a synthetic benchmark optimized to squeeze out the largest possible value (peak throughput), and the maximum throughput of the computation units without caring for bandwidth limits often stated in the device specifi- cations of non-specialized processors (theoretical throughput). Software and hardware implementations alike often come with a throughput dependent on the actual size of the convo- lutional layer. While we make sure our chip can run a large range of ConvNets efficiently, we use the one presented in [27] as a reference for performance evaluation. It has three stages and we assume input images of size 240 × 320. The resulting sizes and complexities of the individual layers are summarized in Table I and use a filter of size 7 × 7 for all of them. The total number of operations required is 7.57 GOp/frame. To give an idea of the complexity of more well-known ConvNets, we have listed some of them in Table II. If we take an existing system like the NeuFlow SoC [25] which is able to operate at 490 GOp/s/W, we can see that very high quality, dense optical flow on 384 × 512 video can be computed with 25 frame/s at a power of just around 3.5 W if we could scale up the architecture. We can also see that an optimized implementation on a high-end GPU can run at around 27 frame/s. Because convolutional networks can be evaluated signifi- cantly faster than traditional approaches of comparable ac- curacy (e.g. graphical models), they are approaching an area where real-time applications become feasible on workstations with one, or more often, several GPUs. However, most ap- plication areas require a complete solution to fit within the power envelope of an embedded systems or even a mobile device. Taking the aforementioned scene labeling ConvNet as an examples, its usage in a real-time setting at 25 frame/s amounts to 189 GOp/s, which is out of the scope of even the most recent commercially available mobile processors [27].For a subject area changing as rapidly as deep learning, the long-term usability is an important objective when thinking about hardware acceleration of the building blocks of such systems. While the structure of the networks is changing from application to application and from year to year, and better activation and pooling operations are continuously being published, there is a commonality between all these ConvNets: the convolutional layer. It has been around since the early 90s and has not changed since [9], [4], [3]. Fortunately, this key element is also the computation-intensive part for well- optimized software implementations (approx. 89% of the total computation time on the CPU, or 79% on the GPU) as shown in Figure 1. The time for activation and pooling is negligible as well as the computation time for the pixel-wise classification with fully-connected layers.III. PREVIOUS WORK Convolutional Networks have been achieving amazing re- sults lately, even outperforming humans in image recognition on large and complex datasets such as Imagenet. The top performers have achieved a top-5 error rate (actual class in top 5 proposals predicted by the network) of only 6.67% (GoogLeNet [3]) and 7.32% (VGG Oxfordnet [28]) at the ILSVRC 2014 competition [29]. The best performance of a single human so far is 5.1% on this dataset and has been exceeded since the last large image recognition competition [30]. Also in other subjects such as face recognition [8], ConvNets are exceeding human performance. We have listed the required number of operations to evaluate some of these networks in Table II. In the remainder of this section, we will focus on existing implementations to evaluate such ConvNets. We compare soft- ware implementations running on desktop workstations with CPUs and GPUs, but also DSP-based works to existing FPGA and ASIC implementations. In Section III-D we discuss why many such accelerators are not suitable to evaluate networks of this size and conclude the investigation into previous work by discussing the limitation of existing hardware architectures in Section III-E.Acceleration of convolutional neural networks has been discussed in many papers. There are very fast and user-friendly frameworks publicly available such as Torch [31], Caffe [32], Nvidia's cuDNN [33] and Nervana Systems' neon [34], and GPU-accelerated training and evaluation are the commonly way of working with ConvNets.These and other optimized implementations can be used to obtain a performance and power efficiency baseline on desktop workstations and CUDA-compatible embedded pro- cessors, such as the Tegra K1. On a GTX780 desktop GPU, the performance can reach up to 3059 GOp/s for some special problems and about 1800 GOp/s on meaningful ConvNets. On the Tegra K1 up to 96 GOp/s can be achieved, with 76 GOp/s being achieved with an actual ConvNet. On both platforms an energy-efficiency of about 7 GOp/s/W considering the power of the entire platform and 14.4 GOp/s/W with differential power measurements can be obtained [27]. Except for this evaluation the focus is usually on training speed, where multiple images are processed together in batches to attain higher performance (e.g. using the loaded filter values for multiple images). Batch processing is not suitable for real-time applications, since it introduces a delay of many frames.A comparison of the throughput of many optimized soft- ware implementations for GPUs based on several well-known ConvNets is provided in [35]. The list is lead by an im- plementation by Nervana Systems of which details on how it works are not known publicly. They confirm that it is based on maxDNN [36], which started from an optimized matrix-matrix multiplication, adapted for convolutional layers and with fine-tuned assembly code. Their implementation is tightly followed by Nvidia's cuDNN library [33]. The edge of these two implementations over others originates from using half-precision floating point representations instead of single- precision for storage in memory, thus reducing the required memory bandwidth, which is the currently limiting factor. New GPU-based platforms such as the Nvidia Tegra X1 are now supporting half-precision computation [37], which can be used to save power or provide further speedup, but no thorough investigations have been published on this. More computer vision silicon has been presented recently with the Movidius Myriad 2 device [16] which has been used in Google Tango, and the Mobileye EyeQ3 platform, but no benchmarking results regarding ConvNets are available yet.A different approach to increase throughput is through the use of the Fourier transform, diagonalizing the convolution operation. While this has a positive effect for kernels larger than 9 × 9, the bandwidth problem generally becomes much worse and the already considerable memory requirements are boosted further, since the filters have to be padded to the input image size [38], [27].However optimized the software running on such platforms, it will always be constrained by the underlying architecture: the arithmetic precision cannot be adapted to the needs of the computation, caches are used instead of optimized on- chip buffers, instructions have to be loaded and decoded. This pushes the need for specialized architectures to achieve high power-and area-efficiency. a Spartan 3A DSP 3400 FPGA using 18 bit fixed-point arithmetic for the multiplications. Its architecture was designed to be self-contained, allowing it to execute the operations for all common ConvNet layers, and coming with a soft CPU to control the overall program flow. It also features a compiler, converting network implementations with Torch directly to CNP instructions.The CNPs architecture does not allow easy scaling of its performance, prompting the follow-up work NeuFlow which uses multiple CNP convolution engines, an interconnect, and a smart DMA controller. The data flow between the processing tiles can be be rerouted at runtime. The work published in 2011 features a Virtex 6 VLX240T to achieve 147 GOp/s at 11 W using 16 bit fixed-point arithmetic.To make use of the newly available platform ICs, NeuFlow was ported to a Zynq XC7Z045 in 2014, further improved by making use of the hard-wired ARM cores, and renamed to nn- X. It further increases the throughput to about 200 GOp/s at 4 W (FPGA, memory and host) and uses 4 × 950 MB/s full- duplex memory interfaces.Only few alternatives to CNP/NeuFlow/nn-X exist. The two most relevant are a ConvNet accelerator based on Microsoft's Catapult platform in [41] with very little known details and a HLS-based implementation [42] with a performance and energy efficiency inferior to nn-X.Embeddability and energy-efficiency is a major concern re- garding commercialization of ConvNet-based computer vision systems and has hence prompted many researchers to approach this issue using FPGA implementations. Arguably the most popular architecture is the one which started as CNP [39] and was further improved and renamed to NeuFlow [24], [25] and later on to nn-X [40].Published in 2009, CNP was the first ConvNet specific FPGA implementation and achieved 12 GOp/s at 15 W onThe NeuFlow architecture was implemented as an ASIC in 2012 on 12.5 mm 2 of silicon for the IBM 45nm SOI process. The results based on post-layout simulations were published in [25], featuring a performance of about 300 GOp/s at 0.6 W operating at 400 MHz with an external memory bandwidth of 4 × 1.6 GB/s full-duplex.To explore the possibilities in terms of energy efficiency, a convolution accelerator suitable for small ConvNets was im- plemented in ST 28nm FDSOI technology [43]. They achieve 37 GOp/s with 206 GOp/s/W at 0.8 V and 1.39 GOp/s with 1375 GOp/s/W at 0.4 V during simulation (pre-silicon) with the same implementation, using aggressive voltage scaling combined with reverse body biasing available with FDSOI technology.Further interesting aspects are highlighted in ShiDian- Nao [44], [45], which evolved from DianNao [26]. The original DianNao was tailored to fully-connected layers, but was also able to evaluate convolutional layers. However, its buffering strategy was not making use of the 2D structure of the com- putational problem at hand. This was improved in ShiDianNao. Nevertheless, its performance strongly depends on the size of the convolutional layer to be computed, only unfolding its performance for tiny feature maps and networks. They achieve a peak performance of 128 GOp/s with 320 mW on a core-only area of 1.3mm 2 in a TSMC 65 nm post-layout evaluation. Another way to approach the problem at hand is to look at general convolution accelerators, such as the ConvEngine [46] which particularly targets 1D and 2D convolutions common in computer vision applications. It comes with an array of 64 10- bit ALUs and input and output buffers optimized for the task at hand. Based on synthesis results, they achieve a core-only power efficiency of 409 GOp/s/W.In the last few months we have seen a wave of vision DSP IP cores and SoCs becoming commercially available: CEVA- XM4, Synopsys DesignWare EV5x, Cadence Tensilica Vision P5. They are all targeted at general vision applications and not specifically tailored to ConvNets. They are processor-based and use vector engines or many small specialized processing units. Many of the mentioned IP blocks have never been imple- mented in silicon, and their architecture is kept confidential and has not been peer reviewed, making a quantitative comparison impossible. However, as they use instruction-based processing, an energy efficiency gap of 10× or more with respect to specialized ASICs can be expected.Besides the aforementioned efforts, there are many accelera- tors which are targeted at accelerating non-convolutional neural networks. One such accelerator is the K-Brain [47], which was evaluated to achieve an outstanding power efficiency of 1.93 TOp/s/W in 65 nm technology. It comes with 216 KB of SRAM to store the weights and the dataset. For most applications this is by far insufficient (GoogLeNet [3]: 6.8M, VGG-Oxfordnet [28]: 133M parameters) and the presented architectures do not scale to larger networks, requiring exces- sive amounts of on-chip memory [47], [48], [49], [50]. Other neural network accelerators are targeted at more experimental concepts like spiking neural networks, where thorough perfor- mance evaluations are still missing [51]. been done on the required word width [52], [53], [54] and compression [55], but validated only on very small datasets (MNIST, CIFAR-10).Recent work on hardware accelerators for ConvNets shows that highly energy-efficient implementations are feasible, sig- nificantly improving over software implementations.However, existing architectures are not scalable to higher performance applications as a consequence of their need for a very wide memory interface. This manifests itself with the 299 I/O pins required to achieve 320 GOp/s using Neu- Flow [25]. For many interesting applications, much higher throughput is needed, e.g. scene labeling of full-HD frames requires 5190 GOp/s to process 20 frame/s, and the trend clearly points towards even more complex ConvNets. To underline the need for better options, we want to emphasize that linearly scaling NeuFlow would require almost 5000 I/O pins or 110 GB/s full-duplex memory bandwidth. This issue is currently common to all related work, as long as the target application is not limited to tiny networks which allow caching of the entire data to be processed.This work particularly focuses on this issue, reducing the memory bandwidth required to achieve a high computational throughput without using very large on-chip memories to store the filters and intermediate results. For state-of-the-art networks storing the learned parameters on-chip is not feasible with GoogLeNet requiring 6.8 M and VGG Oxfordnet 135 M parameters. The aforementioned scene labeling ConvNet re- quired 872 k parameters, of which 855 k parameters are filter weights for the convolutional layers. Some experiments haveIn this section we first present the concept of operation of our architecture in a simple configuration. We then explain some changes which make it more suitable for an area- efficient implementation. We proceed by looking into possible inefficiencies when processing ConvNet data. We conclude this section by presenting a system architecture suitable to embed Origami in a SoC or a FPGA-based system.A top-level diagram of the architecture is shown in Figure 3. It shows two different clock areas which are explained later on. The concept of operation for this architecture first assumes a single clock for the entire circuit for simplicity. In Figure 4 we show a timeline with the input and output utilization. Note that the utilization of internal blocks corresponds to these utilizations in a very direct way up to a short delay.The input data (image with many channels) are fed in stripes of configurable height into the circuit and stored in a SRAM, which keeps a spatial window of the input image data. The data is the loaded into the image bank, where a smaller window of the size of the filter kernel is kept in registers and moved down on the image stripe before jumping to the next column. This register-based memory provides the input for the sum-of-product (SoP) units, where the inner products of the individual filter kernels are computed. Each SoP unit is fed the same image channel, but different filters, such that each SoP computes the partial sum for a different output channel. The circuit iterates over the channels of the input image while the partial sums are accumulated in the channel summer (ChSum)   unit to compute the complete result, which is then transmitted out of the circuit. For our architecture we tile the convolutional layer into blocks with a fixed number of input and output channels n ch . We perform 2n 2 ch h k w k operations every n ch clock cycles, while transmitting and receiving n ch values instead of n 2 ch . This is different from all previous work, and improves the throughput per bandwidth by a factor of n ch . The architecture can also be formulated for non-equal block size for the input and output channels, but there is no advantage doing so, thus we keep this constraint for simplicity of notation. We proceed by presenting the individual blocks of the architecture in more detail.1) Image Window SRAM and Image Bank: The image window SRAM and the image bank are in charge of storing new received image data and providing the SoP units with the image patch required for every computation cycle. To minimize size, we want to keep the image bank as small as possible, while not requiring an excessive data rate from the SRAM. The size of the image bank was chosen as n ch h k w k . In every cycle a new row of w k of the current input channel elements is loaded from the image window SRAM and shifted into the image bank. The situation is illustrated in Figure 2 for an individual channel.In order for the SRAM to be able to provide this minimum amount of data, it needs to store a w k element wide window for all n ch channels and have selectable height h in ≤ h (in,max) . A large image has to be fed into the circuit in stripes of maximum height h in,max with an overlap of h k −1 pixels. The overlap is because an evaluation of the kernel will need a surrounding of (h k − 1)/2 pixel in height and (w k /1)/2 pixel in width. When the image bank reaches the bottom of the image window stored in SRAM, it jumps back to the top, but shifted one pixel to the right. This introduces a delay of n ch (h k − 1) cycles, during which the rest of the circuit is idling. This delay is not only due to the loading of the new values for the image bank, but also to receive the new pixels for the image window SRAM through the external I/O. Choosing h (in,max) is thus mostly a trade- off between throughput and area. The performance penalty on the overall circuit is about a factor of (h k − 1)/h (in,max) . The same behavior can be observed at the beginning of the horizontal stripe. During the first n ch h in (w k − 1) cycles the processing units are idling.2) Filter Bank: The filter bank stores all the weights of the filters, these are n ch n ch h k w k values. In configuration mode the filter values are shifted into these registers which are clocked with at the lower frequency f . In normal operation, the entire filter bank is read-only. In each cycle all the filter values supplied to the SoP have to be changed, this means that n ch h k w k filter values are read per cycle. Because so many filters have to be read in parallel and they change so frequently, it is not possible to keep them in a SRAM. Instead, it is implemented with registers and a multiplexer capable of multiplexing selecting one of n ch sets of n ch h k w k weights.The size of the filter bank depends quadratically on the number of channels processed, which results in a trade-off between area and I/O bandwidth efficiency. When doubling the I/O efficiency (doubling n ch , doubling I/O bandwidth, quadrupling the number of operations per data word), the storage requirements for the filter bank are quadrupled.Global memory structures which have to provide lots of data at a high speed are often problematic during back end design. It is thus important to highlight that while this filter bank can be seen as such a global memory structure, but is actually local: Each SoP unit only needs to access the filters of the output channel it processes, and no other SoP unit accesses these filters.3) Sum-of-Products Units: A SoP unit calculates the inner product between an image patch and a filter kernel. It is built from h k w k multipliers and h k w k − 1 adders arranged in a tree. Mathematically the output of a SoP unit is described as . While previous steps have only loaded and stored data, we here perform a lot of arithmetic operations, which raises the question of numerical precision. A fixed-point analysis to select the word-width is shown in Section V-B. In terms of architecture, the word width v is doubled by the multiplier, and the adder tree further adds log 2 (h k w k ) bits. We truncate the result to the original word width with the same underlying fixed-point representation. This truncation also reduces the accuracy with which the adder tree and the multipliers have to be implemented. The idea of using the same fixed-point representation for the input and output is motivated by the fact that there are multiple convolutional layers and each output will also serve again as an input. 4) Channel Summer Units: Each ChSum unit sums up the inner products it receives from the SoP unit it is connected to, reducing the amount of data to be transmitted out of the circuit by a factor of 1/n ch over the naive way of transmitting the individual convolution results. The SoP units are built to be able to perform this accumulation while still storing the old total results, which are one-by-one transmitted out of the circuit while the next computations are already running. The ChSum units also perform their calculations at full precision and the results are truncated to the original fixed-point format.the input image or takes a step forward. This makes each SoP unit responsible for two output channels. While there is little change to the image bank, the values taken from the filter bank have to be switched at the faster frequency as well. Additionally, the ChSum units have to be adapted to alternatingly accumulate the inner products of the two different output channels.The changes induced to the filter bank reduce the number of filter values to be read to n ch h k w k /2 per cycle, however at twice the clock rate. The adapter filter bank has to be able to read one of 2n ch sets of n ch h k w k /2 weights each at f f ast = 2f .The peak throughput of this architecture is given byTo achieve a high area efficiency, it is essential that large logic blocks are operated at a high frequency. We can pipeline the multipliers and the adder tree inside the SoP units to achieve the desired clock frequency. The streaming nature of the overall architecture makes it very simple to vary this with- out drawbacks as encountered with closed-loop architectures.The limiting factor for the overall clock frequency is the SRAM keeping the image window, which comes with a fixed delay and a minimum clock period, and the speed of CMOS I/O pads. Because the SRAM's maximum frequency is much lower than the one of the computation-density-and power- optimized SoP units, we have chosen to have them running at twice the frequency. This way each unit calculates two inner products until the image bank changes the channel of operations per second. Looking at the SoP units, they can each calculate w k × h k multiplications and additions per cycle. As mentioned before, the clock is running at twice the speed (f f ast = 2f ) to maximize area efficiency by using only n SoP = n ch /2 SoP units. All the other blocks of the circuit are designed to be able to sustain this maximum throughput. Nevertheless, several aspects may cause these core operation units to stall. We discuss the aspects in the following paragraphs.1) Border Effects: At the borders of an image no valid convolution results can be calculated, so the core has to wait for the necessary data to be transferred to the device. These waiting periods occur at the beginning of a new image while w k − 1 columns are preloaded, and at the beginning of each new column while h k − 1 pixels are loaded in n ch (h k − 1) cycles. The effective throughput thus depends on the size of the image:The maximum h in is limited to some h in,max depending on the size of the image window SRAM. It is feasible to choose h in large enough to process reasonably sized image, otherwise the image has to be tiled into multiple smaller horizontal stripes with an overlap of h k − 1 rows with the corresponding additional efficiency loss.Assuming h in,max is large enough and considering our reference network, this factor is 0.96, 0.91 and 0.82 for stages 1, . . . , 3, respectively in case of a 240 × 320 pixel input image. For larger images this is significantly improved, e.g. for a 480 × 640 image the Stage 3 will get an efficiency factor of 0.91. However, the height of the input image is limited to 512 pixel due to the memory size of the image bank.2) Filter Loading: Before the image transmission can start, the filters have to be loaded through the same bus used to transmit the image data. This causes a loss of a few more cycles. Instead of just the n ch h in w in input data values, an additional n  If we choose nch = 8, this evaluates to 0.99, 0.98 and 0.91 for the three stages.3) Channel Idling: The number of output and input channels usually does not correspond to the number of output and input channels processed in parallel by this core. The output and input channels are partitionned into blocks of n ch × n ch and filling in all-zero filters for the unused cases. The outputs of these blocks then have to be summed up pixel-wise off-chip.This processing in blocks can have a strong additional impact on the efficiency when not fully utilizing the core. While for the reasonable choice n ch = 8 the stages 2 and 3 of our reference ConvNet can be perfectly split into n ch × n ch blocks and thus no performance is lost, Stage 1 has only 3 input channels and can load the core only with η blocks = 3/8. However, stages with a small number of input and/or output channels generally perform much less operations and efficiency in these cases is thus not that important.The total throughput with the reference ConvNet running on this device with the configuration used for our implementation (cf. Section V) is summarized in Table III, alongside details on the efficiency of the individual stages.When designing the architecture it is important to keep in mind how it can be used in a larger system. This system should be able to take a video stream from a camera, analyze the content of the images using ConvNets (scene labeling, object detection, recognition, tracking), display the result, and transmit alerts or data for further analysis over the network.1) General Architecture: We elaborate one configuration (cf. Fig. 5), based on which we show the advantages of our design. Besides the necessary peripherals and four Origami chips, there is a 32 bit 800 MHz DDR3 or LPDDR3 memory. The FPGA could be a Xilinx Zynq 7010 device 1 . The FPGA has to be configured to include a preprocessing core for rescaling, color space conversion, and local contrastive normalization. To store the data in memory after preprocessing, but also to load and store the data when applying the convolutional layer using the Origami chips and applying the fully-connected layers, there has to be a DMA controller and a memory controller.The remaining steps of the ConvNet like summing over the partial results returned by the Origami chips, adding the bias, and applying the ReLU non-linearity and max-pooling have to be done on the FPGA, but requires very little resources since no multipliers are required. The only multipliers are required to apply the fully-connected layers following the ConvNet feature extraction, but these do not have to run very fast, since the share of operations in this layer is less than 2% for the scene labeling ConvNet in [27].For every stage of the ConvNet, we just tile the data into blocks of height h in,max , n ch input channels and n ch output channels. We then sum up these blocks over the input channels and reassemble the final image in terms of output channels and horizontal stripes.2) Bandwidth Considerations: In the most naive setup, this means that we need to be able to provide memory accesses for the full I/O bandwidth of every connected Origami chip together. However, we also need to load the previous value of each output pixel because the results are only the partial sums and need to be added for the final result. In any case the ReLU operation and max-pooling can be done in a scan-line proce- dure right after computing the final values of the convolutional layers, requiring only a buffer of ( − 1)h in,max // values for × max-pooling since the max operation can be applied in vertical and horizontal direction independently (one direction can be done locally).However, this is far from optimal and we can improve using the same concept as in the Origami chip itself. We can arrange the Origami chips such that they calculate the result of a larger tile of input and output channels, making chips 1&amp;2 and 3&amp;4 share the same input data and chips 1&amp;3 and 2&amp;4 generate output data which can immediately be summed up before writing it to memory. Analogous to the same principle applied on-chip, this saves a factor of two for read and write access to the memory. Of course, the same limitations as explained in the previous section also apply at the system level.The pixel-wise fully-connected layers can be computed in a single pass, requiring the entire image to be only loaded once. For the scene labeling ConvNet we require 256 · 64 + 64 · 8 ≈ 17k parameters, which can readily be stored within the FPGA alongside 64 intermediate values during the computations.This system can also be integrated into a SoC for reduced system size and lower cost as well as improved energy effi- ciency. This makes the low memory bandwidth requirement the most important aspect of the system, being able to run with a narrow and moderate-bandwidth memory interface translates to lower cost in terms of packaging, and significantly higher energy efficiency (cf. Section VII-C for a more detailed discussion of this on a per-chip basis).We first present the general implementation of the circuit. Thereafter, we present the results of a fixed-point analyses to determine the number format. We finalize this section by summarizing the implementation figures and by taking a look at implementation aspects of the entire system. Classification accuracy with filter coefficients stored with 12 bit precision. The single precision implementation achieves an accuracy of 70.3%. Choosing an input length of 12 bit results in an accuracy loss of less than 0.5%.As discussed in Section IV, we operate our design with two clocks originating from the same source, where one is running at twice the frequency of the other. The slower clock f = 250 MHz is driving the I/O and the SRAM, but also other elements which do not need to run very fast, such as the image and filter bank. The SoP units and channel summers are doing most of the computation and run at f f ast = 2f = 500 MHz to achieve a high area efficiency. To achieve this frequency, the multipliers and the subsequent adder tree are pipelined. We have added two pipeline stages for each, the multipliers and the adder tree.For the taped-out chip we set the filter size h k = w k = 7, since we found 7 × 7 and 5 × 5 to be the most common filter sizes and a device capable of computing larger filter sizes is also capable to calculate smaller ones. For the maximum height of a horizontal image stripe we chose h in,max = 512, requiring an image window SRAM size of 29k words. Due to its size and latency, we have split it into four blocks of 1024 words each with a word width of 7 · 12, as can be seen in the floorplan (Figure 10). The alignment shown has resulted in the best performance of various configurations we have tried. Two of the RAM macro cells are placed besides each other on the left and the right boundary of the chip, with two of the cells flipped such that the ports face towards the center of the device. For silicon testing, we have included a built-in self-test for the memory blocks.The pads of the input data bus were placed at the top of the chip around the image bank memory, in which it is stored after one pipeline stage. The output data bus is located at the bottom-left together with an in-phase clock output and the test interface at the bottom-right of the die. The control and clock pads can be found around the center of the right side. Two Vdd and GND core pads were placed at the center of the left and right side each, and one Vdd and GND core pad was placed at the top and bottom of the chip. A pair of Vdd and GND pads for I/O power was placed close to each corner of the chip.The core clock of 500 MHz is above the capabilities of standard CMOS pads and on-chip clock generation is unsuit- able for such a small chip, while also complicating testing. To overcome this, two phase-shifted clocks of 250 MHz are fed into the circuit. One of the clock directly drives the clock tree of the slower clock domain inside the chip. This clock is also XOR-ed with the second input clock signal to generate the faster 500 MHz clock.Previous work is not conclusive on the required precision for ConvNets, 16 and 18 bit are the most common values [39], [24], [40], [43]. To determine the optimal data width for our design, we performed a fixed-point analysis based on our reference ConvNet. We replaced all the convolution operations in our software model with fixed-point versions thereof and evaluated the resulting precision depending on the input, output and weight data width. The quality was analyzed based on the per-pixel classification accuracy of 150 test images omitted during training. We used the other 565 images of the Stanford backgrounds dataset [56] to train the network.Our results have shown that an output length of 12 bit is sufficient to keep the implementation loss below a drop of 0.5% in accuracy. Since the convolution layers are applied repeatedly with little processing between them, we chose the same signal width for the input, although we could have reduced them further. For the filter weights a signal width of 12 bit was selected as well.For the implementation, we fixed the filter size h k = w k = 7 and chose n c h = 8. Smaller filters have to be zero-padded and larger filters have to be decomposed into multiple 7 × 7 filters and added up. To keep the cycles lost during column changes low also for larger image, we chose h (in,max) = 512. For the SRAM, the technology libraries we used did not provide a fast enough module to accommodate 8 · 512 words of 7 · 12 bit at 250 MHz. Therefore, the SRAM was split into 4 modules of 1024 words each.  The four Origami chips require 750 MB/s FD for the given implementation(12 bit word length, n ch = 8 input and output channels, 250 MHz) using the input and output feature map sharing discussed in Section IV-D to save a factor of 2. The inputs and outputs are read directly from and again written directly to memory. Since the chips output partial sums, these have to be read again from memory and added up for the final convolution result. This can be combined with activation and pooling, adding slightly less than 750 MB/s read and 187.5 MB/s (for 2×2 pooling) write memory bandwidth. For the third stage in the scene labeling ConvNet there is no such pooling layer, instead there is the subsequent pixel- wise classification which can be applied directly and which reduces the feature maps from 256 to 8, yielding an even lower memory write throughput requirement. To sum up, we require 2.45 GB/s memory bandwidth during processing. To achieve the maximum performance, we have to load the filters at full speed for all four chip independently at the beginning of each processing burst, requiring a memory bandwidth of 1.5 GB/s -less than during computation. This leaves enough bandwidth available for some pre-and post-processing and memory access overhead. In the given configuration, 320×240 frames can be processed at over 75 frame/s or at an accordingly higher resolution.is shared between the image window SRAM, the image bank (0.05 mm 2 registers and 7614µm 2 logic), and other circuitry (I/O registers, data output bus mux, control logic; 0.1 mm 2 ). The chip area is clearly dominated by logic and is thus suited to benefit from voltage and technology scaling.We have used Synopsys Design Compiler 2013.12 for syn- thesis and Cadence SoC Encounter 13.14 for back-end design. Synthesis and back-end design have been performed for a clock frequency of f = 350 MHz with typical case corners for the functional setup view and best case corners for the functional hold view. Clock trees have been synthesized for the fast and the slow clock with a maximum delay of 240 ps and a maximum skew of 50 ps. For scan testing, a different view with looser constraints was used. Reset and scan enable signals have also been inserted as clock trees with relaxed constraints. Clock gating was not used. We performed a post-layout power estimation based on switching activity information from a simulation running parts of the scene labeling ConvNet. The total core power was estimated to be 620.8 mW, of which 35.5 mW are used in the f f ast and 41.7 mW are used in the lower frequency clock tree. Each SoP unit uses 66.9 mW, the filter bank 122.5 mW, the image bank 18.3 mW, and the image window SRAM 43.6 mW. The remaining power was used to power buffers connecting these blocks, I/O buffers and control logic. The entire core has only one power domain with a nominal voltage of 1.2 V and the pad frame uses 1.8 V. The power used for the pads is 205 mW with line termination (50Ω towards 0.9 V).2) Silicon Measurements: The ASIC has been named Origami and has been taped-out in UMC 65nm CMOS technology. The key measurement results of the ASIC have been compiled in Table IV. In the high-speed configuration we can apply a 500 MHz clock to the core, achieving a peak throughput of 196 GOp/s. Running the scene labeling ConvNet from [27], we achieve an actual throughput of 145 GOp/s while the core (logic and on-chip memory) consumes 448 mW. This amounts to a power efficiency of 437 GOp/s/W, measured with respect to the peak throughput for comparability to related work. The I/O data interface consist of one input and one output 12 bit data bus running at half of the core frequency, providing a peak bandwidth of 375 MB/s full-duplex. We achieve a very high throughput density of 63.4 GOp/s/mm 2 We have analyzed and measured multiple metrics in our architecture: I/O bandwidth, throughput per area and power efficiency. We can run our chip at two operating points: a high- speed configuration with V dd = 1.2 V and a high-efficiency configuration with V dd = 0.8 V. We have taped out this chip and the results below are actual silicon measurement results (cf . Table IV), as opposed to post-layout results which are known to be quite inaccurate. We now proceed by presenting implementation results and silicon measurements.1) Implementation: We show the resulting final area break- down in Figure 7. The filter bank accounts for more than a third of the area and consists of registers storing the filter weights (0.41 mm 2 ) and the multiplexers switching between them (0.03 mm 2 ). The SoP units take up almost another third of the circuit and consist mostly of logic (98188 µm 2 /unit) and some pipeline registers (26615 µm 2 /unit). The rest of the space despite the generously chosen core area of 3.09 mm 2 (to accommodate a large enough pad frame for all 55 pins), while the logic and on-chip memory occupy a total area of just 1.31 mm 2 , which would correspond to a throughput density of 150 GOp/s/mm 2 . When operating our chip in the high-efficiency configu- ration, the maximum clock speed without inducing any er- rors is 189 MHz. The throughput is scaled accordingly to 74 GOp/s for the peak performance and 55 GOp/s running our reference ConvNet. The core's power consumption is reduced dramatically to only 93 mW, yielding a power-efficiency of 803 GOp/s/W. The required I/O bandwidth shrinks to 142 MB/s full-duplex or 1.92 MB/GOp. The throughput density amount to 23.9 GOp/s/mm 2 for this configuration. The chip was orig- inally targeted at the 1.2 V operating point and has hold violations operating at 0.8 V at room temperature. Thus the VII. DISCUSSION None of the previous work on ConvNet accelerators has silicon measurement results. We will thus compare to post- layout and post-synthesis results of state-of-the-art related works, although such simulation results are known to be optimistic. We have listed the key figures of all these works in Table V and discuss the various results in the sections below.Our chip is the most area-efficient ConvNet accelerator reported in literature. We measure the area in terms of 2- input NAND gate equivalents to compensate for technology differences to some extent. With 90.7 GOp/s/MGE our imple- mentation is by far the most area-efficient, and even in high power-efficiency configuration we outperform previous state- of-the-art results. The next best implementation is a NeuFlow design at 33.8 GOp/s/MGE, requiring a factor 3 more space for the same performance. ShiDianNao is of comparable area- efficiency with 26.3 GOp/s/MGE. Also note that the chip size was limited by the pad-frame, and that the area occupied by the standard cells and the on-chip SRAM is only 1.31 mm Besides the two mentioned operating points there are many more, allowing for a continuous trade-off between throughput and energy efficiency by changing the core supply voltage as evaluated empirically in Figure 9. As expected the figures are slightly worse for the measurements at higher temperature. Static power dissipation takes a share around 1.25% across the entire voltage range at 25°C and a share of about 10.5% (0.91 MGE). We would thus achieve a throughput density of an enormous 215 GOp/s/MGE in this very optimistic scenario. This would require a more complex and expensive pad-frame architecture, e.g. flip-chip with multiple rows of pads, which we decided not to implement.We see the reason for these good results in our approach to compute multiple input and output channels in parallel. This way we have to buffer a window of 8 input channels to compute 64 convolutions, instead of buffering 64 input images, a significant saving of storage, particularly also because the window size of the input images that has to be buffered is a lot larger than the size of a single convolution kernel. Another 25% can be attributed to the use of 12 bit instead of 16 bit words which expresses itself mostly with the size of the SRAM and the filter kernel buffer. Our chip performs second-best in terms of energy efficiency of the core with 803 GOp/s/W (high-efficiency configuration) and 437 GOp/s (high-performance configuration), being out- performed only by the HWCE. The HWCE can reach up to 1375 GOp/s/W in its high-efficiency setup when runningThe projected results are shown in Table VI. To obtain the operating voltage in 28 nm technology, we scale the operating voltage linearly with respect to the common operating voltage of the used technology. This projection, although not based on a very accurate model, gives an idea of how the various implementations perform in a recent technology. Clearly, the only competitive results in terms of core power efficiency are ShiDianNao and this work. Previous work has always excluded I/O power, although it is a major contributor to the overall power usage. We estimate this power based on an energy usage of 21 pJ/bit, which has been reported for a LPDDR3 memory model and the PHY on the chip in 28 nm [57], assuming a reasonable output load and a very high page hit rate. For our chip, this amounts to an additional 63 mW or ous architectures. It is more area efficient than any previously reported results and comes with the lowest-ever reported power consumption when compensating for technology scaling. Further work with newer technologies, programmable logic and further configurability to build an entire high-performance low-power system is planned alongside investigations into the ConvNet learning-phase to adapt networks for very-low precision accelerators during training. Fig. 10. Floorplan and die shot of the final chip. In the floorplan view, the cells are colored by functional unit, making the low density in the sum-of- products computation units clearly visible.24 mW for the high-performance and high-throughput config- uration, respectively. For NeuFlow, due to the much higher I/O bandwidth, it looks worse with an additional 1.08 W for their 320 GOp/s implementation. If we assume the power efficiency of these devices in their original technology, this reduces the power efficiency including I/O to 342 GOp/s/W, 632 GOp/s/W and 191 GOp/s/W for our chip in high-throughput and high- efficiency configuration as well as NeuFlow. If we look at their projected 28 nm efficiency, they are decreased to 1315 GOp/s/W, 2326 GOp/s/W and 243 GOp/s/W. This clearly shows the importance of the reduced I/O bandwidth in our de- sign, and the relevance of I/O power in general with it making up a share of 42% to 82% of the total power consumption for these three devices.We have presented the first silicon measurement results of a convolutional network accelerator. The developed architecture is also first to scale to multi-TOp/s performance by signifi- cantly improving on the external memory bottleneck of previ-
