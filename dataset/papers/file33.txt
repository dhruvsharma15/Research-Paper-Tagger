Estimating a deformation field by gradient descent The second approach, particularly popular in medical imag- ing, consists in estimating a dense deformation field from one image to the other one [1,9,25,15,13]. One of its advantages over the first approach is to be able to model objects, to make use of shape statistics, etc. The warping is modeled as a smooth vector field φ, mapping one image domain onto the other one. Given two images I 1 and I 2 , a criterion C(I 1 • φ, I 2 ) is defined, to express the similarity between the warped image I 1 • φ and the target I 2 , and is optimized with respect to φ by gradient descent. Selecting a suitable similarity criterion C is crucial, as well as de- signing carefully the gradient descent, as we will detail in section 2.Tasks Image registration deals with images either of the same modality (same sensor), or not. When of the same modality, the task is typically to align different but similar objects (e.g., faces [4] or organs of different people [13]), or to align the same object but taken at different times (as in the tumor monitoring example). On the other side, multi-modal registration deals with aligning images usually of the same object but taken with different sensors, which capture different physical properties, at possibly different resolutions. For instance in medical imaging, MR and CT scans capture the density of water and of matter respec- tively, while in remote sensing RGB and hyperspectral data capture information from different light frequencies (infrared, etc.). In our case of study, we will focus on the alignment of RGB remote sensing images with cadastral maps, which are vector-format images with polygonal representations of all buildings and roads, hand-made by local authorities, map makers or OpenStreetMap users, as in Figures 1 and 2.The difficulty to design or pick particular local descriptors or matching criteria among many possibilities is the trait of computer vision problems where the introduction of neu- ral networks can prove useful. The question is how. Ma- chine learning techniques have already been explored to learn similarity measures between different imaging modal- ities [38], for instance using kernel methods to register MR and CT brain scans [16], but without tackling the question of scale. We will aim at designing a system able to learn scale-specific and modality-specific features, and able to perform multimodal image registration densely and swiftly, without the use of any iterative process such as gradient de- scent which hampers classical approaches. Our contribu- tions are thus:.Whether mono-modal or multi-modal, image registra- tion faces two challenges: first, to describe locally image data, and then, to match points with similar description, in a spatially coherent manner. Historically, two main classical approaches have emerged.Matching key-points The first one consists in sampling a few key-points from each image (e.g. with Harris corner detection), in describing them locally (with SIFT, SURF, HOG descriptors...) [29,7], in matching these points [26] and then interpolating to the rest of the image. The ques- • a swift system to register images densely • learning features to register images of different modal- ities • learning scale-specific features and managing scales • designing a (relatively small) neural network to do this in an end-to-end fashion • aligning remote sensing images with cadastral maps (buildings and roads) • providing a long-awaited tool to create large-scale benchmarks in remote sensing.We first analyze the problems related to scale when aligning images, in order to design a suitable neural network archi-tecture. We show results on benchmarks and present addi- tional experiments to show the flexibility of the approach.of the intensity around x 1 and x 2 within a neighborhood of pre-defined size [13]. Another famous example is the mutual information between the histograms of the intensity within a certain window with pre-defined size.In order to analyze issues that arise when aligning images, let us first consider the case of mono-modal registration, for simplicity. Keeping the notations from section 1.2, we pursue the quest for a reasonable criterion C(I 1 • φ, I 2 ) to optimize by gradient descent to estimate the deformation φ.Too local quantities such as the pixellic intensity differenceL 2 would create many local minima and get the gradient descent stuck very fast. In- deed, if as a toy example one considers I 1 and I 2 to be two white images with a unique black dot 1 at different locations x 1 and x 2 respectively, the derivative of C(I 1 • φ, I 2 ) with respect to φ will never involve quantities based on these two points at the same time, which prevents them from being in- fluenced by each other:In all these cases, the neighborhood size is particularly im- portant: if too small, the gradient descent will get stuck in a poor local minimum, while if too large, the image details might be lost, preventing fine registration. What is actually needed is this neighborhood size to be of the same order of magnitude as the displacement to be found. As this dis- placement is unknown, the neighborhood size needs to be wide enough during the first gradient steps (possibly cover- ing the full image), and has to decrease with time, for the registration to be able to get finer and finally reach pixellic precision. Controlling the speed of this decrease is a dif- ficult matter, leading to slow optimization. Moreover, the performance of the descriptors may depend on the scale, and different descriptors might need to be chosen for the coarse initial registration than for the finest final one. In plus of the difficult task of designing [39,36] or learning [16] relevant descriptors L s for each scale, this raises an- other issue, that is that the criterion C s to optimizeis 0 at all points x = x 1 , and at x 1 the deformation φ (ini- tialized to the identity) evolves to make it disappear from the cost C by shrinking the image around. Thus the deriva- tive of the similarity cost C with respect to the deformation φ does not convey any information pushing x 1 towards x 2 , but on the contrary will make the descent gradient stuck in this (very poor) local minimum. Instead of the intensity I(x), one might want to consider other local, higher-level features L(I)(x) such as edge de- tectors, in order to grasp more meaningful information, and thus minimize a criterion for instance of the form: now depends on the current neighborhood size s(t), which is itself time-dependent, and thus the optimized criterion C s(t) might increase when the descriptor L s(t) evolves: the optimization process is then not a gradient descent anymore.One might think of scale-invariant descriptors such as SIFT, however the issue is not just to adapt the scale to a particular location within an image, but to adapt it to the amplitude of the deformation that remains to be done to be matched to the other image.(1)2.4 Multi-resolution viewpointThe solution consists in considering local descriptors in- volving larger spatial neighborhoods, wide enough so that the image domains involved in the computations of L(I 1 • φ)(x 1 ) and L(I 2 )(x 2 ) for two points x 1 and x 2 to be matched overlap significantly. For instance, the computa- tion of the Canny edge detector is performed over a trun- cated Gaussian neighborhood, whose size is pre-defined by the standard deviation parameter σ. Another example is the local-cross correlation, which compares the local variations scales simultaneously by considering a multi-scale parame- terisation of the deformation [28]. However, the same local minimum problem would be encountered if implemented naively; heuristics then need to be used to estimate at which scale the optimization has currently to be performed locally.knowledge no neural network-based work for dense non- rigid alignment yet. In [24], the Siamese network idea is used, but for matching only very few points. It is also worth noting that, much earlier, in [16], a similarity crite- rion between different modalities was learned, with a kernel method, but for rigid registration only.Deformations are usually modeled as diffeomorphisms [1,9,15,13], i.e. smooth one-to-one vector fields, in order to avoid deleting image parts. The smoothness is controlled by an additional criterion to optimize, quantifying the reg- ularity of the deformation φ, such as its Sobolev norm (pe- nalizing fast variations). As in any machine learning tech- nique, this regularity term sets a prior over the space of pos- sible functions (here, deformations), preventing overfitting (here, spatial noise). But once again, the smoothness level required should depend on the scale, e.g. prioritizing global translations and rotations at first, while allowing very local moves when converging. This can be handled by suitable metrics on instantaneous deformations [5,31]; yet in prac- tice these metrics tend to slow down convergence by over- smoothing gradients ∇ φ C at finest scales.As seen in the previous sections, aligning images thanks to a gradient descent over the deformation φ has the fol- lowing drawbacks: it is slow because of the need to ensure convergence at each scale, it is actually not a real gradient descent if descriptors are scale-dependent, and it induces a long backpropagation chain when learning the descriptors.To get rid of this iterative process, we propose to predict di- rectly its final result at convergence. That is, given images I 1 and I 2 , to predict directly the optimal deformation φ so that I 1 •φ and I 2 are aligned. Also, instead of proceeding in two steps: first learning the features L required to define the criterion C in (1), then finding the deformation φ minimiz- ing C, we propose to directly learn the deformation as in a standard machine learning setup, that is, from examples. Given a training dataset of input pairs P = (I 1 , I 2 ) together with the expected associated output φ P , we aim at learning the function P → φ P .As neural networks have proved useful to replace hand- designed features for various tasks in the literature recently, and convolutional ones (CNN) in particular in computer vi- sion, one could think, for mono-modal image alignment, of training a CNN in the Siamese network setup [3,6], in or- der to learn a relevant distance between image patches. The multi-modal version of this would consist in training two CNN (one per modality) with same output size, in comput- ing the Euclidean norm of the difference of their outputs as a dissimilarity measure, and in using that quantity within a standard non-rigid alignment algorithm, such as a gradient descent over (1). For training, this would however require to be able to differentiate the result of this iterative align- ment process with respect to the features. This is not real- istic, given the varying, usually large number of steps re- quired for typical alignment tasks. A similar approach was nonetheless successfully used in [17], for the simpler task of correcting blurry segmentation maps, sharpening them and relying on image edges. For this, a partial differen- tial equation (PDE) was mimicked with a recurrent network, and the number of steps applying this PDE was pre-defined to a small value (5), sufficient for that particular problem. In the same spirit, for image denoising, in [21,34] the prox- imal operator used during an iterative optimization process is modeled by a neural network and learned. There is to ourTraining set We first consider the task of aligning geolo- calized aerial RGB images with binary maps from Open- StreetMap indicating building locations. As explained in section 1.1, the matching is usually imperfect. Creating the deformation ground truth by manually performing the warpings would be too time-consuming. Instead, we ex- tract image pairs which visually look already well aligned, as in Figure 2. This way we obtain a dataset composed of 5000x5000 image pairs (aerial RGB image, binary vector- format building map) at resolution 0.3m/pixel, for which the deformation φ to be found is the identity. We generate an artificial training set by applying random deformations to the cadastral vectorial maps, moving ac- cordingly the corners of the polygons it contains, and then generating the new binary maps by rasterization. We thus obtain a training set of pairs of non-registered images, with known deformations. As typical deformations in reality are smooth, we model our family of random deformations as: a global translation v 0 taken uniformly within a certain range [−r, +r] 2 , plus a mixture of Gaussian functions with ran- dom shifts v i , centers x i and covariance matrices S i :two features, i.e. emits two real values per pixel, which are interpreted as φ(x). In our experiments, such a network does not succeed in learning deformations: it constantly outputs φ(x) = (0, 0) ∀x, which is the best constant value for our loss, i.e. the best answer one can make when not understanding the link between the input (I 1 , I 2 ) and the output φ for a quadratic loss: the average expected answer , which is (0, 0) in our case.We also tried changing representation by predicting bin probabilities pwith uniformly random v i , S i , x i within suitable pre- defined ranges (S i being symmetric positive definite). This way, we can drastically augment the dataset by applying arbitrarily many random deformations to the initially well- aligned images.Optimization criterion The loss considered is simply the Euclidean norm of the prediction error:The task in section 3.4 is indeed too hard: the network needs to develop local descriptors at all scales to capture all in- formation, and is asked to perform a fine matching with (2r) 2 1700 possibilities for each pixel x. This task can be drastically simplified though, by requir- ing the network to perform the alignment at one scale s only. By this, we mean:i.e. the expectation, over the ground truth dataset D of triplet examples (RGB image I 1 , cadastral image I 2 , associated deformation φ GT ), of the sum, over all pixels x in the im- age domain Ω(I 2 ), of the norm of the difference between the ground truth deformation φ GT (x) and the one predicted Task at scale s: Solve the alignment problem for the im- age pair (I 1 , I 2 ), with a precision required of ±2 s pixels, under the assumption that the amplitude of the registra- tion to be found is not larger than 2 s+1 pixels. φ (w)(I1,I2) (x) for the pair of images (I 1 , I 2 ) given model parameters w (i.e. the neural network weights).In order to make sure that predictions are smooth, we also consider for each pixel a penalty over the norm of the (spatial) Laplacian of the deformation φ:which penalizes all but affine warpings. In practice in the discrete setting this sum is the deviation of φ(x) from the average over the 4 neighboring pixels:We first produce a training set typical of real deformations by picking a realistic range r = ±20 pixels of deforma- tion amplitudes. We consider a fully-convolutional neural network, consisting of two convolutional networks (one for each input image I i ), whose final outputs are concatenated and sent to more convolutional layers. The last layer hasFor instance, at scale s = 0, the task is to search for a pix- elwise precise registration (±1 pixel) on a dataset prepared as previously but with amplitude r = 2 s+1 = 2. As a first approximate test, we train the same network as described earlier, with r = 2, i.e. each of the 2 coordinates of φ(x) take value in [−2, 2], and we consider a prediction φ(x) to be correct if in the same unit-sized bin as φ(x). Without tuning the architecture or the optimization method, we ob- tain, from the first training run, about 90% of accuracy, to be compared to ∼ 6% for a random guess.Thus, it is feasible, and easy, to extract information when specifying the scale. Intuitively, the search space is much smaller; in the light of section 2.2, the descriptor recep- tive field required for such a ±1 pixel task is just of ra- dius 1. And indeed, in the classical framework for mono- modal registration, a feature as simple as the image intensity would define a sufficiently good criterion (1), as the associ- ated gradient step involves the comparison to the next pixel (through ∇ x I 1 ). Note that such a simple intensity-based criterion would not be expected to perform more, e.g. find deformations of amplitude r 2 pixels in the general case (textures).Designing a suitable neural network architecture We now propose better architectures to solve that alignment task at scale s = 0. We need a fully-convolutional archi- tecture since the output is a 2-channel image of the same size as the input, and we need to go across several scales in order to understand which kind of object part each pixel belongs to, in each modality. High-level features require a wide receptive field, and are usually obtained after sev- eral pooling layers, in a pyramidally shaped network. The output needs however to be of the same resolution as the input, which leads to autoencoder-like shapes. In order to keep all low-level information until the end, and not to lose precision, we link same-resolution layers together, thus ob- taining a U-net-like network [33] (developed for medical image segmentation). As the 2 input images are not regis- tered, and to get modality-specific features, we build 2 sep- arate convolutional pyramids, one for each modality (in a similar fashion as networks for stereo matching [40]), but concatenate their activities once per scale to feed the U-net. The architecture is summarized in Figure 3. The network is trained successfully to solve the s = 0 task as explained previously. Figure 3. Network architecture. The two input images I1 and I2 are fed to layers 1a and 1b respectively. The output is a 2 dimen- sional vector map (layer 26 with 2 channels). See Appendix for all details.We now solve the general alignment task very simply: the classical multi-resolution approaches with gradient de- scents at each scale.Note also some similarity with recent work on optical flow [14], consisting in an arrangement of 3 different scale-related blocks, though monomodal, not principled from a scale analysis and without scale-specific training.Solution for task at scale s: Downsample the images by a factor 2 s ; solve the alignment task at scale 0 for these reduced images, and upsample the result with the same factor.We will also check the following variations:Full alignment algorithm: Given an image pair (I 1 , I 2 ) of width w, iteratively solve the alignment task at scale s, from s = log 2 w until s = 0.• "fast": replace all scale-specific blocks with the same s = 2-specific block, to see how well features general- ize across scales; the output quality decreases slightly but remains honorable.One can choose to use the same network for all scales, or different ones if we expect specific features at each scale, as in remote sensing or medical imaging.The full processing chain is shown in Figure 4. Note a certain global similarity with ResNet [12], in that we have a chain of consecutive scale-specific blocks, each of which refining the previously-estimated deformation, not by adding to it but by diffeomorphism composition:. Another difference with ResNet is that we train each scale-specific block indepen- dently, which is much easier than training the whole chain at once.Note that the overall complexity of an alignment is very low, linear in the image size. Indeed, for a given image with n pixels, a similar convolutional architecture is applied to all reduced versions by factors 2 s , of size 2 −s ×2 −s n pixels, leading to a total cost of n(1+• "accurate": apply the network on symmetrised and ro- tated versions of the input images, and average the re- sult over these 8 tests. This ensures rotation invariance and improves the result. 3 nK where K is the constant per-pixel convolutional cost. This is to be compared with the classical gradient descent based approaches of unknown convergence duration, and with We perform four experiments on different datasets. The first experiment uses the Inria aerial image labeling dataset [18], which is a collection of aerial orthorecti- fied color (RGB) imagery with a spatial resolution of 30 cm/pixel covering 810 km 2 over 9 cities in USA and Aus- tria. We aim at aligning a map of buildings downloaded from OSM with the images from the Inria dataset. The net- work described in Section 3.6 is trained using image patches from six different cities, for which accurate building cadas- tral data are available 2 . We then evaluated the network by using images of the area of Kitsap County not presented during training. Fig. 5 shows an example close-up of align- ment result. In the second experiment, the network trained in the first experiment is used to align the OSM building map with satellite images with a pansharpened resolution of 50 cm/pixel, acquired by the Pléiades sensor over the Forez ru- ral area in France.To measure performance of the network, we use the per- centage of correct key point metric [27]. We manually iden- tified matching key points on two couples of multimodal images (one Kitsap image from experiment 1 and one Forez image from experiment 2) with more than 600 keypoints for each image. We then measure the distance between the po- sitions of keypoints after alignment by using different algo- rithms and the manually indicated ones. If this distance is smaller than a certain threshold, the keypoint is identified as matched. Fig. 6 compares the performance of our network with the following methods: DeepFlow of Weinzaepfel et al. [35], two variations of geometric matching method of Rocco et al. [27], and a multimodal registration method of Ye et al. [37]. Our approach clearly outperforms other ones by a large margin. We note that averaging over rotations and symmetries (in green, "accurate") does help on the Forez dataset, and that learning scale-specific features performs slightly better than scale-independent features but not al- ways (blue vs. red, "fast"). Examples of alignment results are shown in Figure 7. Our approach is also much faster, as shown by the computational times below for a 5000 × 5000 image, even though we compute a dense registration while other approaches only match keypoints:Method  In a third experiment, we align roads with the images used in the first experiment. The task differs from previous experiments in that only the center line of the road is known, and in the form of a polyline. Moreover, local edges are not useful features for alignment anymore, as the center of roads is homogeneous. We train on OSM data, by dilating road polylines to reach a 4 pixel width and rasterizing them. We then test the performance of the trained network on the Kitsap image. The results are shown in Figure 8.The fourth experiment checks the performance of our approach on a higher-resolution dataset. We consider the Kitti dataset [8], which contains high precision aerial im- ages (9 cm/pixel), as well as perfectly aligned multi classes labeling [20]. We create a training set with artificial random deformations, in the same spirit as before, and a test set with randomly deformed images as well, but following different distributions, in order to check also the robustness of our training approach. Image pairs to be registered consist of a RGB image and a 3-channel binary image indicating build- The curves indicate the percentage of keypoints whose distance to the ground truth is less than the threshold in abscissa. Higher is better. ings, roads and sidewalk presence respectively. An example of result is shown in Figure 9. We also analyse the distribu- tion of misalignments before and after registration, shown as histograms in Figure 10. We note that the vast majority of pixels are successfully very closely matched to their ground truth location. We also perform an extra experiment to show that our multi-scale approach could generalize to other applications. We consider the problem of stereovision, where the input is a pair of RGB images taken from slightly different view points, and the expected output is the depth map, i.e. a single channel image instead of a deformation field. We consider the dataset from [22,23] and define the loss function as the depth error (squared), plus the regularizer (4). We keep the same architecture but link the scale-specific networks with additions instead of compositions, so that each block adds Error value (pixels) Error value (pixels) Figure 10. Misalignment histograms on the fourth experiment (Kitti dataset). Left: original misalignment distribution in the test set; right: remaining error after our automatic alignment.Optimization details The network is trained with an Adam optimizer, on mini-batches of 16 patches of 128 × 128 pixels images, with a learning rate starting from 0.001 and decayed by 4% every 1000 iterations. Weights are ini- tialized following Xavier Glorot's method. We trained for 60 000 iterations. More technical details are available in the Appendix.Additional details specific to sparse modalities such as cadastral maps, though not essential. During training, we sort out fully or mostly blank images (e.g. cadastre with- out any building). Also, in order to train more where there is more information to extract (e.g., corners and edges vs. wide homogeneous spaces), we multiply the pixel loss by a factor &gt; 1 on building edges when training.When rectangular building are glued together in a row with shared walls, the location of their edges and corners is not visible anymore on the rasterized version of the OSM cadastre. By adding a channel to the cadastre map, remind- ing the OSM corner locations, we observe a better align- ment of such rows.Based on an analysis of classical methods, we designed a chain of scale-specific neural networks for non-rigid image registration. By predicting directly the final registration at each scale, we avoid slow iterative processes such as gra- dient descent schemes. The computational complexity is linear in the image size, and far lower than even keypoint matching approaches. We demonstrated its performance on various remote sensing tasks and resolutions. The trained network as well as the training code will be made available online. This way, we hope to contribute to the creation of large datasets in remote sensing, where precision so far was an issue requiring hand-made ground truth.An interesting point to study further is the specialization of the networks for each scale, to check on which type of image dataset it is strong or not (medical imaging vs. land- scape pictures e.g.). Figure 11. Network architecture. The two input images I1 and I2 are fed to layers 1a and 1b respectively. The output is a 2 dimensional vector map (layer 26 with 2 channels). This architecture allows to merge information from both sources at all scales, to extract high-level information, and to remember fine details from the input resolution to output a precise full-resolution deformation. Details on Figure 12.   when the dataset is not sparse or binary.To reduce the training time and possible memory issues, patch of images (256 × 256 pixels) were given to the net- work for the training instead of the whole image, reducing the amount of computations needed per mini-batch. This is also important in terms of memory usage of the network as original images contain 5000 × 5000 pixels. Further- more, neural network computations and data generation (a random transformation is generated for each image at each training step in order to augment the training set size) are parallelized in order to improve the training speed of the algorithm.Another issue encountered was to reach the local min- imum corresponding to outputting always a null defor- mation, thus preventing the neural network parameters to evolve towards a better optimum. To solve this issue we used several methods to facilitate the training of the net- work and reduce its probability to reach this local minima. The first technique used was to force the network to over- fit a very small sample of the dataset (400 iterations on 4 images with random transformations). This proved to be particularly efficient at avoiding the null local minimum.The second technique is specific to the dataset used, i.e. the data from the cadastral images is particularly sparse. The first step is then to check, before selecting any train- ing example, that data needed for alignment is present on the cadastral image, i.e. the cadastral image does contain buildings, e.g. This was done simply by calculating the ratio between labeled and unlabeled pixels (cadastral/non- cadastral) on each candidate image patch, and by setting a range of accepted values (e.g., the minor class of an im- age should represent at least 5% of the labels of this im- age). Patches not respecting this rule were not selected when forming mini-batches. Thus mini-batches contained only relevant examples.Another issue linked to the sparsity of the cadastre arises when the network is training on parts of a patch where not enough data is present to determine the transformation needed (e.g., only one class within an area, as in a garden for example), even to a human eye: the estimation of the offset was not possible due to the lack of information. To solve this problem, we increase the weight of the loss function on the boundaries of buildings (parts where the transformation can be well estimated). For this, we first detect building boundaries based on the cadastre, as shown in 14, and add an multiplying factor to the loss at such locations (which is equivalent to sampling more often there). This insures that the deformation is findable and that the training is useful. This last trick is specific to our dataset, which is binary la- belled, but we show in experiments that this is not needed Lastly, we observed minor aligning issues when dealing with rows of houses with common walls, due to local trans- lation invariance of the images, which adds locally a degree of freedom for alignment along the row axis. We decided to give supplementary information corresponding to the loca- tion of all corners extracted from the OpenStreetMap vecto- rial image (as each corner of each house is indicated), hop- ing to help to guide the alignment along such translation- invariant line in the cadastre. This step is however not crit- ical as the results improvement is small and specific to cer- tain building geometries (row of identical houses with com- mon walls). In the paper we suggest to try the same framework on a dif- ferent task, the one of stereovision. The result, shown in Figure 18 without any tuning, is very promising and con- firms the generalization ability of our approach.  
