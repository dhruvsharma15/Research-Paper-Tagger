As neural networks move into applications where the out- comes of human lives depend on their decisions, it is in- creasingly crucial that we are able to interpret the decisions they make. Indeed, the European Union is considering legis- lation with a clause that asserts that individuals have 'rights to explanation', i.e. individuals should be able to under- stand how algorithms make decisions about them (Council of European Union, 2016). Example problem domains re- One approach to interpreting neural networks is to train the network as normal, and then apply analysis techniques after training. Often this approach yields systems that per- form extremely well, but where interpretability is challeng- ing. For example, Sussillo &amp; Barak (2013) used lineariza- tion and nonlinear dynamical systems theory to understand RNNs solving a set of simple but varied tasks. Karpathy et al. (2015) analyzed an LSTM (Hochreiter &amp; Schmidhuber, 1997) trained on a character-based language modeling task. They were able to break down LSTM language model errors into classes, such as e.g., "rare word" errors. Con- currently with our submission, Murdoch &amp; Szlam (2017) decomposed LSTM outputs using telescoping sums of statis- tics computed from memory cells at different RNN steps. The decomposition is exact, but not unique and the authors justify it by demonstrating good performance of decision rules formed using the computed cell statistics.The community is also interested in post hoc interpretation of feed-forward networks. Examples include the use of linear probes in Alain &amp; Bengio (2016), and a variety of techniques (most driven by back-propagation) to assign credit for activations to specific inputs or input patterns in feed-forward networks ( Zeiler et al., 2010;Le et al., 2012;Mordvintsev et al., 2015). A second approach is to build a neural network where inter- pretability is an explicit design constraint. In this approach, a typical outcome is a system that can be better understood, but at the cost of reduced performance. Model classes whose decisions are naturally interpretable include logistic regres- sion (Freedman, 2009), decision trees (Quinlan, 1987), and support vector machines with simple (e.g. linear) kernels (Andrew, 2013).In this work we follow this second approach and build in- terpretability into our network model, while maintaining good, though not always state-of-the-art, performance for the tasks we study. We focus on the commonly studied task of character based language modeling. We develop and analyze a model trained on a one-step-ahead predic- tion task of the Text8 dataset, which is 10 million char- acters of Wikipedia text (Mahoney, 2011), on the Billion Word Benchmark ( Chelba et al., 2013), and finally on a toy multiple parentheses counting task which we fully reverse engineer. and performs probabilistic sequence modeling. Unlike the ISAN, the OOM requires that a linear projection of the hid- den state corresponds to a normalized sequence probability. This imposes strong constraints on both the model param- eters and the model dynamics, and restricts the choice of training algorithms. In contrast, the ISAN applies an affine readout to the hidden state to obtain logits, which are then pushed through the softmax function to obtain probabilities. Therefore no constraints need to be imposed on the ISAN's parameters and training is easy using backprop. Lastly, the ISAN is formulated as an affine, rather than linear model. While this doesn't change the class of processes that can be modeled, it stabilizes training and greatly enhances inter- pretability, facilitating the analysis in Section 3.3.1.5. Paper structureThe model we introduce is an Input Switched Affine Net- work (ISAN), where the input determines the switching behavior by selecting a transition matrix and bias as a func- tion of that input, and there is no nonlinearity. Linear time- varying systems are standard material in undergraduate elec- trical engineering text books, and are closely related to our technique.In what follows, we define the ISAN architecture, demon- strate its performance on the one-step-ahead prediction task, and then analyze the model in a multitude of ways, most of which would be currently difficult or impossible to accom- plish with modern nonlinear recurrent architectures.Although the ISAN is deterministic, probabilistic versions of switching linear models with discrete latent variables have a history in the context of probabilistic graphical models. A recent example is the switched linear dynamical system in ( Linderman et al., 2016). Focusing on language modeling, (Belanger &amp; Kakade, 2015) defined a probabilistic linear dynamical system (LDS) as a generative language model for creating context-dependent token embeddings and then used steady-state Kalman filtering for inference over token sequences. They used singular value decomposition and discovered that the right and left singular vectors were se- mantically and syntactically related. A critical difference between the ISAN and the LDS is that the ISAN weight matrices are input token dependent (while the biases of both models are input dependent).In what follows W x and b x respectively denote a transition matrix and a bias vector for a specific input x, the symbol x t is the input at time t, and h t is the hidden state at time t. Our ISAN model is defined asThe network also learns an initial hidden state h 0 . We em- phasize the intentional absence of any nonlinear activation function.Multiplicative neural networks (MRNNs) were proposed precisely for character based language modeling in ). The MRNN architecture is similar to our own, in that the dy- namics matrix switches as a function of the input character. However, the MRNN relied on a tanh nonlinearity, while the ISAN is explicitly linear. It is this property of our model which makes it both amenable to analysis, and computation- ally efficient.We trained RNNs on the Text8 Wikipedia dataset and the bil- lion word benchmark (BWB), for one-step-ahead character prediction. The Text8 dataset consists only of the 27 char- acters 'a'-'z' and '_' (space). The BWB dataset consist of Unicode text and was modelled as a sequence of bytes (256 discrete tokens) that formed the UTF8-encoded data. Given a character sequence of x 1 , ..., x t , the RNNs are trained to minimize the cross-entropy between the true next character, and the output prediction. We map from the hidden state, h t , into a logit space via an affine map. The probabilities are computed asThe Observable Operator Model (OOM) (Jaeger, 2000) is similar to the ISAN in that the OOM updates a latent state using a separate transition matrix for each input symbolwhere W ro and b ro are the readout weights and biases, and l t is the logit vector. For the Text8 dataset, we split  the data into 90%, 5%, and 5% for train, validation, and test respectively, in line with ( Mikolov et al., 2012). The network was trained with the same hyperparameter tuning infrastructure as in ( Collins et al., 2016). For the BWB dataset, we used data splits and evaluation setup identical to (Józefowicz et al., 2016). Due to long experiment running times, we manually tuned the hyperparameters.3. Results and analysisThe results on Text8 are shown in Table 1. For the largest parameter count, the ISAN matches almost exactly the per- formance of all other nonlinear models with the same num- ber of maximum parameters: RNN, IRNN, GRU, LSTM. However, we note that for small numbers of parameters the ISAN performs considerably worse than other architectures. All analyses use ISAN trained with 1.28e6 maximum pa- rameters (1.58 bpc cross entropy). Samples of generated text from this model are relatively coherent. We show two examples, after priming with "annual reve", at inverse tem- perature of 1.5, and 2.0, respectively:without input switched dynamics. This achieves a cross- entropy of 3.1 bits / char, independent of network size. This perplexity is only slightly better than that of a Naive Bayes model on the task, at 3.3 bits / char. The output probability of the fully linear network is a product of contributions from each previous character, as in Naive Bayes. Those factorial contributions are learned however, giving the non-switched affine network a slight advantage. We also trained a fully linear network with a nonlinear readout. This achieves 2.15 bits / char, independent of network size. Both of these comparisons illustrate the importance of the input switched dynamics for achieving good results.Lastly we also test to what extent the ISAN can deal with large dictionaries by running it on a byte-pair encoding of the text8 task, where the input dictionary consists of the 27   2 • "annual revenue and producer of the telecommunica- tions and former communist action and saving its new state house of replicas and many practical persons" • "annual revenue seven five three million one nine nine eight the rest of the country in the united states and south africa new". As a preliminary, comparative analysis, we performed PCA on the state sequence over a large set of sequences for the vanilla RNN, GRU of varying sizes, and ISAN. This is shown in Figure 1. The eigenvalue spectra, in log of variance explained, was significantly flatter for the ISAN than the other architectures.We trained ISAN and LSTM models on the BWB dataset. All networks were trained using asynchronous gradient de- scent using the Adagrad learning rule. Our best LSTM model reached 1.1 bits per character, which matches pub- lished results (Hwang &amp; Sung, 2016  Figure 2. Using the linearity of the hidden state dynamics, predictions at step t can be broken out into contributions, κ t s , from previous steps. Accordingly, each row of the top panel corresponds to the propagated contribution (κ t s ) of the input character at time s, to the prediction at time t (summed to create the logit at time t). The penultimate row contains the output bias vector replicated at every time step. The last row contains the logits of the predicted next character, which is the sum of all rows above. The bottom panel contains the corresponding softmax probabilities at each time t for all characters (time is separated by gray lines). Labeled is the character with the maximum predicted probability. The time step boxed in red is examined in more detail in Figure 3. 512 hidden units, a reduced set of most common 70 input tokens and 256 output tokens (18e6 parameters). Increasing ISAN's hidden layer size to 768 units (41e6 parameters) yielded a perplexity improvement to 1.36 bits/char. Investi- gation of generated samples shows that the ISAN learned the distinction between lower-and upper-cased letters and is able to generate text which is coherent over short segments.To demonstrate sample variability we show continuations of the prompt "The [Pp]ol" generated using the ISAN: time points s in the history of the input:where the empty product when s + 1 &gt; t is 1 by convention, and b x0 = h 0 is the learned initial hidden state.• Using this decomposition and the fact that matrix multi- plication is a linear transformation we can also write the unnormalized logit-vector, l t , as a sum of terms linear in the biases, With ISAN we can analyze which factors were important in the past for determining the current character prediction. Taking advantage of the linearity of the hidden state dynam- ics for any sequence of inputs, we decompose the current latent state h t into contributions originating from different 'q' refers to the contribution from the character 'q' in a string. Similarly, when discussing the summed con- tributions from a word or substring we will sometimes write κ terms that are propagated and transformed through time. We emphasize that κ t '_' to zero. The results from panel b demonstrate the disproportionately large importance of '_' in decoding, especially at the onset of a word. c) The cross-entropy as a function of history when artificially limiting the number of characters available for prediction. This corresponds to only considering the most recent n of the κ, where n is the length of the history.s includes the multiplicative contributions from the W x s for s &lt; s ≤ t. It is however independent of prior inputs, x s for s &lt; s. This is the main difference between the analysis we can carry out with the ISAN com- pared to a nonlinear RNN. In a general recurrent network the contribution of a specific character sequence will depend on the hidden state at the start of the sequence. Due to the linearity of the dynamics, this dependency does not exist in the ISAN.next corresponds to the decay of information across words and sentences. We also show the relevance of the κ t In Figure 2 we show an example of how this decomposi- tion allows us to understand why a particular prediction is made at a given point in time, and how previous characters influence the decoding. For example, the sequence '_an- nual_revenue_' is processed by the ISAN: Starting with an all-zero hidden state, we use equation (6) to accumulate a sequence of κ s contri- butions to the decoding of characters at different positions in the word (Figure 4b). For example, we observe that κ t '_' makes important contributions to the prediction of the next character at time t. We show that using only the κ t t t t t t '_' , the model can achieve a cross entropy of less than 1 bit / char when the position of the character is more than 3 letters from the beginning of the word. Finally, we link the norm-decay of κ '_ , κ 'a , κ 'n , κ 'n , .... We then used these values to understand the prediction of the network at some time t, by simple addition across the s index.We provide a detailed view of how past characters contribute to the logits predicting the next character in Figure 3. There are two competing options for the next letter in the word stem 'reve': either 'revenue' or 'reverse'. We show that without the contributions from '_annual' the most likely decoding of the character after the second 'e' is 'r' (to form 'reverse'), while the contributions from '_annual' tip the balance in favor of 'n', decoding to 'revenue'. s to the importance of past characters for the decoding quality ( Figure 4c). By artificially limiting the number of past κ available for prediction we show that the prediction quality improves rapidly when extending the history from 0 to 10 characters and then saturates. This rapid improvement aligns with the range of faster decay in Figure 4a.The ISAN provides a natural means of moving from char- acter level representation to word level. Using the linearity of the hidden state dynamics we can aggregate all of the κ t Using ISAN, we can investigate information timescales in the network. For example, we investigated how quickly the contributions of κ t s decay as a function of t − s on average. Figure 4a shows that this contribution decays on two dif- ferent exponential timescales. We hypothesize that the first time scale corresponds to the decay within a word, while the s belonging to a given word and visualize them as a sin- gle contribution to the prediction of the letters in the next word. This allows us to understand how each preceding word impacts the decoding for the letters of later words. In Figure 5 we show that the words 'was' and 'higher' make large contributions to the prediction of the characters in 'than' as measured by the norm of the κ For example, when predicting the characters of 'than' there is a large contribution from both κ Figure 6. By transforming the ISAN dynamics into a new basis, we can better understand the action of the input-dependent biases. a) We observe a strong correlation between the norms of the input de- pendent biases, bx, and the log-probability of the unigram x in the training data. We can begin to understand this correlation structure using a basis transform into the 'readout basis'. Breaking out the norm into its components in P ro ro and P ⊥ in b) and c) respectively, shows that the correlation is due to the component orthogonal to Wro. This implies a connection between information or 'surprise' and distance in the 'computational' subspace of state space. We are free to perform a change of basis on the hidden state, and then to run the affine ISAN dynamics in that new basis. Note that this change of basis is not possible for other RNN architectures, since the action of the nonlinearity depends on the choice of basis. Figure 7. By transforming ISAN dynamics into a new basis, we can better interpret structure in the input-dependent biases. In a) we show the cosine distance between the input dependent bias vectors, split between vowels and consonants (' ' is first). In b) we show the correlation only considering the components in the subspace P ro spanned by the rows of the readout matrix Wro. c) shows the correlation of the components in the orthogonal complement P ro ⊥ . In all plots white corresponds to 0 (aligned) and black to 2.In particular we can construct a 'readout basis' that explicitly divides the latent space into a subspace P ro spanned by the rows of the readout matrix W ro , and its orthogonal complement P ro component of b x in the computational space, rather than in the readout space.⊥ . This representation explicitly divides the hidden state dynamics into a 27-dimensional 'readout' subspace that is accessed by the readout matrix to make predictions, and a 'computational' subspace comprising the remaining 216 − 27 dimensions that are orthogonal to the readout matrix.Similarly, in Figure 7 we illustrate that the structure in the correlations between the biases b x (across all x) is due to their components in P ro ro , while the correlation in P We apply this change of basis to analyze an intriguing ob- servation about the hidden offsets b x . As shown in Fig- ure 6, the norm of the b x is strongly correlated to the log-probability of the unigram x in the training data. Re- expressing network parameters using the 'readout basis' shows that this correlation is not related to reading out the next-step prediction. This is because the norm of the pro- jection of b x into P ⊥ is relatively uniform. We can clearly see two blocks of high correlations between the vowels and consonants respectively, while b '_' is uncorrelated to either.ro ⊥ remains strongly correlated with character frequency, while the projection into P ro shows little correlation. This indicates that the information content or 'surprise' of a letter is encoded through the norm of the We compared the computation performed by n-gram lan- guage models and those performed by the ISAN. An n-gram model with back-off weights expresses the conditional prob- ability p (x t |x 1 ...x t−1 ) as a sum of smoothed count ratios of n-grams of different lengths, with the contribution of shorter n-grams down-weighted by back-off weights. On the other hand, the computations performed by the ISAN start with the contribution of b ro to the logits, which as shown in Fig-ure 8a, corresponds to the unigram log-probabilities. The logits are then additively updated with contributions from longer n-grams, represented by κ t s . This additive contribu- tion to the logits corresponds to a multiplicative modifica- tion of the emission probabilities from histories of different length. For long time lags, the additive correction to log- probabilities becomes small (Figure 2), which corresponds to multiplication by a uniform distribution. Despite these differences in how n-gram history is incorporated, we nev- ertheless observe an agreement between empirical models estimated on the training set and model predictions for uni- grams and bigrams. Figure 8 shows that the bias term b ro gives the unigram probabilities of letters, while the addition of the offset terms b x accurately predict the bigram distri- bution of P (x t+1 |x t ). Shown in panel b is an example, P (x|'_ ), and in panel c, a summary plot for all 27 letters.We further explore the n-gram comparison by artificially limiting the length of the character history that is available to the ISAN for making predictions, as shown in Figure 4c). we compare softmax(bro) to the empirical unigram distribution P (x). In b) we compare softmax(Wrob'_' + bro) with the em- pirical distribution P (xt+1|'_'). In c) we show the correlation of softmax(Wrobx + bro) with P (xt+1|xt) for all 27 characters (y-axis), and compare this to the correlation between the empiri- cal unigram probabilities P (x) to P (xt+1|xt) (x-axis). The plot shows that the readout of the bias vector is a better predictor of the conditional distribution than the unigram probability.states into this computational subspace 2-hot vectors. With this subspace decomposition, the hidden states and character matrices have the formTo show the possibility of complete interpretability of the ISAN we train a model on a parenthesis counting task. Bringing together ideas from section 3.5 we re-express the transition dynamics in a new basis that fully reveals per- formed computations.and the update equation can be written asWe analyze the task of counting the nesting levels of multi- ple parentheses types, a simplified version of a task defined in ( Collins et al., 2016). Briefly, a 35-unit ISAN is required to keep track of the nesting level of 2 different types of parentheses independently. The inputs are the one-hot en- coding of the different opening and closing parentheses (e.g. '(', ')', ' [', ']') as well as a noise character ('a'). The output is the one-hot encoding of the nesting level between (0-5), one set of counts for each parenthesis type (so the complete output vector is a 12 dimensional 2-hot vector). Further- more, the target output is the nesting level at the previous time step. This artificial delay requires the model to develop a memory. One change from ( Collins et al., 2016) is that we exchange the cross-entropy error with an L2 error. This leads to slightly cleaner figures, but does not qualitatively change the results. In this paper we motivated an input-switched affine recurrent network for the purpose of interpretability. We showed that a switched affine architecture achieves the same performance as LSTMs on the Text8 dataset for the same number of maximum parameters, and reasonable performance on the BWB. We performed a series of analyses, demonstrating the ability to understand how inputs at one point in the input sequence affect the outputs later in the output sequence. We showed further in the multiple parentheses counting task that the ISAN dynamics can be completely reverse engineered. In summary, this work provides evidence that the ISAN is able to express complex dynamical systems, yet its operation can in principle be fully understood, a prospect that remains out of reach for many popular recurrent architectures. Switched affine networks hold the potential to be massively more computationally and memory efficient for text process- ing than other recurrent architectures. First, input-dependent affine transitions reduce the number of parameters used at every step. For K possible inputs and N parameters, the computational cost per update step is O N , a factor of K 1 2 mem- ory improvement for storage of the latent state.Furthermore, the ISAN is unique in its ability to pre- compute affine transformations corresponding to input strings. This is possible because the composition of affine transformations is also an affine transformation. This prop- erty is used in Section 3.4 to evaluate the linear contributions of words, rather than characters. This means that the hidden state update corresponding to an entire input sequence can be computed with identical cost to the update for a single character (plus the dictionary look-up cost for the com- posed transformation). ISAN can therefore achieve very large speedups on input processing, at the cost of increased memory use, by accumulating large look-up tables of the W x and b x corresponding to common input sequences. Of course, practical implementations will have to incorporate There are some obvious future directions to this work. Cur- rently, we define switching behavior using an input set with finite and manageable cardinality. Studying word-level lan- guage models with enormous vocabularies may require some additional logic to scale. Another idea is to build a language model that switches on bigrams or trigrams, rather than characters or words, targeting an intermediate number of affine transformations. Adapting this model to continuous-valued inputs is another important direction. One approach is to use a tensor factorization similar to that employed by the MRNN ( Sutskever et al., 2014) or defining weights via additional networks, as in HyperNetworks ( Ha et al., 2016). Finally, we expect that automated methods for changing bases to enable sparse representations in the hidden state and dynamics matrices will be a particularly fruitful direction to pursue.
