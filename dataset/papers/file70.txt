In models for natural language dialogue and question answering, there is ubiquitous need for querying a knowledge-base [13,11]. The traditional pipeline is to put the query through a semantic parser to obtain some "executable" representations, typically logical forms, and then apply this representation to a knowledge-base for the answer. Both the semantic parsing and the query execution part can get quite messy for complicated queries like˜Qlike˜ like˜Q: "Which city hosted the longest game before the game in Beijing? " in Figure 1, and need carefully devised systems with hand-crafted features or rules to derive the correct logical form˜Fform˜ form˜F (written in SQL-like style). Partially to overcome this difficulty, there has been effort [11] to "backprop- agate" the result of query execution to revise the semantic representation of the query, which actually falls into the thread of work on learning from grounding [5]. One drawback of these Athens (probability distribution over entries) Executor-5 Select host_city of r2Executor-4Memory Layer-4Find r2 in R with max(#_duration)Executor-3 Memory Layer-3Find row sets R where year &lt; aExecutor-2 Memory Layer-2 Figure 1: An overview of Neural Enquirer with five executors semantic parsing models is rather symbolic with rule-based features, leaving only a handful of tunable parameters to cater to the supervision signal from the execution result.On the other hand, neural network-based models are previously successful mostly on tasks with direct and strong supervision in natural language processing or related domain, with examples including machine translation and syntactic parsing. The recent work on learning to execute simple Python code with LSTM [15] pioneers in the direction on learning to parse structured objects through executing it in a purely neural way, while the later work on Neural Turing Machine (NTM) [6] introduces more modeling flexibility by equipping the LSTM with external memory and various means of interacting with it.Our work, inspired by above-mentioned threads of research, aims to design a neural net- work system that can learn to understand the query and execute it on a knowledge-base table from examples of queries and answers. Our proposed Neural Enquirer encodes queries and KBs into distributed representations, and executes compositional queries against the KB through a series of differentiable operations. It can be trained using Query-Answer pairs, where the distributed representations of queries and the KB are optimized together with the query execution logic in an end-to-end fashion. We then demonstrates using a synthetic question-answering task that our proposed Neural Enquirer is capable of learning to exe- cute compositional natural language queries with complex structures.Given an NL query Q and a KB table T , Neural Enquirer executes the query against the table and outputs a ranked list of query answers. The execution is done by first using Encoders to encode the query and table into distributed representations, which are then sent to a cascaded pipeline of Executors to derive the answer. Figure 1 gives an illustrative example (with five executors) of various types of components involved:Query Encoder (Section 3.1), which encodes the query into a distributed representation that carries the semantic information of the original query. The encoded query embedding will be sent to various executors to compute its execution result.  Table Encoder outputs an embedding vector for each table entry, which retains the two- dimensional structure of the table. Executor (Section 3.3), which executes the query against the table and outputs annotations that encode intermediate execution results, which are stored in the memory of each layer to be accessed by subsequent executor. Our basic assumption is that complex, compositional queries can be answered through multiple steps of computation, where each executor models a specific type of operation conditioned on the query. Figure 1 illustrates the operation each executor is supposed to perform in answering˜Qanswering˜ answering˜Q. Different from classical semantic parsing approaches which require a predefined set of all possible logical operations, Neural Enquirer is capable of learning the logic of executors via end-to-end training using Query-Answer pairs. By stacking several executors, Neural Enquirer is able to answer complex queries involving multiple steps of computation.In this section we give a more detailed exposition of different types of components in the Neural Enquirer model.Given an NL query Q composed of a sequence of words {w 1 , w 2 , . . . , w T }, Query Encoder parses Q into a d Q -dimensional vectorial representation q:In our imple- mentation of Neural Enquirer, we employ a bidirectional RNN for this mission 1 . More specifically, the RNN summarizes the sequence of word embeddings of Q, {x 1 , x 2 , . . . , x T }, into a vector q as the representation of Q, whereIt is worth noting that our Query Encoder can find the representation of rather general class of symbol sequences, agnostic to the actual representation of queries (e.g., natural lan- guage, SQL-like, etc). Neural Enquirer is capable of learning the execution logic expressed in the input query through end-to-end training, making it a generic model for query execution.   table embedding  row reading   row annotations   Reader   Annotator   pooling   table annotation Memory Layer-( -1) Figure 2: Overview of an Executor- the embedding for field names and values of table, and then it computes the (field, value) composite embedding for each of the M × N entries in the table. More specifically, for the entry in the m-th row and n-th column with a value of w mn , Table Encoder computes a d E -dimensional embedding vector e mn by fusing the embedding of the entry value with the embedding of its corresponding field name as follows:where f n is the embedding of the field name (of the n-th column). W and b denote the weight matrices, and [·; ·] the concatenation of vectors. The output of  TransE [4]), where embeddings of entities (entry values) and relations (field names) are learned in a unsupervised fashion via minimizing certain reconstruction errors. Embeddings in Neu- ral Enquirer are optimized via supervised learning towards end-to-end QA tasks. Addi- tionally, as will shown in the experiments, those embeddings function in a way as indices, which not necessarily encode the exact semantic meaning of their corresponding words.Neural Enquirer executes an input query on a KB table through layers of execution. Each layer of executor captures a certain type of operation (e.g., select, where, max, etc.) relevant to the input query 2 , and returns intermediate execution results, referred to as annotations, saved in an external memory of the same layer. A query is executed step-by-step through a sequence of stacked executors. Such a cascaded architecture enables Neural Enquirer to answer complex, compositional queries. An illustrative example is given in Figure 1, with each executor annotated with the operation it is assumed to perform. We will demonstrate in Section 5 that Neural Enquirer is capable of learning the operation logic of each executor via end-to-end training.As illustrated in Figure 2, an executor at Layer-(denoted as Executor-has two major neural network components: Reader and Annotator. An executor processes a table row-by- row. For the m-th row, with N (field, value) composite embeddings R m = {e m1 , e m2 , . . . , e mN }, the Reader fetches a read vector r m from R m , which is sent to the Annotator to compute a  Read Vector:Row Annotation:where M denotes the content in memory Layer-( and F T = {f 1 , f 2 , . . . , f N } is the set of field name embeddings. Once all row annotations are obtained, Executor-then generates the table annotation through the following pooling process:  [6], where data is fetched from an external memory using a read head, and subsequently processed by a controller, whose outputs are flushed back in to memories. An executor functions similarly by reading data from each row of the table, using a Reader, and then calling an Annotator to calculate inter- mediate computational results as annotations, which are stored in the executor's memory. We assume that row annotations are able to handle operations which require only row-wise, local information (e.g., select, where), while table annotations can model superlative operations (e.g., max, min) by aggregating table-wise, global execution results. Therefore, a combination of row and table annotations enables Neural Enquirer to capture a variety of real-world query operations.As illustrated in Figure 3, an executor at Layer-reads in a vector r m for each row m, defined as the weighted sum of composite embeddings for entries in this row:where˜ωwhere˜ where˜ω(·) is the normalized attention weights given by:and ω(·) is modeled as a DNN (denoted as DNN ( 1 ). Note that the˜ωthe˜ the˜ω(·) is agnostic to the values of entries in the row, i.e., in an executor all rows share the same set of weights˜ωweights˜ weights˜ω(·). Since each executor models a specific type of computation, it should only attend to a subset of entries pertain to its execution, which is modeled by the Reader. This is related to the content-based addressing of Neural Turing Machines [6] and the attention mechanism in neural machine translation models [2].In Executor-the Annotator computes row and table annotations based on the fetched read vector r m of the Reader, which are then stored in the memory layer M accessible to Executor-( This process is repeated in intermediate layers, until the executor in the last layer to finally generate the answer.Row annotations A row annotation encodes the local computational result on a specific row. As illustrated in Figure 4, a row annotation for row m in Executor-given byfuses the corresponding read vector r m , the results saved in previous memory layer (row and table annotations a m , g ), and the query embedding q. Basically,• row annotation a m represents the local status of the execution before Layer-• table annotation g summarizes the global status of the execution before Layer-• read vector r m stores the value of current attention;• query embedding q encodes the overall execution agenda, all of which are combined through DNN   ( 5) whereis the maximum value among the k-th elements of all row annotations. It is possible to use other pooling operations (e.g., gated pooling), but we find max pooling yields the best results.Instead of computing annotations based on read vectors, the last executor in Neural En- quirer directly outputs the probability of the value of each entry in T being the answer:where f ans (·) is modeled as a DNN. Note that the last executor, which is devoted to returning answers, carries out a specific kind of execution using f Ans (·) based on the entry value, the query, and annotations from previous layer.Real-world KBs are often modeled by a schema involving various tables, where each table stores a specific type of factual information. We present Neural Enquirer-M, adapted for simultaneously operating on multiple KB tables. A key challenge in this scenario is that the multiplicity of tables requires modeling interaction between them. For example, Neural Enquirer-M needs to serve join queries, whose answer is derived by joining fields in different tables. Details of the modeling and experiments of Neural Enquirer-M are given in Appendix C.Neural Enquirer can be trained in an end-to-end (N2N) fashion in Question Answering tasks. During training, both the representations of queries and table entries, as well as the execution logic captured by weights of executors are learned. More specifically, given a set of, y (i) )}, we optimize the model parameters by maximizing the log-likelihood of gold-standard answers:In end-to-end training, each executor discovers its operation logic from training data in a purely data-driven manner, which could be difficult for complicated queries requiring four or five sequential operations. This can be alleviated by softly guiding the learning process via controlling the attention weights˜wweights˜ weights˜w(·) in Eq. (3). By enforcing˜wenforcing˜ enforcing˜w(·) to bias towards a field pertain to a specific operation, we can "coerce" the executor to figure out the logic of this particular operation relative to the field. As an example, for Executor-1 in Figure 1, by biasing the weight of the host city field towards 1.0, only the value of host city field will be fetched and sent for computing annotations, in this way we can force the executor to learn to find the row whose host city is Beijing. This setting will be referred to as step-by-step (SbS) training. Formally, this is done by introducing additional supervision signal to Eq. (7):where α is a scalar and f k,, is the embedding of the field name known a priori to be relevant to the executor at Layer-in the k-th example.In this section we evaluate Neural Enquirer on synthetic QA tasks with queries with vary- ing compositional depth. We will first briefly describe our synthetic QA task for benchmark and experimental setup, and then discuss the results under different settings.We present a synthetic QA task to evaluate the performance of Neural Enquirer, where a large amount of QA examples at various levels of complexity are generated to evaluate the single table and multiple tables cases of the model. Starting with "artificial" tasks eases the process of developing novel deep models [14], and has gained increasing popularity in recent advances of the research on modeling symbolic computation using DNNs [6,15].Our synthetic dataset consists of query-table-answer triples {(Q (i) , T (i) , y (i) )}. To generate such a triple, we first randomly sample a table T (i) of size 10 × 10 from a synthetic schema of Olympic Games, which has 10 fields, whose values are drawn from a vocabulary of size 240, with 120 country and city names, and 120 numbers. Figure 5 gives an example table with one row. Next, we generate a query Q (i) using predefined templates associated with its gold-standard answer y (i) on T (i) . Our task consists of four types of natural language queries as summarized in Table 1, with annotated SQL-like logical forms for easy interpretation. We generate NL queries at various levels of compositionality to mimic the real world scenario. The complexity of those queries ranges from simple Select Where queries to more complicated Nest ones involving multiple steps of computation. Those queries are flexible enough to involve complex matching between NL phrases and logical constituents, which makes query understanding and execution nontrivial: (1) the same field is described by different NL phrases (e.g., "How big is the country ..." and "What is the size of the country ..." for country size field); (2) different fields may be referred to by the same NL pattern (e.g, "in China" for country and "in Beijing" for host city); (3) simple NL constituents may be grounded to complex logical operations (e.g., "after the game in Beijing" implies comparing between year fields). In our experiments we use the above procedure to generate benchmark datasets consisting of different types of queries. To make the artificial task harder, we enforce that all queries in the testing set do not appear in the training set.To  Table 1: Example queries in our synthetic QA task training examples respectively, where four types of quires are sampled with the ratio 1 : 1 : 1 : 2. Both datasets share the same testing set of 20K examples, 5K for each type of query.[Tuning] We use a Neural Enquirer with five executors. The number of layers for DNN( 1 and DNN ( 2 are set to 2 and 3, respectively. We set the dimensionality of word/entity em- beddings and row/table annotations to 20, hidden layers to 50, and the hidden states of the GRU in query encoder to 150. α in Eq. (8) is set to 0.2. We pad the beginning of all input queries to a fixed size.Neural Enquirer is trained via standard back-propagation. Objective functions are op- timized using SGD in a mini-batch of size 100 with adaptive learning rates (AdaDelta [16]). The model converges fast within 100 epochs.[Baseline] We compare our model with Sempre [11], a state-of-the-art semantic parser.[Metric] We evaluate the performance of Neural Enquirer and Sempre (baseline) in terms of accuracy, defined as the fraction of correctly answered queries. Table 2 summarizes the results of Sempre (baseline) and our Neural Enquirer under end- to-end (N2N) and step-by-step (SbS) settings. We show both the individual performance for each type of query and the overall accuracy. We evaluate Sempre only on Mixtured-25K because of its long training time even on the smaller Mixtured-25K (&gt; 3 days). We give discussion of efficiency issues in Appendix B.We first discuss Neural Enquirer's performance under end-to-end (N2N) training set- ting (the 3rd and 6th column in  How long is the game with the most medals that has fewer than 3,000 participants?1.0Executor-11.0Executor-21.0Executor-31.0Executor-4Executor tion 5.4. On Mixtured-25K, our model outperforms Sempre on all types of queries, with a marginal gain on simple queries (Select Where, Superlative), and significant improve- ment on complex ones (Where Superlative, Nest). When the size of training set grows (Mixtured-100K), Neural Enquirer achieves near 100% accuracy for the first three types of queries, while registering a decent overall accuracy of 90.6%. These results suggest that our model is very effective in answering compositional natural language queries, especially those with complex semantic structures compared with the state-of-the-art system. To further understand why our model is capable of handling compositional queries, we study the attention weights˜wweights˜ weights˜w(·) of Readers (Eq. 3) for executors in intermediate layers, and the answer probability (Eq. 6) the last executor outputs for each entry in the table. Those statistics are obtained from the model trained on Mixtured-100K. We sampled two queries (Q 5 and Q 7 in Table 1) in the dataset that our model answers correctly and visualized their corresponding values, as illustrated in Figure 6 and 7, respectively. We find that each executor actually learns its execution logic from just the correct answers in end-to-end training, which corresponds with our assumption. For Q 5 , the model executes the query in three steps, with each of the last three executors performs a specific type of operation. For each row, Executor-3 takes the value of the # participants field as input and computes intermediate annotations, while Executor-4 focuses on the # medals field. Finally, the last executor outputs high probability for the # duration field (the 5-th column) in the 3-rd row. The attention weights for Executor-1 and Executor-2 appear to be meaningless because Q 5 requires only three steps of execution, and the model learns to defer the meaningful execution to the last three executors. We can guess confidently that in executing Q 5 , Executor-3 performs the conditional filtering operation (where clause in F 5 ), and Executor-4 performs the first part of argmax (finding the maximum value of # medals), while the last executor finishes the execution by assigning high probability for the # duration field of the row with the maximum value of # medals.Compared with the relatively simple Q 5 , Q 7 is more complicated, whose logical form F 7 involves a nest sub-query, and requires five steps of execution. From the weights visualized in figure 7, we can find that the last three executors function similarly as the case in answering Q 8 : How many people watched the earliest game that lasts for more days than the game in 1956?1.0Executor-11.0Executor-21.0Executor-31.0Executor-4Executor Q 5 , yet the execution logic for the first two executors is a bit obscure. We posit that this is because during end-to-end training, the supervision signal propagated from the top layer has decayed along the long path down to the first two executors, which causes vanishing gradient problem.We also investigate the case where our model fails to deliver the correct answer for compli- cated queries. Figure 8 gives such a query Q 8 in Table 1 together with its visualized weights. Similar as Q 7 , Q 8 requires five steps of execution. Besides messing up the weights in the first two executors, the last executor, Executor-5, predicts a wrong entry as the query answer, instead of the highlighted (in red rectangle) correct entry.To alleviate the vanishing gradient problem when training on complex queries as described in Section 5.3, in our next set of experiments we trained our Neural Enquirer model using step-by-step (SbS) training (Eq. 8), where we encourage each executor to attend to a specific field that is known a priori to be relevant to its execution logic. The results are shown in the 4-rd and 7-th columns of Table 2. With stronger supervision signal, the model significantly outperforms the results in end-to-end setting, and achieves near 100% accuracy on all types of queries, which shows that our proposed Neural Enquirer is capable of leveraging the additional supervision signal given to intermediate layers in SbS training setting, and answering complex and compositional queries with perfect accuracy.Let us revisit the query Q 7 in SbS setting with the weights visualization in Figure 9. In contrast to the result in N2N setting (Figure 7) where the attention weights for the first two executors are obscure, the weights in every executor are perfectly skewed towards the actual field pertain to each layer of execution (with a weight 1.0). Quite interestingly, the attention weights for Executor-3 and Executor-4 are exactly the same with the result in N2N setting, while the weights for Executor-1 and Executor-2 are significantly different, suggesting Neural Enquirer learned a different execution logic in the SbS setting. Q 9 : How many people watched the game in Macau?1.0Executor-11.0Executor-21.0Executor-31.0Executor-4Executor One of the major challenges for applying neural network models to NLP applications is to deal with Out-Of-Vocabulary (OOV) words, which is particularly severe for QA. It is hard to cover existing tail entities, while at the same time new entities appear in user-issued queries and back-end KBs everyday. Quite interestingly, we find that a simple variation of Neural Enquirer is able to handle unseen entities almost without any loss of accuracy.Basically, we divide words in the vocabulary into entity words and operation words. Em- beddings of entity words (e.g., Beijing, China) function in a way as index to facilitate the matching between entities in queries and tables during the layer-by-layer execution, and do not need to be updated once initialized; while those of operation words, i.e., all non-entity words (e.g., numbers, longest, before, etc) carry semantic meanings relevant to execution and should be optimized during training. Therefore, after randomly initializing the embedding matrix L, we only update the embeddings of operation words in training, while keeping those of entity words unchanged.To test the model's performance with OOV words, we modify queries in the testing portion of the Mixtured dataset to replace all entity words (i.e., all country and city names) with OOV ones 3 unseen in the training set. Results obtained using N2N training are summarized in the 5th and 8th columns of Table 2. As it shows Neural Enquirer training in this OOV setting yields performance comparable to that in the non-OOV setting, indicating that operation words and entity words play different roles in query execution.An interesting question to investigate in this OOV setting is how Neural Enquirer distinguishes between different types of entity words (i.e., cities and countries) in queries, since their embeddings are randomly initialized and fixed thereafter. An example query is Q 9 : "How many people watched the game in Macau?", where Macau is an OOV entity. To  When was the game with 2,500 participants?How many people watched the game with 3,000 participants? Figure 11: Large knowledge source simulation help understand how the model knows Macau is a city, we give its weights visualization in Figure 10. Interestingly, the model first checks the host city field in Executor-3, and then host country in Executor-4, which suggests that the model learns to scan all possible fields where the OOV entity may belong to.An important direction in semantic parsing research is to scale to large knowledge source [3,11]. In this set of experiments we simulate a test case to evaluate Neural Enquirer's ability to generalize to large knowledge source. We train a model on tables whose field sets are either F 1 , F 2 , . . . , F 5 , where F i (with |F i | = 5) is a subset of the entire set F T . We then test the model on tables with all fields F T and queries whose fields span multiple subsets F i . Figure 11 illustrates the setting. Note that all testing queries exhibit field combinations unseen in the training data, to mimic the difficulty the system often encounter when scaling to large knowledge source, which usually poses great challenge on model's generalization ability.We then train and test the model only on a new dataset of the first three types of relatively simple queries (namely Select Where, Superlative and Where Superlative). The sizes of training/testing splits are 75,000 and 30,000, with equal numbers for different query types. Table 3 lists the results. Neural Enquirer still maintains a reasonable performance even when the compositionality of testing queries is previously unseen, showing the model's generalization ability in tackling unseen query patterns through composition of familiar ones, and hence the potential to scale to larger and unseen knowledge sources.Our work falls into the research area of Semantic Parsing, where the key problem is to parse Natural Language queries into logical forms executable on KBs. Classical approaches for Semantic Parsing can be broadly divided into two categories. The first line of research resorts to the power of grammatical formalisms (e.g., Combinatory Categorial Grammar) to parse NL queries and generate corresponding logical forms, which requires curated/learned lexicons defining the correspondence between NL phrases and symbolic constituents [17,7,1,18]. The model is tuned with annotated logical forms, and is capable of recovering complex semantics from data, but often constrained on a specific domain due to scalability issues brought by the crisp grammars and the lack of annotated training data. Another line of research takes a semi-supervised learning approach, and adopts the results of query execution (i.e., answers) as supervision signal [5,3,10,11,12]. The parsers, designed towards this new learning paradigm, take different types of forms, ranging from generic chart parsers [3,11] to more specifically engineered, task-oriented ones [12,8]. Semantic parsers in this category often scale to open domain knowledge sources, but lack the ability of understanding compositional queries because of the intractable search space incurred by the flexibility of parsing algorithms. Our work follows this line of research in using query answers as indirect supervision to facilitate end-to-end training using QA tasks, but performs semantic parsing in distributional spaces, where logical forms are "neuralized" to an executable distributed representation. Our work is also related to the recent advances of modeling symbolic computation using Deep Neural Networks. Pioneered by the development of Neural Turing Machines (NTMs) [6], this line of research studies the problem of using differentiable neural networks to perform "hard" symbolic execution. As an independent line of research with similar flavor, Zaremba et al. [15] designed a LSTM-RNN to execute simple Python programs, where the parameters are learned by comparing the neural network output and the correct answer. Our work is related to both lines of work, in that like NTM, we heavily use external memory and flexible way of processing (e.g., the attention-based reading in the operations in Reader) and like [15], Neural Enquirer learns to execute a sequence with complicated structure, and the model is tuned from the executing them. As a highlight and difference from the previous work, we have a deep architecture with multiple layer of external memory, with the neural network operations highly customized to querying KB tables.Perhaps the most related work to date is the recently published Neural Programmer proposed by Neelakantan et al. [9], which studies the same task of executing queries on tables with Deep Neural Networks. Neural Programmer uses a neural network model to select operations during query processing. While the query planning (i.e., which operation to execute at each time step) phase is modeled softly using neural networks, the symbolic operations are predefined by users. In contrast Neural Enquirer is fully distributional: it models both the query planning and the operations with neural networks, which are jointly optimized via end- to-end training. Our Neural Enquirer model learns symbolic operations using data-driven approach, and demonstrates that a fully neural, end-to-end differentiable system is capable of modeling and executing compositional arithmetic and logic operations upto certain level of complexity.In this paper we propose Neural Enquirer, a fully neural, end-to-end differentiable network that learns to execute queries on tables. We present results on a set of synthetic QA tasks to demonstrate the ability of Neural Enquirer to answer fairly complicated compositional queries across multiple tables. In the future we plan to advance this work in the following directions. First we will apply Neural Enquirer to natural language questions and natural language answers, where both the input query and the output supervision are noisier and less informative. Second, we are going to scale to real world QA task as in [11], for which we have to deal with a large vocabulary and novel predicates. Third, we are going to work on the computational efficiency issue in query execution by heavily borrowing the symbolic operation.We use a bidirectional RNN as the Query Encoder, which consists of a forward GRU and a backward GRU. Given the sequence of word embeddings of Q: {x 1 , x 2 , . . . , x T }, at each time step t, the forward GRU computes the hidden state h t as follows:where W, W z , W r , U, U z , U r are parametric matrices, 1 the column vector of all ones, and • element-wise multiplication. The backward GRU reads the sequence in reverse order. We concatenate the last hidden states given by the two GRUs as the vectorial representation q of the query.We compared the efficiency of Neural Enquirer and Sempre (baseline) in training by plotting the accuracy on testing data by training time. Figure 12 illustrates the results. We train Neural Enquirer-CPU and Sempre on a machine with Intel Core i7-3770@3.40GHz and 16GB memory, while Neural Enquirer-GPU is tuned on Nvidia Tesla K40. Neural Enquirer-CPU is 10 times faster than Sempre, and Neural Enquirer-GPU is 100 times faster. Basically, Neural Enquirer-M assigns an executor to each table T k in every execution layer denoted as Executor-( k). Figure 13 pictorially illustrates Executor-( 1) and Executor-( K) working on   Table-1 Memory Layer-( -1) for Table-    We present preliminarily results for Neural Enquirer-M, which we evaluated on SQL-like Se- lect Where logical forms (like F 1 , F 2 in Table 1). We sampled a dataset of 100K examples, with each example having two tables as in Figure 15. Out of all Select Where queries, roughly half of the queries (denoted as "Join") require joining the two tables to derive answers. We tested on a model with three executors. Table 4 lists the results. The accuracy of join queries is lower than that of non-join queries, which is caused by additional interaction between the two tables involved in answering join queries.Query Type Non-Join Join Overall Accuracy 99.7% 81.5% 91.3% Table 4: Accuracies of Select Where queries on two tablesWe find that Neural Enquirer-M is capable of identifying that the country field is the foreign key linking the two tables. Figure 16 illustrates the attention weights for a correctly answered join Executor-(1, 1) c o u n t r y c o n t in e n t p o p u la t io n c o u n t r y _ s iz eExecutor- (1,2) c o u n tr y y e a r h o s t_ c it y # _ p a r ti c ip a n ts # _ m e d a ls # _ d u r a ti o n # _ a u d ie n c eExecutor-(2, 1) c o u n t r y c o n t in e n t p o p u la t io n c o u n t r y _ s iz eExecutor-(2, 2)Executor-(3, 1)Executor-(3, 2)Figure 16: Weights visualization of query Q 9query Q 9 . Although the query does not contain any hints for the foreign key (country field), Executor- (1, 1) (the executor at Layer-1 on Table-1) operates on an ensemble of embeddings of the country and year fields, whose outputting row annotations (contain information of both the key country and the value year) are sent to Executor-(2, 2) to compare with the country field in Table-2. We posit that the result of comparison is stored in the row annotations of Executor-(2, 2) and subsequently sent to the executors at Layer-3 for computing the answer probability for each entry in the two tables.
