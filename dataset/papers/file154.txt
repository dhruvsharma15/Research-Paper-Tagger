Our main motivation is the work by Mnih et al. [2015], in which Q-learning [Watkins, 1989] is combined with a deep convolutional neural network [cf. LeCun et al., 2015]. The resulting deep Q network (DQN) algorithm learned to play a varied set of Atari 2600 games from the Arcade Learning Environment (ALE) [Bellemare et al., 2013], which was proposed as an evaluation framework to test general learning algorithms on solving many different interesting tasks. DQN was proposed as a singular solution, using a single set of hyperparameters, but the magnitudes and frequencies of rewards vary wildly between different games. To overcome this hurdle, the rewards and temporal- difference errors were clipped to [−1, 1]. For instance, in Pong the rewards are bounded by −1 and +1 while in Ms. Pac-Man eating a single ghost can yield a reward of up to +1600, but DQN clips the latter to +1 as well. This is not a satisfying solution for two reasons. First, such clipping introduces domain knowledge. Most games have sparse non-zero rewards outside of [−1, 1]. Clipping then results in optimizing the frequency of rewards, rather than their sum. This is a good heuristic in Atari, but it does not generalize to other domains. More importantly, the clipping changes the objective, sometimes resulting in qualitatively different policies of behavior.We propose a method to adaptively normalize the targets used in the learning updates. If these targets are guaranteed to be normalized it is much easier to find suitable hyperparameters. The proposed technique is not specific to DQN and is more generally applicable in supervised learning and reinforcement learning. There are several reasons such normalization can be desirable. First, sometimes we desire a single system that is able to solve multiple different problems with varying natural magnitudes, as in the Atari domain. Second, for multi-variate functions the normalization can be used to disentangle the natural magnitude of each component from its relative importance in the loss function. This is particularly useful when the components have different units, such as when we predict signals from sensors with different modalities. Finally, adaptive normalization can help deal with non-stationary. For instance, in reinforcement learning the policy of behavior can change repeatedly during learning, thereby changing the distribution and magnitude of the values.Many machine-learning algorithms rely on a-priori access to data to properly tune relevant hyper- parameters [Bergstra et al., 2011, Bergstra and Bengio, 2012, Snoek et al., 2012. However, it is much harder to learn efficiently from a stream of data when we do not know the magnitude of the function we seek to approximate beforehand, or if these magnitudes can change over time, as is for instance typically the case in reinforcement learning when the policy of behavior improves over time.Input normalization has long been recognized as important to efficiently learn non-linear approx- imations such as neural networks [LeCun et al., 1998], leading to research on how to achieve scale-invariance on the inputs [e.g., Ross et al., 2013, Ioffe and Szegedy, 2015, Desjardins et al., 2015. Output or target normalization has not received as much attention, probably because in super- vised learning data is commonly available before learning commences, making it straightforward to determine appropriate normalizations or to tune hyper-parameters. However, this assumes the data is available a priori, which is not true in online (potentially non-stationary) settings.Natural gradients [Amari, 1998] are invariant to reparameterizations of the function approximation, thereby avoiding many scaling issues, but these are computationally expensive for functions with many parameters such as deep neural networks. This is why approximations are regularly proposed, typically trading off accuracy to computation [Martens and Grosse, 2015], and sometimes focusing on a certain aspect such as input normalization [Desjardins et al., 2015, Ioffe andSzegedy, 2015]. Most such algorithms are not fully invariant to rescaling the targets.In the Atari domain several algorithmic variants and improvements for DQN have been proposed [van Hasselt et al., 2016, Bellemare et al., 2016, Schaul et al., 2016, Wang et al., 2016, as well as alternative solutions [Liang et al., 2016, Mnih et al., 2016. However, none of these address the clipping of the rewards or explicitly discuss the impacts of clipping on performance or behavior.Concretely, we consider learning from a stream of data {(X t , Y t )} ∞ t=1 where the inputs X t ∈ R n and targets Y t ∈ R k are real-valued tensors. The aim is to update parameters θ of a function f θ : R n → R k such that the output f θ (X t ) is (in expectation) close to the target Y t according to some loss l t (f θ ), for instance defined as a squared difference:. A canonical update is stochastic gradient descent (SGD). For a sample (X t , Y t ), the update is then θ t+1 = θ t − α∇ θ l t (f θ ), where α ∈ [0, 1] is a step size. The magnitude of this update depends on both the step size and the loss, and it is hard to pick suitable step sizes when nothing is known about the magnitude of the loss.An important special case is when f θ is a neural network [McCulloch andPitts, 1943, Rosenblatt, 1962], which are often trained with a form of SGD [Rumelhart et al., 1986], with hyperparameters that interact with the scale of the loss. Especially for deep neural networks [LeCun et al., 2015, Schmidhuber, 2015 large updates may harm learning, because these networks are highly non-linear and such updates may 'bump' the parameters to regions with high error.We propose to normalize the targets Y t , where the normalization is learned separately from the approximating function. We consider an affine transformation of the targets˜Ywhere Σ t and µ t are scale and shift parameters that are learned from data. The scale matrix Σ t can be dense, diagonal, or defined by a scalar σ t as Σ t = σ t I. Similarly, the shift vector µ t can contain separate components, or be defined by a scalar µ t as µ t = µ t 1. We can then define a loss on a normalized function g(X t ) and the normalized target˜Ytarget˜ target˜Y t . The unnormalized approximation for any input x is then given by f (x) = Σg(x) + µ, where g is the normalized function and f is the unnormalized function.At first glance it may seem we have made little progress. If we learn Σ and µ using the same algorithm as used for the parameters of the function g, then the problem has not become fundamentally different or easier; we would have merely changed the structure of the parameterized function slightly.Conversely, if we consider tuning the scale and shift as hyperparameters then tuning them is not fundamentally easier than tuning other hyperparameters, such as the step size, directly.Fortunately, there is an alternative. We propose to update Σ and µ according to a separate objective with the aim of normalizing the updates for g. Thereby, we decompose the problem of learning an appropriate normalization from learning the specific shape of the function. The two properties that we want to simultaneously achieve are (ART) to update scale Σ and shift µ such that Σ −1 (Y − µ) is appropriately normalized, and (POP) to preserve the outputs of the unnormalized function when we change the scale and shift.We discuss these properties separately below. We refer to algorithms that combine output-preserving updates and adaptive rescaling, as Pop-Art algorithms, an acronym for "Preserving Outputs Precisely, while Adaptively Rescaling Targets".Unless care is taken, repeated updates to the normalization might make learning harder rather than easier because the normalized targets become non-stationary. More importantly, whenever we adapt the normalization based on a certain target, this would simultaneously change the output of the unnormalized function of all inputs. If there is little reason to believe that other unnormalized outputs were incorrect, this is undesirable and may hurt performance in practice, as illustrated in Section 3. We now first discuss how to prevent these issues, before we discuss how to update the scale and shift.The only way to avoid changing all outputs of the unnormalized function whenever we update the scale and shift is by changing the normalized function g itself simultaneously. The goal is to preserve the outputs from before the change of normalization, for all inputs. This prevents the normalization from affecting the approximation, which is appropriate because its objective is solely to make learning easier, and to leave solving the approximation itself to the optimization algorithm.Without loss of generality the unnormalized function can be written aswhere h θ is a parametrized (non-linear) function, and g θ,W,b = Wh θ (x) + b is the normalized function. It is not uncommon for deep neural networks to end in a linear layer, and then h θ can be the output of the last (hidden) layer of non-linearities. Alternatively, we can always add a square linear layer to any non-linear function h θ to ensure this constraint, for instance initialized as W 0 = I and b 0 = 0.The following proposition shows that we can update the parameters W and b to fulfill the second desideratum of preserving outputs precisely for any change in normalization. , then the outputs of the unnormalized function f are preserved precisely in the sense that∀x .This and later propositions are proven in the appendix. For the special case of scalar scale and shift, with Σ ≡ σI and µ ≡ µ1, the updates to W and b become W new = (σ/σ new )W andAfter updating the scale and shift we can update the output of the normalized function g θ,W,b (X t ) toward the normalized output˜Youtput˜ output˜Y t , using any learning algorithm. Importantly, the normalization can be updated first, thereby avoiding harmful large updates just before they would otherwise occur. This observation will be made more precise in Proposition 2 in Section 2.2. Algorithm 1 is an example implementation of SGD with Pop-Art for a squared loss. It can be generalized easily to any other loss by changing the definition of δ. Notice that W and b are updated twice: first to adapt to the new scale and shift to preserve the outputs of the function, and then by SGD. The order of these updates is important because it allows us to use the new normalization immediately in the subsequent SGD update.A natural choice is to normalize the targets to approximately have zero mean and unit variance. For clarity and conciseness, we consider scalar normalizations. It is straightforward to extend to diagonal or dense matrices. If we have dataThis can be generalized to incremental updatesHere ν t estimates the second moment of the targets and β t ∈ [0, 1] is a step size. If ν t − µ 2 t is positive initially then it will always remain so, although to avoid issues with numerical precision it can be useful to enforce a lower bound explicitly by requiring ν t − µ 2 t ≥ with &gt; 0. For full equivalence to (3) we can use β t = 1/t. If β t = β is constant we get exponential moving averages, placing more weight on recent data points which is appropriate in non-stationary settings.A constant β has the additional benefit of never becoming negligibly small. Consider the first time a target is observed that is much larger than all previously observed targets. If β t is small, our statistics would adapt only slightly, and the resulting update may be large enough to harm the learning. If β t is not too small, the normalization can adapt to the large target before updating, potentially making learning more robust. In particular, the following proposition holds.Proposition 2. When using updates (4) to adapt the normalization parameters σ and µ, the normal- ized targets are bounded for all t by for all t, then the normalized target is guaranteed to be in (−100, 100). Note that Proposition 2 does not rely on any assumptions about the distribution of the targets. This is an important result, because it implies we can bound the potential normalized errors before learning, without any prior knowledge about the actual targets we may observe.For a given differentiable function h θ , initialize θ. while learning do Observe input X and targetIt is an open question whether it is uniformly best to normalize by mean and variance. In the appendix we discuss other normalization updates, based on percentiles and mini-batches, and derive correspondences between all of these.We now step back and analyze the effect of the magnitude of the errors on the gradients when using regular SGD. This analysis suggests a different normalization algorithm, which has an interesting correspondence to Pop-Art SGD.We consider SGD updates for an unnormalized multi-layer function of form,is gradient of the squared loss, which we here call the unnormalized error. The magnitude of this update depends linearly on the magnitude of the error, which is appropriate when the inputs are normalized, because then the ideal scale of the weights depends linearly on the magnitude of the targets.Now consider the SGD update to the parameters of h θ ,is the Jacobian for h θ . The magnitudes of both the weights W and the errors δ depend linearly on the magnitude of the targets. This means that the magnitude of the update for θ depends quadratically on the magnitude of the targets. There is no compelling reason for these updates to depend at all on these magnitudes because the weights in the top layer already ensure appropriate scaling. In other words, for each doubling of the magnitudes of the targets, the updates to the lower layers quadruple for no clear reason.This analysis suggests an algorithmic solution, which seems to be novel in and of itself, in which we track the magnitudes of the targets in a separate parameter σ t , and then multiply the updates for all lower layers with a factor σ −2 t . A more general version of this for matrix scalings is given in Algorithm 2. We prove an interesting, and perhaps surprising, connection to the Pop-Art algorithm.where h θ is the same differentiable function in both cases, and the functions are initialized identically, using Σ 0 = I and µ = 0, and the same initial θ 0 , W 0 and b 0 . Consider updating the first function using Algorithm 1 (Pop-Art SGD) and the second using Algorithm 2 (Normalized SGD). Then, for any sequence of non-singular scales {Σ t } ∞ t=1 and shifts {µ t } ∞ t=1 , the algorithms are equivalent in the sense that 1) the sequences {θ t } ∞ t=0 are identical, 2) the outputs of the functions are identical, for any input.The proposition shows a duality between normalizing the targets, as in Algorithm 1, and changing the updates, as in Algorithm 2. This allows us to gain more intuition about the algorithm. In particular,  in Algorithm 2 the updates in top layer are not normalized, thereby allowing the last linear layer to adapt to the scale of the targets. This is in contrast to other algorithms that have some flavor of adaptive normalization, such as RMSprop [Tieleman and Hinton, 2012], AdaGrad [Duchi et al., 2011], and Adam [Kingma and Adam, 2015] that each component in the gradient by a square root of an empirical second moment of that component. That said, these methods are complementary, and it is straightforward to combine Pop-Art with other optimization algorithms than SGD.We first analyze the effect of rare events in online learning, when infrequently a much larger target is observed. Such events can for instance occur when learning from noisy sensors that sometimes captures an actual signal, or when learning from sparse non-zero reinforcements. We empirically compare three variants of SGD: without normalization, with normalization but without preserving outputs precisely (i.e., with 'Art', but without 'Pop'), and with Pop-Art.  for Art). The faster tracking of statistics protects Pop-Art from the large spikes, while the output preservation avoids invalidating the outputs for smaller targets. We ran experiments with RMSprop but left these out of the figure as the results were very similar to SGD.An important motivation for this work is reinforcement learning with non-linear function approxima- tors such as neural networks (sometimes called deep reinforcement learning). The goal is to predict and optimize action values defined as the expected sum of future rewards. These rewards can differ arbitrarily from one domain to the next, and non-zero rewards can be sparse. As a result, the action values can span a varied and wide range which is often unknown before learning commences.Mnih et al. [2015] combined Q-learning with a deep neural network in an algorithm called DQN, which impressively learned to play many games using a single set of hyper-parameters. However, as discussed above, to handle the different reward magnitudes with a single system all rewards were clipped to the interval [−1, 1]. This is harmless in some games, such as Pong where no reward is ever higher than 1 or lower than −1, but it is not satisfactory as this heuristic introduces specific domain knowledge that optimizing reward frequencies is approximately is useful as optimizing the total score. However, the clipping makes the DQN algorithm blind to differences between certain actions, such as the difference in reward between eating a ghost (reward &gt;= 100) and eating a pellet (reward = 25) in Ms. Pac-Man. We hypothesize that 1) overall performance decreases when we turn off clipping, because it is not possible to tune a step size that works on many games, 2) that we can regain much of the lost performance by with Pop-Art. The goal is not to improve state-of-the-art performance, but to remove the domain-dependent heuristic that is induced by the clipping of the rewards, thereby uncovering the true rewards.We ran the Double DQN algorithm [van Hasselt et al., 2016] in three versions: without changes, without clipping both rewards and temporal difference errors, and without clipping but additionally using Pop-Art. The targets are the cumulation of a reward and the discounted value at the next state:   DQN and Double DQN), and right to using Pop-Art instead of clipping. Each faint dashed lines corresponds to the median norms (where the median is taken over time) on one game. The shaded areas correspond to 50%, 90%, and 95% of games.Without clipping the rewards, Pop-Art produces a much narrower band within which the gradients fall. Across games, 95% of median norms range over less than two orders of magnitude (roughly between 1 and 20), compared to almost four orders of magnitude for clipped Double DQN, and more than six orders of magnitude for unclipped Double DQN without Pop-Art. The wide range for the latter shows why it is impossible to find a suitable step size with neither clipping nor Pop-Art: the updates are either far too small on some games or far too large on others.After 200M frames, we evaluated the actual scores of the best performing agent in each game on 100 episodes of up to 30 minutes of play, and then normalized by human and random scores as described by Mnih et al. [2015]. Figure 1 shows the differences in normalized scores between (clipped) Double DQN and Double DQN with Pop-Art.The main eye-catching result is that the distribution in performance drastically changed. On some games (e.g., Gopher, Centipede) we observe dramatic improvements, while on other games (e.g., Video Pinball, Star Gunner) we see a substantial decrease. For instance, in Ms. Pac-Man the clipped Double DQN agent does not care more about ghosts than pellets, but Double DQN with Pop-Art learns to actively hunt ghosts, resulting in higher scores. Especially remarkable is the improved performance on games like Centipede and Gopher, but also notable is a game like Frostbite which went from below 50% to a near-human performance level. Raw scores can be found in the appendix.   Some games fare worse with unclipped rewards because it changes the nature of the problem. For instance, in Time Pilot the Pop-Art agent learns to quickly shoot a mothership to advance to a next level of the game, obtaining many points in the process. The clipped agent instead shoots at anything that moves, ignoring the mothership.However, in the long run in this game more points are scored with the safer and more homogeneous strategy of the clipped agent. One reason for the disconnect between the seemingly qualitatively good behavior combined with lower scores is that the agents are fairly myopic: both use a discount factor of γ = 0.99, and therefore only optimize rewards that happen within a dozen or so seconds into the future.On the whole, the results show that with Pop-Art we can successfully remove the clipping heuristic that has been present in all prior DQN variants, while retaining overall performance levels. Double DQN with Pop-Art performs slightly better than Double DQN with clipped rewards: on 32 out of 57 games performance is at least as good as clipped Double DQN and the median (+0.4%) and mean (+34%) differences are positive.We have demonstrated that Pop-Art can be used to adapt to different and non-stationary target magnitudes. This problem was perhaps not previously commonly appreciated, potentially because in deep learning it is common to tune or normalize a priori, using an existing data set. This is not as straightforward in reinforcement learning when the policy and the corresponding values may repeatedly change over time. This makes Pop-Art a promising tool for deep reinforcement learning, although it is not specific to this setting.We saw that Pop-Art can successfully replace the clipping of rewards as done in DQN to handle the various magnitudes of the targets used in the Q-learning update. Now that the true problem is exposed to the learning algorithm we can hope to make further progress, for instance by improving the exploration [Osband et al., 2016], which can now be informed about the true unclipped rewards. For the experiments described in Section 4 in the main paper, we closely followed the setup described in Mnih et al. [2015] and van Hasselt et al. [2016]. In particular, the Double DQN algorithm is identical to that described by van Hasselt et al. The shown results were obtained by running the trained agent for 30 minutes of simulated play (or 108,000 frames). This was repeated 100 times, where diversity over different runs was ensured by a small probability of exploration on each step ( exploration with = 0.01), as well as by performing up to 30 'no-op' actions, as also used and described by Mnih et al. In summary, the evaluation setup was the same as used by Mnih et al., except that we allowed more evaluation time per game (30 minutes instead of 5 minutes), as also used by Wang et al. [2016].The results in Figure 2 were obtained by normalizing the raw scores by first subtracting the score by a random agent, and then dividing by the absolute difference between human and random agents, such that score normalized ≡ score agent − score random |score human − score random | .The raw scores are given below, in Table 1.We can change the variance of the normalized targets to influence the magnitudes of the updates. For a desired standard deviation of s &gt; 0, we can usewith the updates for ν t and µ t as normal. It is straightforward to show that then a generalization of Proposition 2 holds with a bound ofThis additional parameter is for instance useful when we desire fast tracking in non-stationary problems. We then want a large step size α, but without risking overly large updates. (1 − β)/β when we either change β while keeping s = 1 fixed (magenta curve) or we change s while keeping β = 0.01 fixed (black straight line).The new parameter s may seem superfluous because increasing the normalization step size β also reduces the hard bounds on the normalized targets. However, β additionally influences the distribution of the normalized targets. The histograms in the left-most plot in Figure 2 show what happens when we try to limit the magnitudes using only β. The red histogram shows normalized targets where the unnormalized targets come from a normal distribution, shown in blue. The normalized targets are contained in [−1, 1], but the distribution is very non-normal even though the actual targets are normal. Conversely, the red histogram in the middle plot shows that the distribution remains approximately normal if we instead use s to reduce the magnitudes. The right plot shows the effect on the variance of normalized targets for either approach. When we change β while keeping s = 1 fixed, the variance of the normalized targets can drop far below the desired variance of one (magenta curve). When we use change s while keeping β = 0.01 fixed, the variance remains predictably at approximately s (black line). The difference in behavior of the resulting normalization demonstrates that s gives us a potentially useful additional degree of freedom.Sometimes, we can simply roll the additional scaling s into the step size, such that without loss of generality we can use s = 1 and decrease the step size to avoid overly large updates. However, sometimes it is easier to separate the magnitude of the targets, as influenced by s, from the magnitude of the updates, for instance when using an adaptive step-size algorithm. In addition, the introduction of an explicit scaling s allows us to make some interesting connections to normalization by percentiles, in the next section.Instead of normalizing by mean and variance, we can normalize such that a given ratio p of normalized targets is inside the predetermined interval. The per-output objective is thenFor normally distributed targets, there is a direct correspondence to normalizing by means and variance.  We now discuss a concrete algorithm to obtain normalization by percentiles. Let Y (n) t denote order statistics of the targets up to time t, Solving for σ t and µ t gives, andIn the special case where p = 1 we getWe are then guaranteed that all normalized targets fall in [−1, 1], but this could result in an overly conservative normalization that is sensitive to outliers and may reduce the overall magnitude of the updates too far. In other words, learning will then be safe in the sense that no updates will be too big, but it may be slow because many updates may be very small. In general it is probably typically better to use a ratio p &lt; 1.Exact order statistics are hard to compute online, because we would need to store all previous targets. To obtain more memory-efficient online updates for percentiles we can store two values y min t and y max t , which should eventually have the property that a proportion of (1 − p)/2 values is larger than y max t and a proportion of (1 − p)/2 values is smaller than y min t , such thatThis can be achieved asymptotically by updating y where the indicator function I(·) is equal to one when its argument is true and equal to zero otherwise.If the step size β t is too small it will take long for the updates to converge to appropriate values. In practice, it might be better to let the magnitude of the steps depend on the actual errors, such that the update takes the form of an asymmetrical least-squares update [Newey andPowell, 1987, Efron, 1991].Online normalization by mean and variance with minibatches {Y t,1 , . . . , Y t,B } of size B can be achieved by using the updates, and, whereAnother interesting possibility is to update y This fact connects the online minibatch updates (9) to normalization by percentiles. For instance, a minibatch size of B = 20 would correspond roughly to online percentile updates with p = 19/21 ≈ 0.9 and, by Proposition 4, to a normalization by mean and variance with a s ≈ 0.6. These different normalizations are not strictly equivalent, but may behave similarly in practice.Proposition 6 quantifies an interesting correspondence between minibatch updates and normalizing by percentiles. Although the fact as stated holds only for uniform targets, the proportion of normalized targets in the interval [−1, 1] more generally becomes larger when we increase the minibatch size, just as when we increase p or decrease s, potentially resulting in better robustness to outliers at the possible expense of slower learning.When using constant step sizes it is useful to be aware of the start of learning, to trust the data rather than arbitrary initial values. This can be done by using a step size as defined in the following fact.Proposition 7. Consider a recency-weighted running average ¯ z t updated from a stream of data {Z t } ∞ t=1 using ¯ z t = (1 − β t )¯ z t−1 + β t Z t , with β t defined byThen 1) the relative weights of the data in Z t are the same as when using a constant step size β, and 2) the estimate ¯ z t does not depend on the initial value ¯ z 0 .A similar result was derived to remove the effect of the initialization of certain parameters by Kingma and Ba [2014] for a stochastic optimization algorithm called Adam. In that work, the initial values are assumed to be zero and a standard exponentially weighted average is explicitly computed and stored, and then divided by a term analogous to 1 − (1 − β) t . The step size (10) corrects for any initialization in place, without storing auxiliary variables, but for the rest the method and its motivation are very similar.Alternatively, it is possible to initialize the normalization safely, by choosing a scale that is relatively high initially. This can be beneficial when at first the targets are relatively small and noisy. If we would then use the step size in (10), the updates would treat these initial observations as important, and would try to fit our approximating function to the noise. A high initialization (e.g., ν 0 = 10 4 or ν 0 = 10 6 ) would instead reduce the effect of the first targets on the learning updates, and would instead use these only to find an appropriate normalization. Only after finding this normalization the actual learning would then commence.Sometimes it makes sense to apply the normalization not to the output of the network, but at a lower level. For instance, the i th output of a neural network with a soft-max on top can be writtenwhere W is the weight matrix of the last linear layer before the soft-max. The actual outputs are already normalized by using the soft-max, but the outputs Wh θ (X) + b of the layer below the soft-max may still benefit from normalization. To determine the targets to be normalized, we can either back-propagate the gradient of our loss through the soft-max or invert the function.More generally, we can consider applying normalization at any level of a hierarchical non-linear function. This seems a promising way to counteract undesirable characteristics of back-propagating gradients, such as vanishing or exploding gradients [Hochreiter, 1998].In addition, normalizing gradients further down in a network can provide a straightforward way to combine gradients from different sources in more complex network graphs than a standard feedforward multi-layer network. First, the normalization allows us to normalize the gradient from each source separately before merging gradients, thereby avoiding one source to fully drown out any others and allowing us to weight the gradients by actual relative importance, rather than implicitly relying on the current magnitude of each as a proxy for this. Second, the normalization can prevent undesirably large gradients when many gradients come together at one point of the graph, by normalizing again after merging gradients., Σ is a k × k matrix, µ and b are k-element vectors, and W is a k × m matrix. Consider any change of the scale and shift parameters from Σ to Σ 2 and from µ to µ 2 , where Σ 2 is non-singular. If we then additionally change the parameters W and b to W 2 and b 2 , defined bythen the outputs of the unnormalized function f are preserved precisely in the sense thatProof. The stated result follows fromProposition 2. When using updates (4) to adapt the normalization parameters σ and µ, the normal- ized target σis bounded for all t byProof.The inequality follows from the fact that ν t−1 ≥ µ , the algorithms are equivalent in the sense that 1) the sequences {θ t } ∞ t=0are identical, 2) the outputs of the functions are identical, for any input.Proof. Let θ then it must follow that Finally, we put everything together and note that f Proof. For any µ and σ, the normalized targets are distributed according to a normal distribution because the targets themselves are normally distributed and the normalization is an affine transforma- tion. For a normal distribution with mean zero and variance v, the values 1 and −1 are both exactly 1/ √ v standard deviations from the mean, implying that the ratio of data between these points iswhereis the standard normal cumulative distribution. The normalization by mean and variance is then equivalent to a normalization by percentiles with a ratio p defined bywhere we used the fact that erf is odd, such that erf(x) = − erf(−x).∞ t=1 β t and ∞ t=1 β 2 t , and the distribution of targets is stationary, then the updatesconverge to values such thatProof. Note thatso this is a fixed point of the update. Note further that the variance of the stochastic update is finite, and that the expected direction of the updates is towards the fixed point, so that this fixed point is an attractor. The conditions on the step sizes ensure that the fixed point is reachable ( ∞ t=1 β t = ∞) and that we converge upon it in the limit ( ∞ t=1 β 2 t &lt; ∞). For more detail and weaker conditions, we refer to reader to the extensive literature on stochastic approximation [Robbins andMonro, 1951, Kushner andYin, 2003]. The proof for the update for y min t is exactly analogous.   
