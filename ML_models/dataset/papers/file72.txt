We address an important problem in sequence-to-sequence (Seq2Seq) learning referred to as copying, in which cer- tain segments in the input sequence are selectively replicated in the output se- quence. A similar phenomenon is ob- servable in human language communica- tion. For example, humans tend to re- peat entity names or even long phrases in conversation. The challenge with re- gard to copying in Seq2Seq is that new machinery is needed to decide when to perform the operation. In this paper, we incorporate copying into neural network- based Seq2Seq learning and propose a new model called COPYNET with encoder- decoder structure. COPYNET can nicely integrate the regular way of word gener- ation in the decoder with the new copy- ing mechanism which can choose sub- sequences in the input sequence and put them at proper places in the output se- quence. Our empirical study on both syn- thetic data sets and real world data sets demonstrates the efficacy of COPYNET. For example, COPYNET can outperform regular RNN-based model with remark- able margins on text summarization tasks.Seq2Seq is essentially an encoder-decoder model, in which the encoder first transform the input se- quence to a certain representation which can then transform the representation into the output se- quence. Adding the attention mechanism (Bahdanau et al., 2014) to Seq2Seq, first proposed for automatic alignment in machine translation, has led to significant improvement on the perfor- mance of various tasks (Shang et al., 2015;Rush et al., 2015). Different from the canonical encoder- decoder architecture, the attention-based Seq2Seq model revisits the input sequence in its raw form (array of word representations) and dynamically fetches the relevant piece of information based mostly on the feedback from the generation of the output sequence.In this paper, we explore another mechanism important to the human language communication, called the "copying mechanism". Basically, it refers to the mechanism that locates a certain seg- ment of the input sentence and puts the segment into the output sequence. For example, in the following two dialogue turns we observe differ- ent patterns in which some subsequences (colored blue) in the response (R) are copied from the input utterance (I):as we expected. R: What do you mean by "doesn't perform copying mechanism is closer to the rote memo- rization in language processing of human being, deserving a different modeling strategy in neural network-based models. We argue that it will ben- efit many Seq2Seq tasks to have an elegant unified model that can accommodate both understanding and rote memorization. Towards this goal, we pro- pose COPYNET, which is not only capable of the regular generation of words but also the operation of copying appropriate segments of the input se- quence. Despite the seemingly "hard" operation of copying, COPYNET can be trained in an end-to- end fashion. Our empirical study on both synthetic datasets and real world datasets demonstrates the efficacy of COPYNET.The attention mechanism was first introduced to Seq2Seq ( Bahdanau et al., 2014) to release the burden of summarizing the entire source into a fixed-length vector as context. Instead, the atten- tion uses a dynamically changing context c t in the decoding process. A natural option (or rather "soft attention") is to represent c t as the weighted sum of the source hidden states, i.e.2 Background: Neural Models for Sequence-to-sequence Learning Seq2Seq Learning can be expressed in a prob- abilistic view as maximizing the likelihood (or some other evaluation metrics (Shen et al., 2015)) of observing the output (target) sequence given an input (source) sequence.where η is the function that shows the correspon- dence strength for attention, approximated usually with a multi-layer neural network (DNN). Note that in ( Bahdanau et al., 2014) the source sen- tence is encoded with a Bi-directional RNN, mak- ing each hidden state h τ aware of the contextual information from both ends.RNN-based Encoder-Decoder is successfully ap- plied to real world Seq2Seq tasks, first by Cho et al. (2014) and Sutskever et al. (2014), and then by Vinyals et al., 2015a).In the Encoder-Decoder framework, the source se- quence X = [x 1 , ..., x T S ] is converted into a fixed length vector c by the encoder RNN, i.e.where {h t } are the RNN states, c is the so-called context vector, f is the dynamics function, and φ summarizes the hidden states, e.g. choosing the last state h T S . In practice it is found that gated RNN alternatives such as LSTM (Hochreiter and Schmidhuber, 1997) or GRU ( Cho et al., 2014) of- ten perform much better than vanilla ones. The decoder RNN is to unfold the context vec- tor c into the target sequence, through the follow- ing dynamics and prediction model:From a cognitive perspective, the copying mech- anism is related to rote memorization, requiring less understanding but ensuring high literal fi- delity. From a modeling perspective, the copying operations are more rigid and symbolic, making it more difficult than soft attention mechanism to integrate into a fully differentiable neural model. In this section, we present COPYNET, a differen- tiable Seq2Seq model with "copying mechanism", which can be trained in an end-to-end fashion with just gradient descent.As illustrated in Figure 1, COPYNET is still an encoder-decoder (in a slightly generalized sense). The source sequence is transformed by Encoder into representation, which is then read by Decoder to generate the target sequence.where s t is the RNN state at time t, y t is the pre- dicted target symbol at t (through function g(·)) with y &lt;t denoting the history {y 1 , ..., y t−1 }. The prediction model is typically a classifier over the vocabulary with, say, 30,000 words.Encoder: Same as in ( Bahdanau et al., 2014), a bi-directional RNN is used to transform the source sequence into a series of hidden states with equal length, with each hidden state h t corresponding to word x t . This new representation of the source, {h 1 , ..., h T S }, is considered to be a short-term memory (referred to as M in the remainder of the paper), which will later be accessed in multiple ways in generating the target sequence (decoding).Prob("Jebara") = Prob("Jebara", g) + Prob("Jebara", c)  Figure 1: The overall diagram of COPYNET. For simplicity, we omit some links for prediction (see Sections 3.2 for more details).Decoder: An RNN that reads M and predicts the target sequence. It is similar with the canoni- cal RNN-decoder in ( Bahdanau et al., 2014), with however the following important differencesGiven the decoder RNN state s t at time t to- gether with M, the probability of generating any target word y t , is given by the "mixture" of proba- bilities as follows• Prediction: COPYNET predicts words based on a mixed probabilistic model of two modes, namely the generate-mode and the copy- mode, where the latter picks words from the source sequence (see Section 3.2);• State Update: the predicted word at time t−1 is used in updating the state at t, but COPY- NET uses not only its word-embedding but also its corresponding location-specific hid- den state in M (if any) (see Section 3.3 for more details);where g stands for the generate-mode, and c the copy mode. The probability of the two modes are given respectively by• Reading M: in addition to the attentive read to M, COPYNET also has"selective read" to M, which leads to a powerful hybrid of content-based addressing and location-based addressing (see both Sections 3.3 and 3.4 for more discussion).We assume a vocabulary V = {v 1 , ..., v N }, and use UNK for any out-of-vocabulary (OOV) word. In addition, we have another set of words X , for all the unique words in source sequence X = {x 1 , ..., x T S }. Since X may contain words not in V, copying sub-sequence in X enables COPY- NET to output some OOV words. In a nutshell, the instance-specific vocabulary for source X iswhere ψ g (·) and ψ c (·) are score functions for generate-mode and copy-mode, respectively, and Z is the normalization term shared by the two modes, Z = v∈V∪{UNK} e ψg(v) + x∈X e ψc(x) . Due to the shared normalization term, the two modes are basically competing through a softmax function (see Figure 1 for an illustration with ex- ample), rendering Eq.(4) different from the canon- ical definition of the mixture model (McLachlan and Basford, 1988). This is also pictorially illus- trated in Figure 2. The score of each mode is cal- culated:where e(y t−1 ) is the word embedding associated with y t−1 , while ζ(y t−1 ) is the weighted sum of hidden states in M corresponding to y t unk ζ(y t−1 ) = The illustration of the decoding proba- bility p(y t |·) as a 4-class classifier.where K is the normalization term which equals τ :x τ =y t−1Generate-Mode: The same scoring function as in the generic RNN encoder-decoder ( Bahdanau et al., 2014) is used, i.e.where W o ∈ R (N +1)×ds and v i is the one-hot in- dicator vector for v i .Copy-Mode: The score for "copying" the word x j is calculated aswhere W c ∈ R d h ×ds , and σ is a non-linear ac- tivation function, considering that the non-linear transformation in Eq. ( 8) can help project s t and h j in the same semantic space. Empirically, we also found that using the tanh non-linearity worked better than linear transformation, and we used that for the following experiments. When calculating the copy-mode score, we use the hidden states {h 1 , ..., h T S } to "represent" each of the word in the source sequence {x 1 , ..., x T S } since the bi- directional RNN encodes not only the content, but also the location information into the hidden states in M. The location informaton is important for copying (see Section 3.4 for related discussion).Note that we sum the probabilities of all x j equal to y t in Eq. (6) considering that there may be mul- tiple source symbols for decoding y t . Naturally we let p(y t , c|·) = 0 if y t does not appear in the source sequence, and set p(y t , g|·) = 0 when y t only appears in the source.p(x τ , c|s t−1 , M), considering there may exist multiple positions with y t−1 in the source sequence. In practice, ρ tτ is often con- centrated on one location among multiple appear- ances, indicating the prediction is closely bounded to the location of words.In a sense ζ(y t−1 ) performs a type of read to M similar to the attentive read (resulting c t ) with however higher precision. In the remainder of this paper, ζ(y t−1 ) will be referred to as selective read. ζ(y t−1 ) is specifically designed for the copy mode: with its pinpointing precision to the cor- responding y t−1 , it naturally bears the location of y t−1 in the source sequence encoded in the hidden state. As will be discussed more in Section 3.4, this particular design potentially helps copy-mode in covering a consecutive sub-sequence of words. If y t−1 is not in the source, we let ζ(y t−1 ) = 0.COPYNET updates each decoding state s t with the previous state s t−1 , the previous symbol y t−1 and the context vector c t following Eq. (2) for the generic attention-based Seq2Seq model. However, there is some minor changes in the y t−1 −→s t path for the copying mechanism. More specifically, y t−1 will be represented as [e(y t−1 ); ζ(y t−1 )] , We hypothesize that COPYNET uses a hybrid strategy for fetching the content in M, which com- bines both content-based and location-based ad- dressing. Both addressing strategies are coordi- nated by the decoder RNN in managing the atten- tive read and selective read, as well as determining when to enter/quit the copy-mode. Both the semantics of a word and its location in X will be encoded into the hidden states in M by a properly trained encoder RNN. Judging from our experiments, the attentive read of COPYNET is driven more by the semantics and language model, therefore capable of traveling more freely on M, even across a long distance. On the other hand, once COPYNET enters the copy-mode, the selec- tive read of M is often guided by the location in- formation. As the result, the selective read often takes rigid move and tends to cover consecutive words, including UNKs. Unlike the explicit de- sign for hybrid addressing in Neural Turing Ma- chine ( Graves et al., 2014;Kurach et al., 2015), COPYNET is more subtle: it provides the archi- tecture that can facilitate some particular location- based addressing and lets the model figure out the details from the training data for specific tasks.Location-based Addressing: With the location information in {h i }, the information flow in the source sequence, the copy-mode will con- tribute to the mixture model, and the gradient will more or less encourage the copy-mode; otherwise, the copy-mode is discouraged due to the compe- tition from the shared normalization term Z. In practice, in most cases one mode dominates.provides a simple way of "moving one step to the right" on X. More specifically, assuming the se- lective read ζ(y t−1 ) concentrates on the th wordin X, the state-update operation ζ(y t−1 ) update −−−→s t acts as "location ← location+1", making s t favor the ( th word in X in the prediction We report our empirical study of COPYNET on the following three tasks with different characteristics 1. A synthetic dataset on with simple patterns; 2. A real-world task on text summarization; 3. A dataset for simple single-turn dialogues. Handling Out-of-Vocabulary Words Although it is hard to verify the exact addressing strategy as above directly, there is strong evidence from our empirical study. Most saliently, a properly trained COPYNET can copy a fairly long segment full of OOV words, despite the lack of semantic infor- mation in its M representation. This provides a natural way to extend the effective vocabulary to include all the words in the source. Although this change is small, it seems quite significant empiri- cally in alleviating the OOV problem. Indeed, for many NLP applications (e.g., text summarization or spoken dialogue system), much of the OOV words on the target side, for example the proper nouns, are essentially the replicates of those on the source side.Dataset: We first randomly generate transforma- tion rules with 5∼20 symbols and variables x &amp; y, e.g.with {a b c d e f g h m} being regular symbols from a vocabulary of size 1,000. As shown in the table below, each rule can further produce a num- ber of instances by replacing the variables with randomly generated subsequences (1∼15 sym- bols) from the same vocabulary. We create five types of rules, including "x → ∅". The task is to learn to do the Seq2Seq transformation from the training instances. This dataset is designed to study the behavior of COPYNET on handling sim- ple and rigid patterns. Since the strings to repeat are random, they can also be viewed as some ex- treme cases of rote memorization.Rule-type Examples (e.g. x = i h k, y = j c)Although the copying mechanism uses the "hard" operation to copy from the source and choose to paste them or generate symbols from the vocab- ulary, COPYNET is fully differentiable and can be optimized in an end-to-end fashion using back- propagation. Given the batches of the source and target sequence {X} N and {Y } N , the objectives are to minimize the negative log-likelihood:where we use superscripts to index the instances. Since the probabilistic model for observing any target word is a mixture of generate-mode and copy-mode, there is no need for any additional labels for modes. The network can learn to co- ordinate the two modes from data. More specif- ically, if one particular word yExperimental Setting: We select 200 artificial rules from the dataset, and for each rule 200 in- stances are generated, which will be split into training (50%) and testing (50%  correct only when the generated sequence is ex- actly the same as the given one. It is clear from Table 1 that COPYNET signifi- cantly outperforms the other two on all rule-types except "x → ∅", indicating that COPYNET can ef- fectively learn the patterns with variables and ac- curately replicate rather long subsequence of sym- bols at the proper places.This is hard to Enc-Dec due to the difficulty of representing a long se- quence with very high fidelity. This difficulty can be alleviated with the attention mechanism. How- ever attention alone seems inadequate for handling the case where strict replication is needed.A closer look (see Figure 3 for example) re- veals that the decoder is dominated by copy-mode when moving into the subsequence to replicate, and switch to generate-mode after leaving this area, showing COPYNET can achieve a rather pre- cise coordination of the two modes.Dataset: We evaluate our model on the recently published LCSTS dataset ( Hu et al., 2015), a large scale dataset for short text summarization. The dataset is collected from the news medias on Sina Weibo 1 including pairs of (short news, summary) in Chinese. Shown in Table 2  Figure 3: Example output of COPYNET on the synthetic dataset. The heatmap represents the ac- tivations of the copy-mode over the input sequence (left) during the decoding process (bottom).Experimental Setting: We try COPYNET that is based on character (+C) and word (+W). For the word-based variant the word-segmentation is ob- tained with jieba 2 . We set the vocabulary size to 3,000 (+C) and 10,000 (+W) respectively, which are much smaller than those for models in ( Hu et al., 2015   The energy density of Magnesium ion batteries almost doubles that of lithium battery, which means that for the electric vehicles using of magnesium batteries will last longer even at pure electric power. But currently due to the technical barriers to the electrolyte, it is still too early for the mass production of it and replacing lithium batteries.. ______________________________________________________________Lithium batteries will be phased out, magnesium battery with energy density higher will be the future trend 发现 机遇 保持 创业 激情 。 1. master the skills; 2 Learn to finance ; 3. understand the law; 4. Be confident; 5. test+ trial; 6. understand the need of customers; 7 forecast + measure + ensure; 8. mentally prepared to fight all kinds of small bugs ; 9 discover opportunities and keep the passion of start-up.    are those words with copy-mode probability higher than the generate-mode. We also provide literal English translation for the document, the golden, and COPYNET, while omitting that for RNN context since the language is broken. one. One possible explanation is that a word- based model, even with a much larger vocabulary (50,000 words in Hu et al. (2015)), still has a large proportion of OOVs due to the large number of en- tity names in the summary data and the mistakes in word segmentation. COPYNET, with its ability to handle the OOV words with the copying mech- anism, performs however slightly better with the word-based variant.3. Similar with the synthetic dataset, we enlarge the dataset by filling the slots with suitable subsequence (e.g. name entities, dates, etc.)To make the dataset close to the real conversations, we also maintain a certain proportion of instances with the response that 1) do not contain entities or 2) contain entities not in the input.As shown in Figure 4, we make the following interesting observations about the summary from COPYNET: 1) most words are from copy-mode, but the summary is usually still fluent; 2) COPY- NET tends to cover consecutive words in the orig- inal document, but it often puts together seg- ments far away from each other, indicating a so- phisticated coordination of content-based address- ing and location-based addressing; 3) COPYNET handles OOV words really well: it can gener- ate acceptable summary for document with many OOVs, and even the summary itself often con- tains many OOV words. In contrast, the canonical RNN-based approaches often fail in such cases. It is quite intriguing that COPYNET can often find important parts of the document, a behav- ior with the characteristics of extractive summa- rization, while it often generate words to "con- nect" those words, showing its aspect of abstrac- tive summarization.Experimental Setting: We create two datasets: DS-I and DS-II with slot filling on 173 collected patterns. The main difference between the two datasets is that the filled substrings for training and testing in DS-II have no overlaps, while in DS-I they are sampled from the same pool. For each dataset we use 6,500 instances for training and 1,500 for testing. We compare COPYNET with canonical RNNSearch, both character-based, with the same model configuration in Section 5.  Table 4: The decoding accuracy on the two testing sets. Decoding is admitted success only when the answer is found exactly in the Top-K outputs.In this experiment we follow the work on neural dialogue model proposed in (Shang et al., 2015;Sordoni et al., 2015), and test COPYNET on single-turn dialogue. Basically, the neural model learns to generate a response to user's input, from the given (input, response) pairs as training instances.Dataset: We build a simple dialogue dataset based on the following three instructions:1. Dialogue instances are collected from Baidu Tieba 3 with some coverage of conversations of real life e.g., greeting and sports, etc.hi, my name is x → hi, x are mined from the set, with possibly multi- ple responding patterns to one input.We compare COPYNET and RNNSearch on DS-I and DS-II in terms of top-1 and top-10 ac- curacy (shown in Table 4), estimating respectively the chance of the top-1 or one of top-10 (from beam search) matching the golden. Since there are often many good responses to an input, top- 10 accuracy appears to be closer to the real world setting.As shown in Table 4, COPYNET significantly outperforms RNNsearch, especially on DS-II. It suggests that introducing the copying mechanism helps the dialogue system master the patterns in dialogue and correctly identify the correct parts of input, often proper nouns, to replicate in the re- sponse. Since the filled substrings have no over- laps in DS-II, the performance of RNNSearch drops significantly as it cannot handle words un- seen in training data. In contrast, the performance of COPYNET only drops slightly as it has learned to fill the slots with the copying mechanism and relies less on the representation of the words.As indicated by the examples in Figure 5, COPY- NET accurately replicates the critical segments from the input with the copy-mode, and generates Figure 5: Examples from the testing set of DS-II shown as the input text and golden, with the outputs of RNNSearch and CopyNet. Words in red rectangles are unseen in the training set. The highlighted words (with different colors) are those words with copy-mode probability higher than the generate-mode. Green cirles (meaning correct) and red cross (meaning incorrect) are given based on human judgment on whether the response is appropriate. the rest of the answers smoothly by the generate- mode. Note that in (2) and (3), the decoding se- quence is not exactly the same with the standard one, yet still correct regarding to their meanings. In contrast, although RNNSearch usually gener- ates answers in the right formats, it fails to catch the critical entities in all three cases because of the difficulty brought by the unseen words.Our work is partially inspired by the recent work of Pointer Networks ( Vinyals et al., 2015a), in which a pointer mechanism (quite similar with the proposed copying mechanism) is used to predict the output sequence directly from the input. In ad- dition to the difference with ours in application, ( Vinyals et al., 2015a) cannot predict outside of the set of input sequence, while COPYNET can naturally combine generating and copying.COPYNET is also related to the effort to solve the OOV problem in neural machine translation. Luong et al. (2015) introduced a heuristics to post- process the translated sentence using annotations on the source sentence. In contrast COPYNET ad- dresses the OOV problem in a more systemic way with an end-to-end model. However, as COPY- NET copies the exact source words as the output, it cannot be directly applied to machine translation. However, such copying mechanism can be natu- rally extended to any types of references except for the input sequence, which will help in appli- cations with heterogeneous source and target se- quences such as machine translation.The copying mechanism can also be viewed as carrying information over to the next stage without any nonlinear transformation. Similar ideas are proposed for training very deep neural networks in ( Srivastava et al., 2015;) for clas- sification tasks, where shortcuts are built between layers for the direct carrying of information.Recently, we noticed some parallel efforts to- wards modeling mechanisms similar to or related to copying. Cheng and Lapata (2016) devised a neural summarization model with the ability to ex- tract words/sentences from the source. Gulcehre et al. (2016) proposed a pointing method to han- dle the OOV words for summarization and MT. In contrast, COPYNET is more general, and not lim- ited to a specific task or OOV words. Moreover, the softmaxCOPYNET is more flexible than gating in the related work in handling the mixture of two modes, due to its ability to adequately model the content of copied segment.We proposed COPYNET to incorporate copy- ing into the sequence-to-sequence learning frame- work. For future work, we will extend this idea to the task where the source and target are in hetero- geneous types, for example, machine translation.
