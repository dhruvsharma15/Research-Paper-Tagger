In domains such as healthcare, genomics or social science there is high demand for data analysis that reveals causal relationships between independent and target variables. For example, doctors not only want models that accurately predict the status of patients, but also want to identify the factors that can improve it. The distinction between prediction and causation has at times been subject to debate in statistics and machine learning ( Breiman et al., 2001;Shmueli, 2010). While machine learning has focused mostly on prediction tasks, in many scientific domains pure prediction without considering the underlying causal mechanisms is considered unscientific (Shmueli, 2010). In this work, we propose a causal regularizer that balances causal interpretability and predictive power.We use the counterfactual causality framework (Pearl, 2000), in which one random variable X (e.g. red wine consumption) causes another variable Y (i.e., reduction in risk of heart attack) denoted as X → Y if experimental testing of X would be proven to change the distribution of Y ( Spirtes, 2010). But there may also be competing explanations of the observed correlation between X and Y because of confounding (e.g., people of high socio-economic status tend to drink more wine and this is related to other lifestyle factors that cause a reduction in heart attack) that need to be reconciled in assessing the likelihood that X → Y is true. Causal analytic methods can be used to prioritize what warrants testing in clinical trials among a diversity of hypotheses or as primary evidence if controlled trials are not feasible or desireable (e.g., climate science or health). In healthcare, in particular, it is common that an ensemble of many causal factors needs to occur simultaneously to have an effect on the target variable, a phenomenon we will call multivariate causation. Scalable methods are needed to explore the exponential combinations of the independent variables and different transformations in order to detect multivariate causal relationships.Methods for discovering causal relationships among multiple variables from observational data (Chickering, 2002;Kalisch and Bühlmann, 2007;Colombo et al., 2012) are largely based on the principle that any given set of causal relationships among multiple variables leaves well-defined marks in the joint distribution of the variables. However, when these methods are used for causal variable selection ( Guyon et al., 2007;Cawley, 2008;Bontempi and Meyer, 2010;Sun et al., 2015), the process becomes very sensitive to small changes in Figure 1: The proposed causal regularizer achieves significantly higher causality score, computed using ground truth causality. We compute the score for top k codes in the ranked list reported by three algorithms. The causal regularizer is also competitive in predictive performance, see Section 4 for more details.the joint distribution of variables and may exclude many causal variables due to noise or selection bias in the data.Our main idea is to design a causal regularizer to control the complexity of the statistical models and at the same time favor causal explanations. Compared to the two step procedure of causal variable selection followed by a multivariate regression/classification, the proposed approach performs joint causal variable selection and prediction, thus avoiding the statistically sensitive thresholding of the causality scores in the causal variable selection step. It allows few dependencies that cannot be explained via causation to still be included in the model, relaxing the variable selection procedure. Our technical contributions are as follows:1. We use causality detectors to construct a causal regularizer that can guide predictive models towards learning causal relationships between the independent and target variables. We theoretically quantify the impact of the accuracy of the causality detector on the causal accuracy of the regularized models.2. We propose a new non-linear predictive model regularized by our causal regularizer, which allows causally interpretable neural networks.3. Finally, we demonstrate that the proposed causal regularizer can be combined with neural representation learning techniques to efficiently detect multivariate causal hypotheses.The proposed framework scales linearly with the number of variables, as opposed to many previous causal methods. We applied the proposed algorithms to clinical predictive modeling problems using large EHR datasets: one on heart failure onset prediction and another on mortality prediction using the publicly available MIMIC III ( Johnson et al., 2016) dataset. Altogether, we analyzed the collective influence of 17,081 independent variables on heart failure and validated the results by having a clinical expert to manually review the findings in a blind setup. As shown in Figure 1, our proposed causally-regularized algorithm significantly outperforms the baseline algorithms in causality detection performance. We show a similar boost in the causality score of the detected multivariate causal hypotheses. Finally, we show that the proposed algorithms are also competitive in predictive performance on both datasets.We begin with description of pairwise causal analysis (X → Y ) of a single independent variable X on the target variable Y based on the independence of mechanisms (ICM) assumption and then extend the pairwise causality detector to perform multivariate causality analysis in the next section. While our proposed causal " #′ Figure 2: Common causal and anti-causal structures between two observed and one or more hidden variables. Under the algorithmic independence assumption, we can sample from the joint distribution of X and Y in each case and train a classifier to distinguish between these cases based on the (automatically learned) features of the joint distribution.regularizer can be constructed using any causality detection algorithm, a review of the ICM based methods, as the state of art causality detection algorithms, is helpful because they are the baseline algorithms in the experiments.We are interested in finding causal models where X causes Y , or Y causes X, or the two are confounded based on joint distribution of P (X, Y ). However, the pairwise causality analysis is infeasible for arbitrary joint distributions. Thus, we need to resort to additional assumptions on the nature of the causal relationships. Recently several algorithms have been proposed that distinguish between the cause and effect based on the natural assumption that steps in the process that generates the data are independent from each other, see ( Lemeire and Dirkx, 2006;Janzing et al., 2012;Daniusis et al., 2010;Lopez-Paz, 2016;Chalupka et al., 2016;Kocaoglu et al., 2016) and the references therein. In this work, we follow ( Lopez-Paz et al., 2016;Chalupka et al., 2016) to describe this causality detection approach. In the next subsections, we describe our novel causal regularizer designed based on this causality detection approach and its application in non-linear causality analysis and multivariate causal hypothesis generation.Conceptual description of the independence between the cause and the mechanism. ICM states that the two processes of generation of the cause and mapping from cause to effect are independent. In our case, we assume that when X → Y (X causes Y ), the probabilities P(Y | X) and P(X) are generated by independent higher-level distribution functions. Thus, we do not put assumptions on the functional form of the causal relationships between the variables of interest. ICM conforms to the scientific idea of Uniformitarianism (Gould, 1965) which, putting roughly, states that the laws of nature apply to all objects similarly. ICM can be described in both deterministic (Janzing and Scholkopf, 2010) and probabilistic ( Daniusis et al., 2010) sense; this work mainly uses the probabilistic interpretation.ICM can be used to generate samples from distributions that agree with the possible graphical models including two observed variables X and Y and an unobserved variable H shown in Figure 2, by requiring that the probability functions in the factorization of the joint distribution are independent from each other. The hidden variables can represent the other observed variables, critical in design of the regularizer in the next subsection. Chalupka et al. (2016) developed an analytical likelihood ratio test that decides between the causal and anticausal cases (Figures 2b and 2c). However, taking into account the confounded cases is analytically difficult. Nevertheless, it is possible to generate samples from the scenarios in Figure 2 under the ICM and train a classifier to learn to choose the max likelihood causal structure given samples from the joint P (X, Y ). This is the key idea of the causality detectors in ( Lopez-Paz et al., 2016;Chalupka et al., 2016) described in the rest of this section.Mathematical description of the causality detection algorithm. Formally, suppose we have m variables X i , each with dimensionality d i . For each variable we observe a sample of size n i denoted by, where y j are observations of a common target variable Y . Let S denote the set of all such samples. For each sample S i , we are interested in determining the binary label i ∈ {0, 1} which determines whether X i causes Y or not. In fact, we are interested in the function approximation problem of learning the mapping f : S → {0, 1}.Several approaches can learn such a mapping function. When X and Y are both discrete and finite, Chalupka et al. (2016) offer a means to construct the empirical joint distribution p i = p(X i , Y ) and train a supervised neural network mapping function f ( p i ) → i . Lopez-Paz et al. (2016) learn the representation S i → 1 ni ni j=1 φ(x i,j , y j ) and a neural network f 1 ni ni j=1 φ(x i,j , y j ) → i , followed by training both the representation leaning function φ(·, ·) and the classification network f (·) in a joint and supervised way. However, it is rare to have the true causal labels for training a causal detector. Rather, we generate synthetic datasets to represent the scenarios in Figure 2 based on the ICM assumption. The overall procedure is to generate samples from distributions p X,Y that are one of the ten possible scenarios in Figure 2. We need to select distributions that impose a minimum number of restriction on the data and the synthetically-generated distributions have statistics as similar as possible to those of our true data of interest. For example, in our datasets, the independent variables X are counts of the number of disease codes in patients' records (cf. Section 4). Thus, we sample X from a mixture of appropriate distributions for count data: the Zipf, Poisson, Uniform, and Bernoulli distributions. The hidden variable H and the response variable Y are sampled from the Dirichlet and Bernoulli distributions, respectively. Details of our sampling and training procedures are provided in Appendix B and Algorithm 1 there.Given the causality detector in Section 2, we propose the causal regularizer for linear models in 3.1. We demonstrate in Section 3.2 using a non-linear deep neural networks regularized by our causal regularizer, we can learn non-linear causal relationships between the independent and target variables. Finally, we show that the causal regularizer can efficiently explore the space of multivariate causal hypotheses and extract meaningful candidates for causality analysis.Using the causality detection methods in the previous section for causal variable selection ( Guyon et al., 2007;Cawley, 2008;Bontempi and Meyer, 2010;Sun et al., 2015) makes the variable selection process becomes very sensitive to small changes in the joint distribution of variables and may exclude many causal variables due to noise or selection bias in the data. Ideally, if the ICM holds and if we had access to the true joint distributions and could discriminate between causal and non-causal variables with perfect accuracy, the two-step procedure would be sufficient. But observational datasets are not usually an accurate representation of the true probabilistic generative process because of measurement error and selection bias, which can perturb the causality scores generated by the neural network causality detector.For example, consider the two-step analysis process of first finding the variables that cause Y from a list of variables X i for i = 1, . . . , n and then performing a sparse multivariate regression on the selected variables to prioritize the selected variables. This procedure is sensitive because our causality detection algorithm might give soft scores such as 0.5 + ε or 0.5 − ε to two variables X 1 and X 2 , respectively. These soft-scores can be interpreted as the probability that each variable is a cause of Y . If we use the two-step procedure, we will include X 1 in the regression model but not X 2 . However, X 2 could possibly contribute more to the predictive performance in presence of other variables in the multivariate regression. In other words, any hard cut-off for the purpose of two-step causal variable selection and regression will pose the question of "what should be the best cut-off threshold?"Instead, we propose a causally regularized regression approach, where this trade-off is performed smoothly via a regularization parameter. We select variables that are both causal with high probability and also significantly predictive.Causal Regularizer. Now, given Section 2, assume that we have a classifier that outputs c i = P[X i does not cause Y ], we can design the following regularizer to encourage learning a causal predictive model:is the loss function for prediction of Y given X 1 , . . . , X n . The above regularization term is the L 1 -norm version of the causal regularizer which will be used in our experiments. However, we can define L 2 -norm version similarly as m i=1 c i w 2 i . The first term in Eq. (1) is a multivariate analysis term, whereas the regularizer is constructed using a bivariate causality score of each independent variable X i and the target variable Y for i = 1, . . . , m. This does not create a problem because in the design of the causal regularizer we have implicitly included the other variables as hidden variables in the analysis to allow the regularizer to be used with multivariate regression. That is, the rest of the observed independent variables can be considered as hidden variables in our bivariate causality analysis which allows proper regularization. The proposed causal regularizer is also a decomposable regularizer which makes analysis of its theoretical properties easier ( Negahban et al., 2012).The interplay between causation and prediction has been studied recently, see RojasCarulla et al., 2015) and the references therein. In particular, the notion of a causal regularizer was previously recognized (Lopez-Paz, 2016, Page 181;Lopez-Paz et al., 2016) as possible, however a specific causal regularizer has never been developed and evaluated. Notice that using the score of a "causal-anticausal"-only classifier without including the confounding cases, as e.g. in ( Lopez-Paz et al., 2016), cannot properly regularize a multivariate model such as logistic regression. Moreover, a major novelty of our proposed causal regularizer is to do joint causal variable selection (the L 1 regularization) and prediction, but the idea in ( Lopez-Paz et al., 2016) cannot.The following theorem uses a simple setting to quantify the impact of the L 2 -norm based causal regularizer.where the noise variable ε is a zero mean random variable with variance γ 2 &lt; ∞ and a distribution that satisfies the regularity conditions of Theorem 3.2 in (White, 1982). We assume that X 1 causes Y but X 2 does not and its correlation with Y is due to an unobserved confounder. We have access to an imperfect causality detector with P[X 1 causes Y ] = 1 − and P[X 2 causes Y ] = for ∈ [0,1]. Without loss of generality, assume that β 1 , β 2 ≥ 0. Under this setting, the causality accuracy of an estimate β is defined as follows:Consider the fixed design setting where an i.i.d. sample of size n is drawn from the model as follows:where y ∈ R n , X ∈ R n×2 , and ε ∈ R n . For cleanness of the results, we study the orthonormal design setting where X X = nI 2×2 . Using this sample, we obtain two estimates for β: β R,λ and β C,λ which are the the result of L 2 -norm and L 2 -norm based causally regularized regression, respectively. Asymptotically, as n → ∞, we have the following results:where Φ(·) denotes the CDF of the unit Gaussian distribution.A proof is provided in Appendix A. To understand the result, considering several special cases can be helpful. When the causal detector is perfect ( = 0), we can rewrite C β C,λ as followsCompared to Eq. (3), we see a 1 + λ factor scaling of the causal coefficient β 1 against the non-causal coefficient β 2 in the nominator, increasing the chance of correct causality detection. That is, a perfect causality detector guarantees causal interpretability if the magnitude of λ outweights the predictive advantage of β 2 over β 1 . When the causal detector is random ( = 1/2), we can show that C β C,λ = C β R,λ . That is, a non-informative causality detector makes causal regularization equivalent to standard L 2 regularization. Finally, in the limit of large penalization coefficient, we obtain:The impact of the error rate of the causality detector in the nominator can be seen as linear scaling of the causal coefficient by (1 − and the non-causal factor by Another property of the causal regularizer is that the two-step analysis can be cast as a form of causal regularization where we use hard scores instead of soft scores. Consider the following setting: where c i = ε if c i ≤ 1/2 and 1 − ε otherwise. Now, consider the limiting case of ε → 0 and γε → λ. This case corresponds to the two-step procedure with L 1 regularized logistic regression.We demonstrate two key scenarios of using the causal regularizer as shown in Figure 3.Non-linear Modeling. The linear model in Eq. (1) assumes that the strength of the impact of each independent variable on the target variable is fixed. However, according to probabilistic view of causation (Pearl, 2000), the strength of causation can change from subject to subject. Thus, we need non-linear extensions of logistic regression that can be regularizerd by the causal regularizer and steered towards being causal.To address this problem, we seek neural network architectures that represent the impact of each independent variable by a single coefficient (that can change for each subject) and regularize the coefficients with the causal regularizer. In particular, we propose the following non-linear generalized linear model:where the embedding matrix E ∈ R q×m maps the input x ∈ R m to a lower dimensional representation space and the symbol denotes the element-wise product. The logistic sigmoid function σ maps the real values to the [0,1] interval. The term w x acts as the skip connection and is initialized by the result of the logistic regression. The embedding allows dealing with very large set of discrete concepts and can be initialized via techniques such as skip-gram ( Mikolov et al., 2013) or GloVe ( Pennington et al., 2014). The vector α(Ex) is computed using a Multilayer Perceptron (MLP).The model in Eq. (4) is a non-linear extension of logistic regression that is suitable for causal regularization. We can reorder the equations to write the right hand side of Eq. (4) as ω(x)x + b, where the new regression coefficient ω can change with every input. Each coordinate of the new regression coefficient can be calculated as   variability of ω i (x) for each input x enables us to perform individual causality analysis. For training, we can penalize the ω coefficients and minimize the following loss functionwhere L denotes the negative log-likelihood of the model described by Eq. (4). The change of the prediction vector with each sample x can be related to the probabilistic definition of causation (Pearl, 2000) in the sense that the strength of causality may change from a subject to another one.Multivariate Causal Hypothesis Generation. A key application of our proposed causal regularizer in conjunction with deep representation learning is to efficiently extract multivariate causal hypotheses from the data. Figure 3b shows an example of causal hypothesis generation where the hypotheses are generated via an MLP. We assume that there is a representation learning network with K-dimensional output h(x) ∈ I K , where I denotes the range of the output, for example I = (0, 1) for sigmoid and I = [0, ∞) for ReLU activation functions. Our goal is to force each dimension of h to be causal, thus each coordinate of h(x) can be used as a multivariate causal hypothesis. In particular, we aim at minimizing the following objective function:Our approach is to train an anti-causality detector based on (Lopez-Paz et al., 2016) and design the regularizer g(h(x)) based on its score. Then, as shown in Figure 3b, we can combine it with the neural network to regularize the coefficients of the last layer of the MLP which predicts the labels from h. The weights of the lower layers in h(x) are regularized using L 1 regularizer to make the generated causal hypotheses simple and interpretable.The learning process has two steps: First, the causality detector network g(h) is trained on a synthetic dataset with causal and anti-causal scenarios are labeled as = 0 and = 1, respectively. We select the non-linearity for h to be the logistic sigmoid function, thus we use Beta distribution for generating synthetic data for training of the causality classifier. In the second phase, the coefficients of g(h) are fixed and we train  We evaluate the proposed causal regularizer in Section 3.1 both in terms of its predictive and causal performance. Next, we compare the quality of the codes identified as causes of heart failure identified by different approaches. Finally, we evaluate performance of multivariate causal hypothesis generation by qualitatively analyzing the extracted hypotheses. We defer evaluation of the causality detection algorithms to Appendix B, as they are not the main contributions of this work. Table 1 lists the acronyms and symbols for techniques used in the experiments to improve the presentation.The Sutter Health heart failure (HF) dataset consists of Electronic Health Records of middle-aged adults collected by Sutter Health for study of heart failure. From the encounter records, medication orders, procedure orders and problem lists, we extracted visit records consisting of diagnosis, medication and procedure codes. We denote the set of such codes by C. Given a visit sequence v 1 , . . . , v T , we try to predict if the patient will be diagnosed with heart failure (HF) and identify the key causes of increase heart failure risk. To this end, 3,884 cases are selected and approximately 10 controls are selected for each case (28,903 controls). The case/control selection criteria are fully described in Appendix D. Cases have index dates to denote the date they are diagnosed with HF. Controls have the same index dates as their corresponding cases. We extract diagnosis codes, medication codes and procedure codes from the 18-month window before the index date. There are in total 17,081 number of unique medical codes in this dataset.  The MIMIC III dataset ( Johnson et al., 2016) is a publicly available dataset consisting of medical records of intensive care unit (ICU) patients over 11 years. We use a public query 2 to extract the binary mortality labels for the patients. Our goal is to use the codes in the patients' last visit to the ICU and predict their mortality outcome. Our dataset includes 46,520 patients out of whom 5810 have deceased (mortality=1). A totoal of 14,587 different medical codes are used in this dataset.Feature construction. Given the sequence of visits vT for patients i = 1, . . . , n, we create a feature vector x i ∈ N |C| 0 by counting the number of codes observed in the records of the ith patient. Given the large variations in the number of codes, we logarithmically bin the count data into 16 bins. The final data is in the form of (x i , y i ) where y i is ith patient's label; heart failure and mortality outcome in the heart failure and MIMIC III datasets, respectively.Training details. Because we generate synthetic datasets for training the causality detector neural networks, we can generate as many new batches of data for training and parameter tuning purposes as required. For training and parameter tuning of the models in Section 3, we perform the common 75%/10%/15% training/validation/test splits. The full details of the training procedure for the neural networks are given in Appendix C.  Table 2 shows the test accuracy of heart failure and mortality prediction in heart failure and MIMIC datasets, respectively. We have run each algorithm ten times and report the mean and standard deviation of the performance measures. As we can see, the proposed causal regularizer does not hurt the predictive performance, whereas the two-step procedure significantly reduces the accuracy. An interesting phenomenon, shown in Figure 4, is the relative robustness of the performance with respect to the value of the penalization parameter compared to the L 1 regularization case. This robustness comes at no surprise, because the causal regularizer assigns very small penalization coefficients to the causal variables and as we discussed in Section 3.1, only with very high values of penalization we can force all coefficients to become zero, see Figures 4c and 4f which show the sparsity results. The predictive robustness of the causal regularizer can be also partially attributed to the invariant prediction Peters et al. (2015) property of causal models. That is, the robustness can be due to the fact that the causal regularizer might match the true generative process of the dataset better than the flat L 1 regularizer and put the model under less pressure as we increase the penalization parameter. We demonstrate the predictive gain by nonlinCause in Figure  5a. Furthermore, the impact of changing the regularization parameter on the number of selected variables is visualized in Figures 8a and 8b in Appendix B.2.The risk factors for heart failure are well-studied in medical literature, making the heart failure condition an ideal case for study of causality. To evaluate the causality detection performance of the algorithms, we generate top 100 influential factors by each method. We ask a clinical expert to label each factor as "causal", "not-causal", and "potentially causal" and assign scores 1, 0, and 0.5 to them, respectively. To prevent bias by the expert, we ask him to label a single list of all unique codes in the three lists and use this list to find the scores for individual lists. Figure 1 shows the average causality score by each algorithm based on the labels provided by the medical expert. As expected, L 1 regularized logistic regression performs poorly, as it is susceptible to the impact of confounded variables. Performance of the causally regularized logistic regression is superior to the two step procedure, which suggests that picking factors that are both causal and highly predictive leads to better causality score. The result in Figure 1 together with the predictive results in Table  2 confirm that the causal regularizer can be efficiently used for finding few causal variables that are highly predictive of the target quantity.The qualitative advantages of the regularized approach can also be seen by the results in Table 5 in Appendix E. We have marked the disease codes that can potentially increase the risk of heart failure, but the predicted causality score c CD for them is lower than 0.5 and the two-step procedure would have eliminated from the predictors set (as shown in Table 6 in Appendix E). Thus, the causal regularizer approach is able to establish a balance between the prediction and causation and produce clinically more plausible results.We evaluate the performance of the proposed causal hypothesis generation against the case when we do not use any causal regularization. We generate two lists of top 30 hypotheses using two algorithms and ask our medical expert to label each hypothesis as causal, non-causal or possibly causal with corresponding scores of 1, 0, and 0.5. The results in Figure 5b shows that the causal regularizer can increase the causality score of the hypotheses by up to 20%. We also provide a qualitative analysis of the causal hypotheses generated by our algorithm by picking several hypotheses and showing that they are clinically meaningful. Three examples of multivariate causal hypotheses generated via causal regularizer and the description of their clinical meaning are shown in Table 3.We addressed the problem of exploring the high-dimensional causal hypothesis space in applications such as healthcare. We designed a causal regularizer that maximally steers predictive models towards causally explainable models. The proposed causal regularizer, based on our causality detector, does not increase the computational complexity of the L 1 regularizer and can be seamlessly integrated with a neural network to perform non-linear causality analysis. We also demonstrated the application of the proposed causal regularizer in generating multivariate causal hypotheses. Finally, we demonstrated the usefulness of the causal regularizer in detecting the risk factors of heart failure using an electronic health records dataset.The proof is established based on two results: First, establishing the connection between the two estimates and the ordinary least squares estimate and then using the known asymptotic normality results for maximum likelihood estimation under misspecification. We need the latter, because the noise distribution is not necessarily Gaussian in the theorem to allow causality detection.We can write both of the L 2 based causal regularization and Ridge regression in the following unified format:where D is a diagonal matrix diag (d 1 , d 2 ). It is equal to identity matrix (d 1 , d 2 ) = (1, 1) for the ridge regression and (d 1 , d 2 ) = ( 1 − for the causal regularization. Given this unified formulation, we can represent the estimates in the theorem in terms of the ordinary least squares estimate as follows:where). According to the asymptotic normality of the quasi-maximum likelihood estimation in (White, 1982), as n → ∞, the ordinary least squares estimate β OLS is normal with the following distribution :Given the results in Eqs. (7) and (8), we can find the distributions for the quantities of interest:where in the last step we have used the results on linear transformation of multivariate normal variables. Now, we can use the result in Eq. (9) to write:where Φ is the cdf of the unit Gaussian distribution. Substituting (d 1 , d 2 ) = (1, 1) for the ridge regression and (d 1 , d 2 ) = ( 1 − for the causal regularization, we obtain the result in the theorem.We first describe the sampling process for generating synthetic datasets used for training the causality detector algorithms in Section B.1. Next, evaluate the impact of the proposed sampling procedure on the quality of causality detection algorithms. Algorithm 1 summarizes the process described in Section 2.Given the data, perform the following steps:1. Generate data samples S i for i = 1, . . . , n train from p X,Y according to the ten cases in Figure 2.2. Assign label y = 0 to the cases in Figures 2b, 2d, 2g and 2i and y = 1 to the rest.3. Train a classifier f : S → [0, 1] to classify them as causation (label=1) or not-causation (label=0). Given the fact that this is a synthetic dataset, we know these labels and we can use supervised learning.4. On the test set, construct the test sample sets and use the classifier in step 3 to classify the example.Algorithm 1: The algorithm for constructing the causality detector. The structure of neural network classifier is given in Appendix C.As described in Section 4, our independent variables have count data type. Thus, we need to generate data from distributions for count data, such as Poisson or Zipf distributions with fixed support size of 16. Looking at the histogram of maximum number of code occurrences in Figure 6, we observe that many codes only occur at most once or twice. Thus, we also generate binary and trinary distributions from flat Dirichlet distributions. Finally, to make sure that the space is fully spanned, we also generate samples from Dirichlet distribution with 16 categories. In summary, the dist(s, K) is the mixture of these five distributions. The parameters of Poisson and Zipf are sampled from χ 2 (1) distribution. Sampling from the other graphical models in Figure 2 is done writing the factorization and sampling from directed edges and finally marginalization with respect to hidden variables ( Wainwright and Jordan, 2008). The hidden variables are selected to be categorical variables with cardinality selected uniformly from the integers in the interval [2,100]. The conditional distribution of the hidden variables is selected to be Dirichlet distribution with all-ones parameter vector. Table 4 show two advantages of the proposed sampling procedure for count data in comparison to the binary case proposed by Chalupka et al. (2016). First, in the synthetic dataset, the test error is significantly lower. Let dist(s, K) denotes a discrete distribution with parameter s and given support size K.2. Sample P Y |X ∼ Unif(0, 1) for K times.3. Compute the 2K-dimensional vector P X,Y (x, y) = [p (1, 0), . . . , p(K, 0), p (1, 1), . . . , p(K, 1)].Algorithm 2: Another example of generating the synthetic dataset.  This is because the size of input to the neural causality detector is 32 compared to 4 for the binary case. Applying the causality detectors to our data, we observe that the causality scores generated by our sampling scheme has significantly higher correlation with the mutual information between independent variables and the target label. Figure 7 highlights another advantage of the sampling procedure for count data as it is able to identify a larger portion of the variables as non-causal, which is more in line the expectations. Table 6 shows that the mutual information identifies V70.0 (Routine general medical examination at a health care facility) as highly correlated, but the causality detector correctly identifies it as non-causal with causality score 0.0000.In particular, in Figure 8a, the Spearman's rank correlation is ρ = 0.6689 which indicates a strong correlation. This is intuitive as we expect on average the causal connections to create stronger correlations. Another consequence of the large correlation makes regularization by the non-causality scores safer and guarantees that it will not significantly hurt the predictive performance. In Figure 8a, we have marked four codes in the four corner of the figure. An example of highly correlated and causal code we can point out 250.00 (Diabetes mellitus without mention of complication) which is a known cause of heart failure. Code 362.01 (Background diabetic retinopathy) is an effect of diabetes -a common cause of heart failure. Code V06.5 (Need for TD vaccination) is an example of neither causal nor correlated code. Finally, code 365.00 (Preglaucoma) is known for increasing the risk of heart failure, despite the fact that it is not very correlated with heart failure.   In this section we describe the details of the neural networks used in the paper. Implementation of all methods is done in Theano 0.8 and adamax is used for optimization. We also use early stopping based on the validation accuracy.We used a multilayer perceptron with seven layers of size 1024 with rectified linear units as activation functions. We use batch normalization for each layer.The α(Ex) network in the nonlinCause is selected to be a multilayer perceptron with three layers of size 200 and rectified linear units as activation functions. Using the described tuning procedure, the embedding dimension q is selected to be 200 and we used dropout with rate p = 0.8. The results in Figure 5a is generated using λ = 10 −4 for both LogCause and nonlinCause, though we observed similar performance gain for other values of penalization coefficient.Implementation of the causality detector in ( Lopez-Paz et al., 2016) in our CauseHyp is done via first generating features from the data using a three layered MLP with 200 hidden nodes in each layer. Then, after averaging over the batch, we use a five layered MLP with 200 hidden nodes in each layer. The architecture for the entire network is described in Section 3.2.Case patients were 40 to 85 years of age at the time of HF diagnosis. HF diagnosis (HFDx) is defined as:1. Qualifying ICD-9 codes for HF appeared in the encounter records or medication orders.2. A minimum of three clinical encounters with qualifying ICD-9 codes had to occur within 12 months of each other, where the date of diagnosis was assigned to the earliest of the three dates. If the time span between the first and second appearances of the HF diagnostic code was greater than 12 months, the date of the second encounter was used as the first qualifying encounter. The date at which HF diagnosis was given to the case is denoted as HFDx.Up to ten eligible controls (in terms of sex, age, location) were selected for each case, yielding an overall ratio of 9 controls per case. Each control was also assigned an index date, which is the HFDx of the matched case. Controls are selected such that they did not meet the operational criteria for HF diagnosis prior to the HFDx plus 182 days of their corresponding case. Control subjects were required to have their first office encounter within one year of the matching HF case patient's first office visit, and have at least one office encounter 30 days before or any time after the case's HF diagnosis date to ensure similar duration of observations among cases and controls. Tables 5 and 6 are discussed in the experiments section for qualitative evaluation of the results.  
