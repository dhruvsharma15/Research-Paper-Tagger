Humans are able to learn to recognize new object categories on a single or small number of examples. This has been demonstrated in a wide range of activities from hand-written character recognition [1], and motor control [2], to acquisition of high level concepts [3]. Replicating this kind of behavior in machines is the motivation for studying few-shot learning.Parametric deep learning has been performing well in settings with abundance of data. In general, deep learning models have a very high functional expressivity and capacity, and rely on being slowly, iteratively trained in a supervised regime. An influence of a particular example within the training set is therefore small, as the training is designed to capture the general structure of the dataset. This prevents rapid introduction of new classes after training. [4] In contrast, few-shot learning requires very fast adaptation to new data. In particular, k-shot clas- sification refers to a regime where classes unseen during training must be learned using k labeled examples. Non-parametric models, such as k-nearest-neighbors (kNN) do not overfit, however, their performance strongly depends on the choice of distance metric. [5] Architectures combining parametric and non-parametric models, as well as matching training and test conditions, have been performing well on k-shot classification recently.In this paper we develop a novel architecture based on prototypical networks used in [6], and train it and test it on the Omniglot dataset [3]. Vanilla prototypical networks map images into embedding vectors, and use their clustering for classification. They divide a batch into support, and query images, and use the embedding vectors of the support set to define a class prototype -a typical embedding vector for a given class. Proximity to these is then used for classification.Our model, which we call the Gaussian prototypical network, maps an image into an embedding vector, and an estimate of the image quality. Together with the embedding vector, a confidence region around it is predicted, characterized by a Gaussian covariance matrix. Gaussian prototypical networks learn to construct a direction and class dependent distance metric on the embedding space. We show that our model is a preferred way of using additional trainable parameters compared to vanilla prototypical networks.Our goal is to show that by allowing our model to express its confidence in individual data points, we reach better results. We also experiment with intentionally corrupting parts of our dataset in order to explore the extendability of our method to noisy, inhomogeneous real world datasets, where weighting individual data points might be crucial for performance.We report, to our knowledge, state-of-the-art performance in 1-shot and 5-shot classification both in 5-way and 20-way regime (for 5-shot 5-way, we are comparable to previous state-of-the-art) on the Omniglot dataset. [3] By studying the response of our model to down-sampled data, we hypothesize that its advantage might be even higher in lower quality, inhomogeneous datasets. This paper is structured as follows: We describe related work in Section 2. We then proceed to introduce our methods in Section 3. The episodic training scheme is also presented there. We discuss the Omniglot dataset in Section 4, and our experiments in Section 5. Finally, our conclusions are presented in Section 6.Non-parametric models, such as k-nearest neighbors (kNN), are ideal candidates for few-shot classifiers, as they allow for incorporation of previously unseen classes. However, they are very sensitive to the choice of distance metric. [5] Using the distance in the space of inputs directly (e.g. raw pixel values) does not produce high accuracies, as the connection between the image class and its pixels is very non-linear.A straightforward modification in which a metric embedding is learned and then used for kNN classification has yielded good results, as demonstrated by [7], [8], [9], and [10]. An approach using matching networks has been proposed in [11], in effect learning a distance metric between pairs of images. A noteworthy feature of the method is its training scheme, where each mini-batch (called an episode) tries to mimic the data-poor test conditions by sub-sampling the number of classes as well as numbers of examples in each. It has been demonstrated that such an approach improves performance on few-shot classification. [11] We therefore use it as well.Instead of learning on the dataset directly, it has recently been proposed [12] to train an LSTM [13] to predict updates to a few-shot classifier given an episode as its input. This approach is referred to as meta-learning. Meta-learning has been reaching high accuracies on Omniglot [3], as demonstrated by [14], and [15]. A task-agnostic meta-learner based on temporal convolutions has been proposed in [16]. Combinations of parametric and non-parametric methods have been the most successful in few-shot learning recently. [6][17] [18] Our approach is specific to classification of images, and does not attempt to solve the problem via meta-learning. We build on the model presented in [6], which maps images into embedding vectors, and uses their clustering for classification. The novel feature of our model is that it predicts its confidence about individual data points via a learned, image-dependent covariance matrix. This allows it to construct a richer embedding space to which images are projected. Their clustering under a direction and class-dependent distance metric is then used for classification.In this paper, we first explore the prototypical networks described in [6]. We extend the architecture to what we call a Gaussian prototypical network, allowing the model to reflect quality of individual data points (images) by predicting their embedding vectors as well as confidence regions around them, characterized by a Gaussian covariance matrix.A vanilla prototypical network comprises an encoder that maps an image into an embedding vector. A batch contains a subset of available training classes. In each iteration, images for each class are randomly split into support, and query images. The embeddings of support images are used to define class prototypes -embedding vectors typical of the class. The proximity of query image embeddings to the class prototypes is used for classification.The encoder architectures of vanilla and Gaussian prototypical networks do not differ. The key difference is the way encoder outputs are interpreted, used, and how the metric on the embedding space is constructed. In Gaussian networks, a part of the encoder output is used to construct covariance matrices about embedding vectors, which allows our model to reflect the predictive power, and quality of individual data points.We use a multi-layer convolutional neural network without an explicit, final fully connected layer to encode images into high-dimensional Euclidean vectors. For a vanilla prototypical network described in [6], the encoder is a function taking an image I and transforming it into a vector x aswhere H and W are the height and width of the input image, and C is the number of its channels. D is the embedding dimension of our vector space which is a hyperparameter of the model. W are the trainable weights of the encoder.For a Gaussian prototypical network, the output of the encoder is a concatenation of an embedding vector x ∈ R D and the relevant components of the covariance matrix Σ ∈ R D×D . Thereforewhere D S is the dimensionality of the predicted components of the covariance matrix.We explore three variants of the Gaussian prototypical network: a) Radius covariance estimate. D S = 1 and only a single real number s raw ∈ R 1 is generated per image to characterize the size of the confidence interval around its embedding vector. As such the covariance matrix has the form Σ = diag (σ, σ, . . . , σ), where σ is calculated from the raw encoder output s raw . The confidence estimate is therefore not direction- sensitive. This method proved to be the most efficient usage of additional parameters on the Omniglot dataset [3]. We suspect that this preference might be dataset-specific, and that less homogeneous datasets could prefer more complex covariance estimates. b) Diagonal covariance estimate. D S = D and the dimension of the covariance estimate is the same as of the embedding space. s raw ∈ R D is generated per image to characterize the size of the confidence interval around the embedding vector. Therefore the covariance matrix has the form Σ = diag ( σ), where σ is calculated from the raw encoder output s raw . This allows the network to express direction-dependent confidence about a data point, although the confidence ellipsoid always remains axis-aligned with the embedding space axes. c) Full covariance estimate. A full covariance matrix is output per data point. This method proved to be needlessly complex for the tasks given and therefore was not explored further.We used down-sampled gray-scale Omniglot images of the dimension 28 × 28 × 1 as an input. A 4-layer CNN architecture with 2 × 2 max pooling results into a volume of shape 1where the embedding dimension D plus the relevant parts of the covariance matrix D S are equal to the number of filters in the last later. We were using the TensorFlow SAME padding and stride 1. Our filters were 3 × 3 in spatial extent. The final layer was equivalent to a fully-connected layer.We were using 2 encoder architectures: 1) a small architecture, and 2) a big architecture. The small architecture corresponded to the one used in [6], and we used it to validate our own experiments with respect to the previous state-of-the-art results. The big architecture was used to see the effect of an increased model capacity on accuracy. As a basic building block, we used the sequence of layers in Equation 3.Both architectures were composed of 4 such blocks stacked together. The details of the architectures are as follows:1) Small architecture: 3 × 3 filters, numbers of filters [64, 64, 64, D] ( [64, 64, 64, D + 1] for the radius Gaussian model, [64, 64, 64, 2D] for the diagonal Gaussian model). Embedding space dimensions explored were D = 32, 64, 128. 2) Big architecture: 3 × 3 filters, numbers of filters [128, 256, 512, D] ( [128, 256, 512, D + 1] for the radius Gaussian model, [128, 256, 512, 2D] for the diagonal Gaussian model).Embedding space dimensions explored were D = 128, 256, 512.We explored 4 different methods of translating the raw covariance matrix output of the encoder into an actual covariance matrix. Since we primarily deal with the inverse of the covariance matrix S = Σ −1 , we were predicting it directly. Let the relevant part of the raw encoder output be S raw . The methods are as follows: a) S = 1 + softplus (S raw ), where softplus(x) = log (1 + e x ) and it is applied component- wise. Since softplus(x) &gt; 0, this guarantees S &gt; 1 and the encoder can only make data points less important. The value of S is also not limited from above. Both of these approaches prove beneficial for training. Our best models used this regime for initial training.and it is applied component- wise. Since sigmoid(x) &gt; 0, this guarantees S &gt; 1 and the encoder can only make data points less important. The value of S is bounded from above, as S &lt; 2, and the encoder is therefore more constrained. c) S = 1 + 4 sigmoid (S raw ) and therefore 1 &lt; S &lt; 5. We used this to explore the effect of the size of the domain of covariance estimates on performance. d) S = offset + scale × softplus (S raw /div), where offset, scale, and div are initialized to1.0 and are trainable. Our best models used this regime for late-stage training, as it is more flexible and data-driven than a).A key component of the prototypical model is the episodic training regime described in [6]. During training, a subset of N c classes is chosen from the total number of classes in the training set (without replacement). For each of these classes, N s support examples are chosen at random, as well as N q query examples. The encoded embeddings of the support examples are used to define where a particular class prototype lies in the embedding space. The distances between the query examples and positions of class prototypes are used to classify the query examples and to calculate loss. For the Gaussian prototypical network, the covariance of each embedding point is estimated as well. A diagram of the process is shown in Figure 1.For a Gaussian prototypical network, the radius or a diagonal of a covariance matrix is output together with the embedding vector (more precisely its raw form is, as detailed in Section 3.1). These are then used to weight the embedding vectors corresponding to support points of a particular class, as well as to calculate a total covariance matrix for the class. The distance d c (i) from a class prototype c to a query point i is then calculated aswhere p c is the centroid, or prototype, of the class c, andc is the inverse of its covariance matrix. The Gaussian prototypical network is therefore able to learn class and direction-dependent distance metric in the embedding space. We found that the speed of training and its accuracy depend strongly on how distances are used to construct a loss. We conclude that the best option is to work with linear Euclidean distances, i.e. d c (i). The specific form of the loss function used is presented in Algorithm 1. A diagram of the embedding space for a Gaussian prototypical network is shown in Figure 2. A sample of the embedding space during training is shown in the Appendix in Figures 10  and 11. It illustrates the clustering of similar characters that is used for classification.We study settings in which the covariance matrix is diagonal, as summarized in Section 3.1. For the radius case, S = sI, where I is the identity matrix, and s ∈ R 1 is calculated from the raw encoder output for each image. For the diagonal case, S = diag ( s), where s is similarly calculated from the raw encoder output for each image.  is also output by the encoder. An overall covariance matrix for each class is then computed (large light ellipses), as well as prototypes of the classes (stars). The covariance matrix of a class is used to locally modify the distance metric to query points (shown in gray).  i This corresponds to the optimal combination of Gaussians centered on the individual points into an overall class Gaussian, hence the name of the network. The elements of s are effectively 1/σ 2 . Equations 5 and 6 therefore correspond to weighting examples by 1/σ 2 . This allows the networkInput: Images I, class labels y, encoder f , N s number of support points per class, N q number of query points per class, N c number of classes in a batch Output: Predicted labelsˆylabelsˆ labelsˆy, loss L for batch in data do Choose a subset C used of N c classes from all possible training classes at random (without replacement) for class c in classes C used do Choose N s support examples for the class c from batch and call them S c . Choose N q query examples for the class c from batch and call them Q c .Embed Let the image i embedding vector be x and its true class y for class c in classes to down-weight examples that are less important for defining the class, and therefore makes our architecture more suitable for noisy, inhomogeneous, or otherwise imperfect datasets.For a one-shot regime, which is the way our networks were trained, there is a single labeled vector x c defining each class. That means that the vector itself becomes the class prototype, and its covariance matrix is also inherited by the class. The covariance then comes into play in modifying distances to query points. The full algorithm is described in Algorithm 1.To estimate the accuracy of a model on the test set, we classify the whole test set for every number of support points N s = k in the range k ∈ [1, ..19]. The number of query points for a particular k is therefore N q = 20 − N s , as Omniglot provides 20 examples of each class. The accuracies are then aggregated, and for a particular stage of the model training a k-shot classification accuracy as a function of k is determined. Since we are not using a designated validation set, we ensure our impartiality by considering the test results for the 5 highest training accuracies, and calculate their mean and standard deviation. By doing that, we prevent optimizing our result for the test set, and furthermore obtain error bounds on the resulting accuracies. We evaluate our models in 5-way and 20-way test classification to directly compare to existing literature.We used the Omniglot dataset. [3] Omniglot contains 1623 character classes from 50 alphabets (real and fictional) and 20 hand-written, gray-scale, 105 × 105 pixel examples of each. We down-sampled them to 28 × 28 × 1, subtracted their mean, and inverted them. We were using the recommended split to 30 training alphabets, and 20 test alphabets, as suggested by [3], and used by [6]. The training set included overall 964 unique character classes, and the test set 659 of them. There was no class overlap between the training and test datasets. We did not use a separate validation set as we did not fine-tune hyperparameters and chose the best performing model based on training accuracies alone (see Section 3.4).To extend the number of classes, we augmented the dataset by rotating each character by 90• , 180• , and 270• , and defined each rotation to be a new character class on its own. The same approach is used in [11], and [6]. An example of an augmented character is shown in Figure 3. This increased the number of classes 4-fold. In total, the training set therefore included 77,120 images, and the test set 52,720 images. Due to the rotational augmentation, characters that have a rotational symmetry were nonetheless defined as multiple classes. As even a hypothetical perfect classifier would not be able to differentiate e.g. the character "O" from a rotated "O", 100 % accuracy was not reachable.To improve training, and utilization of the ability to predict covariances of characters by the Gaussian network, we purposefully down-sampled a part of the training set in some of our experiments. Details are provided in Section 5. Our results suggest that the Omniglot dataset is too simple to fully utilize the ability of the Gaussian network to estimate covariance matrices. We hypothesize that the full strength of our method would show more on inhomogeneous datasets with varying quality of individual data points, as is commonly the case in real world applications.We conducted a large number of few-shot learning experiments on the Omniglot dataset. For Gaussian prototypical networks, we explored different embedding space dimensionalities, ways of generating the covariance matrix, and encoder capacities (see Section 3.1 for details). We also compared them to vanilla prototypical networks, and showed that our Gaussian variant is favorable, and that in particular the most efficient way of using the additional parameters is to predict a single number per embedding point (the radius method in Section 3.1). In general, we explored the size of the encoder (small, and big, as described in Section 3), the Gaussian/vanilla prototypical network comparison, the distance metric (cosine, √ L 2 , L 2 , and L 2 2 ), the number of degrees of freedom of the covariance matrix in the Gaussian networks (radius, and diagonal estimates, see Section 3.1), and the dimensionality of the embedding space. We also explored augmenting the input dataset by down-sampling a subset of it to encourage the usage of covariance estimates by the network, and found that this improves (k &gt; 1)-shot performance.We were using the Adam optimizer with an initial learning rate of 2 × 10 −3 . We halved the learning rate every 2000 episodes ≈ 30 epochs. All our models were implemented in TensorFlow, and ran on a single NVidia K80 GPU on Google Cloud. The training time of each model was less than a day.We trained our models with N c = 60 classes (60-way classification) at training time, and tested on N ct = 20 classes (20-way) classification. For our best-performing models, we also conducted a final N ct = 5 (5-way) classification test to compare our results to literature. During training, each class present in the mini-batch comprised N s = 1 support points, as we found that limiting the number of support points leads to better classification accuracies. This could intuitively be understood as matching the training regime to the test regime. The remaining N q = 20 − N s = 19 images per class were used as query points.The detailed results of our experiments are summarized in Table 1. We explored 4 ways of estimating the covariance matrix from the raw covariance output of the encoder, as detailed in Section 3.1.We also verified, provided that the covariance estimate is not needlessly complex, that using encoder outputs as covariance estimates is more advantageous than using the same number of parameters as additional embedding dimension. This holds true for the radius estimate (i.e. one real number The Big Gauss with embedding dimension 256 and a diagonal covariance therefore has the same number of parameters as the vanilla network with 512. The radius estimate adds 1 dimension and is therefore comparable to the vanilla model of the same embedding dimensionality. The damage column signifies that the training set was purposefully partially down-sampled during training.per embedding vector), however, the diagonal estimate does not seem to help with performance (keeping the number of parameters equal). This effect is shown in Figure 4, and Table 1. The best performing model was initially trained on the undamaged dataset for 220 epochs. The training then continued with 1.5% of images down-sampled to 24 × 24, 1.0% down-sampled to 20 × 20, and 0.5% down-sampled to 16 × 16 for 100 epochs. Then with 1.5% down-sampled to 23 × 23 and 1.0% down-sampled to 17 × 17 for 20 epochs, and 1.0% down-sampled to 23 × 23 for 10 epochs. These choices were quite arbitrary and not optimized over. The purposeful damage to the dataset encouraged usage of the covariance estimate and increased (k &gt; 1)-shot results, as shown in Table 1, and Figure 5. This partially shows that the Omniglot dataset is too high quality and simple a testbed for our approach. The training loss curves are shown in Figure 6. The training, and test accuracies as functions of iteration are also shown in Figure 7.  We conducted verification experiments with the small architecture, and reached comparable results to [6], as summarized in Table 2. The table also shows that training in a N s &gt; 1 regime, i.e. with more data points defining a class, leads to worse performance. The effect of the higher capacity of the big model is shown in Figure 8. The comparison of our models, and results from literature is presented in Table 3. To our knowledge, our models outperform state-of-the-art 1-shot and 5-shot results in both 5-way and 20-way test-time classification on Omniglot. In 5-way 5-shot classification in particular, we are reaching very close to perfect performance (99.73 ± 0.02 %) and therefore conclude that a more complex dataset is needed for further few-shot learning algorithms development. In order to validate our assumption that the Gaussian prototypical network outperforms the vanilla version due to its ability to predict covariances of individual embedded images and therefore the possibility to down-weight them, we studied the distribution of predicted values of s for our best performing network that was trained on partially down-sampled training set. We purposefully down-sampled a part of the data, and studied the resulting distribution of covariances.Down-sampling an image changes its mean and variance. As our encoders were built with a batch normalization layer in each block (see Equation 3 for details), the meaning of a particular value of the raw output changes based on the current batch. Since our model was trained with batch normalization, turning it off to study the covariances would lead to irrelevant results.Method (20-way classification)1-shot test 5-shot test Best results from [6] 96.0 % 98.9 % Small, N s = 5 94.28 ± 0.26 % 98.61 ± 0.18 % Small, N s = 1 95.64 ± 0.22 % 98.87 ± 0.11 % Small Gauss σ ∈ R 1 , N s = 1 95.99 ± 0.28 % 98.81 ± 0.16 % Table 2: Results of our verification experiments with small architectures. State of the art for 20-way classification 1-shot was 96.0 % and for 5-shot 98.9 %. N s is the number of support points per class during training. All training was done in N c = 60 (60-way classification) regime. For the Gaussian prototypical model σ ∈ S shows the dimensionality of the estimated covariance matrix.20-way 5-way Model 1-shot 5-shot 1-shot 5-shot Matching networks [11] 93.8% 98.5% 98.1% 98.9% Matching networks [11] 93.5 % 98.7 % 97.9% 98.7% Neural statistician [19] 93.2 % 98.1 % 98.1% 99.5% Prototypical network [6] 96.0 % 98.9 % 98.8% 99.7% TCML [16] 98.8 ± 0.22% 99.2 ± 0.17% Fin et al. [14] 98.7 ± 0.4% 99.9 ± 0.3% Munkhdalai and Yu [15] 98.9 % Big Gauss (radius) (ours) 97.02 ± 0.04% 99.16 ± 0.05% 99.02 ± 0.05% 99.66 ± 0.02% Big Gauss (radius) with damage (ours) 96.94 ± 0.14% 99.29 ± 0.04% 99.07 ± 0.03% 99.73 ± 0.02% Table 3: The best results of our experiments as compared to other papers. All training was done in N c = 60 (60-way classification) regime. To our knowledge, our models have statistically significant state-of-the-art performance in both 1-shot and 5-shot 20-way classification, as well as for 1-shot 5-way classification. We perform comparably with current state-of-the-art in the 5-shot 5-way case.For the undamaged dataset, the vast majority of covariance estimates took the same value. This stays true even when artificially introducing damage by down-sampling. However, the distributions are shifted due to the effect of batch normalization in the last layer. To better represent the meaning of individual inverse covariances, we aligned our histograms such that the most frequent values match each other. This approach is useful as the most dominant values correspond to the raw output of 0, and only the differences from it influence classification. The result is shown in Figure 9. Figure 9: Predicted covariances for the original dataset and a partially down-sampled version of it. The Gaussian network learned to down-weight damaged examples by predicting a higher s, as apparent from the heavier tail of the yellow distribution. The distributions are aligned together, as only the difference between the leading edge and a value influence classification.In this paper we proposed Gaussian prototypical networks for few-shot classification -an improved architecture based on prototypical networks [6]. We tested our models on the Omniglot dataset, and explored different approaches to generating a covariance matrix estimate together with an embedding vector. We showed that the Gaussian prototypical network outperforms the vanilla prototypical network with a comparable number of parameters, and therefore that our architecture choice is beneficial. We found that estimating a single real number on top of an embedding vector works better than estimating a diagonal or a full covariance matrix. We suspect that lower quality, less homogeneous datasets might prefer a more complex covariance matrix estimate. Contrary to [6], we found that the best results are obtained if one trains the network in the 1-shot regime. We then extended the size of our model and managed to reach, to the best of our knowledge, state- of-the-art performance in 1-shot and 5-shot classification both in 5-way and 20-way test regime (for 5-shot 5-way, we are comparable to previous state-of-the-art). We managed to get better accuracies (in particular for (k &gt; 1)-shot classification) by artificially down-sampling fractions of our training dataset, encouraging the network to fully utilize covariance estimates. Especially for 5-way classification, our results are very close to perfect performance and we therefore conclude that further development in few-shot classification should focus on more complex datasets than Omniglot. We hypothesize that the ability to learn the embedding as well as its uncertainty would be even more beneficial for poorer-quality datasets, which are commonplace in real world applications. There, down-weighting some data points might be crucial for faithful classification. This is supported by our experiments with down-sampling Omniglot.  
