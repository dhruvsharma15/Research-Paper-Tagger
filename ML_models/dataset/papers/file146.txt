• gains advantage from the categorical distribution which makes a prediction more accurate,• outputs a single value which is a solution to a given regression task,• may be evaluated as quickly as in the case of the original regression neural network.The method proposed, called drawering, bases on tem- porarily extending a given neural network that solves a regression task. That modified neural network has properties In this setup, any given neural network f (·) may be understood as a composition f (·) = g(h(·)), where g(·) is the last part of the neural network f (·) i.e. g(·) applies one matrix multiplication and optionally a non-linearity. In other words, a vector z = h(x) is the value of last hidden layer for an input x and the value g(z) may be written as g(z) = σ(Gh(x)) for a matrix G and some function σ (one can notice that G is just a vector). The job which is done by g(·) is just to squeeze all information from the last hidden layer into one value.In simple words, the neural network f (·) may be divided in two parts, the first, core h(·), which performs majority of calculations and the second, tiny one g(·) which calculates a single value, a prediction, based on the output of h(·). not only the original target, but also additional one which depicts order of magnitude of the original target. As a result extended neural network simultaneously solves the regression task and a related classification problem.One possibility to define sets e i , called drawers, is to take suitable percentiles of target values to make each e i contain roughly the same number of them. always squeezes the last hidden layer into one value. On the other hand the function s(·) may have hidden layers, but the simplest architecture is presented.Our main idea is to extend the neural network f (·). For every input x the value of the last hidden layer z = h(x) is duplicated and processed by two independent, parameterized functions. The first of them is g(·) as before and the second one is called s(·). The original neural network g(h(·)) is trained to minimize the given loss function L f and the neural network s(h(·)) is trained with a new loss function L s . An example of the extension described is presended in the Figure 1. For the sake of consistency the loss function L f will be called L g .Note that functions g(h(·)) and s(h(·)) share parameters, because g(h(·)) and s(h(·)) are compositions having the same inner function. Since the parameters of h(·) are shared. It means that learning s(h(·)) influences g(h(·)) (and the other way around). We want to train all these functions jointly which may be hard in general, but the function s(·) and the loss function L s are constructed in a special way presented below.All real values are clustered into n consecutive intervals i.e. disjoint sets e 1 , e 2 , ..., e n such that Training is done using gradient descent, hence it is suf- ficient to obtain gradients of all functions defined i.e. h(·), g(·) and s(·). For a given pair (x, y) ∈ D the forward pass for g(h(x)) and s(h(x)) is calculated (note that a majority of calculations is shared). Afterwards two backpropagations are processed.The backpropagation for the composition g(h(x)) using loss function L g returns a vector which is a concatenation of two vectors grad g and grad h,g , such that grad g is the gradient of function g(·) at the point h(x) and grad h,g is the gradient of function h(·) at the point x. Similarly, the backpropagation for s(h(x)) using loss function L s gives two gradients grad s and grad h,s for functions s(·) and h(·), respectively.The computed gradients of g(·) and s(·) parameters (i.e. grad g and grad s ) can be applied as in the normal case - each one of those functions takes part in only one of the backpropagations.Updating the parameters belonging to the h(·) part is more complex, because we are obtaining two different gra- dients grad h,g and grad h,s . It is worth noting that h(·) parameters are the only common parameters of the com- positions g(h(x)) and s(h(x)). We want to take an average of the gradients grad h,g and grad h,s and apply (update h(·) parameters). Unfortunately, the orders of magnitute of them may be different. Therefore, taking an unweighted average may result in minimalizing only one of the loss functions L g or L s . To address this problem, the averages a g and a s of absolute values of both gradients are calculated.Formally, the norm L 1 is used to define:The function s(h(·)) (evaluated for an input x) is trained to predict which of the sets (e i )The loss function L s may be defined as a non-binary cross-entropy loss which is typically used in classifiation problems. In the simplest form the function s(·) may be just a multiplication by a matrix S (whose first dimension is n).To sum up, drawering in its basic form is to add ad- ditional, parallel layer which takes as the input the value of the last hidden layer of the original neural network f (·). A modified (drawered) neural network is trained to predictThe values a g and a s aproximately describe the impacts of the loss functions L g and L s , respectively. The final vector grad h which will be used as a gradient of h(·) parameters in the gradient descent procedure equals:for a hyperparameter α ∈ (0, 1), typically α = 0.5. This strategy makes updates of h(·) parameters be of the same order of magnitude as in the procces of learning the original neural network f (·) (without drawering).One can also normalize the gradient grad h,g instead of the gradient grad h,s , but it may need more adjustments in the hyperparameters of the learning procedure (e.g. learning rate alteration may be required).Note that for α = 1 the learning procedure will be identical as in the original case where the function f is trained using loss function L g only.It is useful to bear in mind that both backpropagations also share a lot of calculations. In the extreme case when the ratio 2.4.2. Disjoint and nested. We observed that sometimes it may be better to train s(h(·)) to predict whether target is in a set f j , whereis known in advance one backpropagation may be performed simultaneously for loss function L g and the weighted loss function L s . We noticed that the ratio needed is roughly constant between batches iterations therefore may be calculated in the initial phase of learning. Afterwards may be checked and updated from time to time.In this section we slightly abused the notation -a value of gradient at a given point is called just a gradient since it is obvious what point is considered. i=j e i . In this case s(h(·)) has to answer a simpler question: "Is a target higher than a given value?" instead of bounding the target value from both sides. Of course in this case s(h(x)) no longer solves a one-class classification problem, but every value of s(h(x)) may be assesed independently by binary cross-entropy loss.Therefore, drawers may be:• regular or uneven,• nested or disjoint.These divisions are orthogonal. In all experiments described in this paper (the section 6) uneven drawers were used.3. Logic behind our idea 2.4.1. Regular and uneven. We mentioned in the subsec- tion 2.2 that the simplest way of defining drawers is to take intervals whose endings are suitable percentiles that distribute target values uniformly. In this case n regular drawers are defined in the following way:We believe that drawering improves learning by provid- ing the following properties.whereThe extension s(·) gives additional expressive power to a given neural network. It is used to predict additional target, but since this target is closely re- lated with the original one, it is believed that gained knowledge is transferred to the core of the given neural network h(·).n -quantile of targets y from training set (the values q 0,n and q n,n are defined as minus infinity and plus inifinity, respectively). This way of defining drawers makes each interval e i contain approximately the same number of target values.However, we noticed that an alternative way of defining e i 's, which tends to support classical mean square error (MSE) loss better, may be proposed. The MSE loss penal- izes more when the difference between the given target and the prediction is larger. To address this problem drawers may be defined in a way which encourages the learning procedure to focus on extreme values. Drawers should group the middle values in bigger clusters while placing extreme values in smaller ones. The definition of 2n uneven drawers is as follows:• Since categorical distributions do not assume their shape, they can model arbitrary distribution -they are more flexible.• We argue that classification loss functions provide better behaved gradients than regression ones. As a result evolution of classification neural network is more smooth during learning.• Additional target (even closely related) works as a regularization as typically in multitask learning [5].In this case every drawer e i+1 contains approximately two times more target values as compared to drawer e i for i &lt; n. Finally, both e n and e n+1 contain the maximum of 25% of all target values. Similarly to the asceding intervals in the first half, e i are desceding for i &gt; n i.e. contain less and less target values. The number of drawers n is a hyperparameter. The big- ger n the more complex distribution may be modeled. On the other hand each drawers has to contain enough representants among targets from training set. In our experiments each drawer contained at least 500 target values.Effectiveness of the method presented was established with the comparison. The original and drawered neural network were trained on the same dataset and once trainings were completed the neural networks performances on a given test set were measured. Since drawering affects just a learning procedure the comparision is fair.All learning procedures depend on random initialization hence to obtain reliable results a few learning procedures in both setups were performed. Adam [6] was chosen for stochastic optimization.The comparison was done on two datasets described in the following section. The results are described in the section 6.The method presented were tested on two datasets.The first dataset is public and was used during Ross- mann Store Sales competition on well-known platform kag- gle.com. The official description starts as follows:Rossmann operates over 3,000 drug stores in 7 European countries. Currently, Rossmann store managers are tasked with predicting their daily sales for up to six weeks in advance. Store sales are influenced by many factors, including promo- tions, competition, school and state holidays, sea- sonality, and locality. With thousands of individual managers predicting sales based on their unique circumstances, the accuracy of results can be quite varied.The dataset contains mainly categorical features like information about state holidays, an indicator whether a store is running a promotion on a given day etc.Since we needed ground truth labels, only the train part of the dataset was used (in kaggle.com notation). We split this data into new training set, validation set and test set by time. The training set (648k records) is consisted of all observations before year 2015. The validation set (112k records) contain all observations from January, February, March and April 2015. Finally, the test set (84k records) covers the rest of the observations from year 2015.In our version of this task target y is normalized loga- rithm of the turnover for a given day. Logarithm was used since the turnovers are exponentially distributed. An input x is consisted of all information provided in the original dataset except for Promo2 related information. A day and a month was extracted from a given date (a year was ignored).The biggest challenge linked with this dataset is not to overfit trained model, because dataset size is relatively small and encoding layers have to be used to cope with categorical variables. Differences between scores on train, validation and test sets were significant and seemed to grow during learning. We believe that drawering prevents overfitting - works as a regularization in this case. but it turned out that scores on validation and test sets are almost identical.We believe that the biggest challenge while working on the conversion value task is to tame gradients which vary a lot. That is to say, for two pairs (x 1 , y 1 ) and (x 2 , y 2 ) from the dataset, the inputs x 1 and x 2 may be close to each other or even identical, but the targets y 1 and y 2 may even not have the same order of magnitude. As a result gradients may remain relatively high even during the last phase of learning and the model may tend to predict the last encountered target (y 1 or y 2 ) instead of predicting an average of them. We argue that drawering helps to find general patterns by providing better behaved gradients.In this section the results of the comparisons described in the previous section are presented.In this case the original neural network f (·) takes an input which is produced from 14 values -12 categorical and 2 continuous ones. Each categorical value is encoded into a vector of size min(k, 10), where k is the number of all possible values of the given categorical variable. The min- imum is applied to avoid incorporating a redundancy. Both continuous features are normalized. The concatenation of all encoded features and two continuous variables produces the input vector x of size 75.The neural network f (·) has a sequential form and is defined as follows:• an input is processed by h(·) which is as follows:• afterwards an output of h(·) is fed to a simple function g(·) which is just a Linear(128, 1).The drawered neural network with incorporated s(·) is as follows:This private dataset depicts conversion value task i.e. a regression problem where one wants to predict the value of the next item bought for a given customer who clicked a displayed ad.The dataset describes states of customers at the time of impressions. The state (input x) is a vector of mainly continuous features like a price of last item seen, a value of the previous purchase, a number of items in the basket etc. Target y is the price of the next item bought by the given user. The price is always positive since only users who clicked an ad and converted are incorporated into the dataset.The dataset was split into training set (2, 1 million records) and validation set (0, 9 million observations). Ini- tially there was also a test set extracted from validation set,• as in the original f (·), the same h(·) processes an input,• an output of h(·) is duplicated and processed inde- pendently by g(·) which is the same as in the original f (·) and s(·) which is as follows:The torch notation were used, here: • Dropout is a dropout layer [7]. Nested (worst) 0,860The drawered neural network has roughly 150k more parameters. It is a huge advantage, but these additional parameters are used only to calculate new target and addi- tional calculations may be skipped during an evaluation. We believe that patterns found to answer the additional target, which is related to the original one, were transferred to the core part h(·).We used dropout only in s(·) since incorporating dropout to h(·) causes instability in learning. While work on regres- sion tasks we noticed that it may be a general issue and it should be investigated, but it is not in the scope of this paper.Fifty learning procedures for both the original and the extended neural network were performed. They were stopped after fifty iterations without any progress on val- idation set (and at least one hundred iterations in total). The iteration of the model which performed the best on validation set was chosen and evaluated on the test set. The loss function used was a classic square error loss.The minimal error on the test set achieved by the draw- ered neural network is 4.481, which is 7.5% better than the best original neural network. The difference between the average of Top5 scores is also around 7.5% in favor of drawering. While analyzing the average of all fifty models per method the difference seems to be blurred. It is caused be the fact that a few learning procedures overfited too much and achieved unsatisfying results. But even in this case the average for drawered neural networks is about 3.8% better. All these scores with standard deviations are showed in the Table 1.  We have to note that extending h(·) by additional 150k parameters may result in ever better performance, but it would drastically slow an evaluation. However, we noticed that simple extensions of the original neural netwok f (·) tend to overfit and did not achieve better results.The train errors may be also investigated. In this case the original neural network performs better which supports our thesis that drawering works as a regularization. Detailed results are presented in the Table 2.This dataset provides detailed users descriptions which are consisted of 6 categorical features and more than 400 continuous ones. After encoding the original neural network f (·) takes an input vector of size 700. The core part h(·) is the neural network with 3 layers that outputs a vector of size 200. The function g(·) and the extension s(·) are simple, Linear(200, 1) and Linear(200, 21), respectively.In case of the conversion value task we do not provide a detailed model description since the dataset is private and this experiment can not be reproduced. However, we decided to incorporate this comparison to the paper because two versions of drawers were tested on this dataset (disjoint and nested). We also want to point out that we invented drawering method while working on this dataset and after- wards decided to check the method out on public data. We were unable to achieve superior results without drawering. Therefore, we believe that work done on this dataset (despite its privacy) should be presented.To obtain more reliable results ten learning procedures were performed for each setup:  In the Figure 2 six learning curves are showed. For each of three setups the best and the worst ones were chosen. It means that the minimum of the other eight are between representants showed. The first 50 iterations were skipped to make the figure more lucid. Each learning procedure was finished after 30 iterations without any progress on the validation set.It may be easily inferred that all twenty drawered neural networks performed significantly better than neural networks trained without the extension. The difference between Dis- The method presented, drawering, extends a given re- gression neural network which makes training more effec- tive. The modification affects the learning procedure only, hence once drawered model is trained, the extension may be easily omitted during evaluation without any change in prediction. It means that the modified model may be evaluated as fast as the original one but tends to perform better.
