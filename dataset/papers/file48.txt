Deep neural networks have recently enjoyed some success at modeling natural language ( Mikolov et al., 2010;Zaremba et al., 2014;Kim et al., 2015). Typically, recurrent and convolutional language models are trained to maximize the likelihood of observing a word or character given the previous observations in the sequence P (w 1 . . . w n ) = p(w 1 ) n i=2 P (w i |w 1 . . . w i−1 ). These models are commonly trained using a tech- nique called teacher forcing (Williams and Zipser, 1989) where the inputs to the network are fixed and the model is trained to predict only the next * Indicates first authors. Ordering determined by coin flip. item in the sequence given all previous observa- tions. This corresponds to maximum-likelihood training of these models. However this one-step ahead prediction during training makes the model prone to exposure bias ( Ranzato et al., 2015;Bengio et al., 2015). Exposure bias occurs when a model is only trained conditioned on ground- truth contexts and is not exposed to its own er- rors (Wiseman and Rush, 2016). An important consequence to exposure bias is that generated se- quences can degenerate as small errors accumu- late. Many important problems in NLP such as machine translation and abstractive summariza- tion are trained via a maximum-likelihood train- ing objective ( Rush et al., 2015), but require the generation of extended se- quences and are evaluated based on sequence-level metrics such as BLEU ( Papineni et al., 2002) and ROUGE (Lin, 2004).One possible direction towards incorporating a sequence-level training objective is to use Gener- ative Adversarial Networks (GANs) ( Goodfellow et al., 2014). While GANs have yielded impres- sive results for modeling images (Radford et al., 2015;Dumoulin et al., 2016), advances in their use for natural language generation has lagged be- hind. Some progress has been made recently in incorporating a GAN objective in sequence mod- eling problems including natural language gen- eration.  use an adversarial criterion to match the hidden state dynamics of a teacher forced recurrent neural network (RNN) and one that samples from its own output distri- bution across multiple time steps. Unlike the ap- proach in , sequence GANs ( Yu et al., 2016) and maximum-likelihood augmented GANs ( Che et al., 2017) use an adversarial loss at outputs of an RNN. Using a GAN at the out- puts of an RNN however isn't trivial since sam- pling from these outputs to feed to the discrimi- nator is a non-differentiable operation. As a re- sult gradients cannot propagate to the generator from the discriminator. Yu et al. (2016) use policy gradient to estimate the generator's gradient and ( Che et al., 2017) present an importance sampling based technique. Other alternatives include RE- INFORCE (Williams, 1992), the use of a Gumbel softmax ( Jang et al., 2016) and the straighthrough estimator ( Bengio et al., 2013) among others.In this work, we address the discrete output space problem by simply forcing the discriminator to operate on continuous valued output distribu- tions. The discriminator sees a sequence of proba- bilities over every token in the vocabulary from the generator and a sequence of 1-hot vectors from the true data distribution as in Fig. 1. This technique is identical to that proposed by Gulrajani et al. (2017), which is parallel work to this. In this paper we provide a more complete empirical investiga- tion of this approach to applying GANs to discrete output spaces. We present results using recurrent as well as convolutional architectures on three lan- guage modeling datasets of different sizes at the word and character-level. We also present quanti- tative results on generating sentences that adhere to a simple context-free grammar (CFG), and a richer probabilistic context-free grammar (PCFG). We compare our method to previous works that use a GAN objective to generate natural language, on a Chinese poetry generation dataset. In addi- tion, we present a conditional GAN (Mirza and Osindero, 2014) that generates sentences condi- tioned on sentiment and questions. be shown to minimize the Jensen Shannon Diver- gence (JSD) between the generator's output distri- bution and the true data distribution.However, in practice, the generator is trained to maximize log(D(G(z))) instead, since it provides stronger gradients in the early stages of learning ( Goodfellow et al., 2014).GANs have been reported to be notoriously hard to train in practice  and several techniques have been proposed to alleviate some of the complexities involved in getting them to work including modified objec- tive functions and regularization (Salimans et al., 2016;Mao et al., 2016;Gulrajani et al., 2017). We discuss some of these prob- lems in the following subsection. Nowozin et al. (2016) show that it is possible to train GANs with a variety of f-divergence mea- sures besides JSD. Wasserstein GANs (WGANs) ( ) minimize the earth mover's distance or Wasserstein distance, while Least Squared GANs (LSGANs) ( Mao et al., 2016) modifies replaces the log loss with an L2 loss. WGAN-GP ( Gulrajani et al., 2017) incorporate a gradient penalty term on the discriminator's loss in the WGAN objective which acts as a regular- izer. In this work, we will compare some of these objectives in the context of natural language gen- eration.GANs ( Goodfellow et al., 2014) are a general framework used in training generative models by formulating the learning process as a two player minimax game as formulated in the equation be- low. A generator network G tries to generate sam- ples that are as close as possible to the true data distribution P (x) of interest from a fixed noise distribution P (z). We will refer to the samples produced by the generator as G(z). A discrimina- tor network is then trained to distinguish between G(z) and samples from the true data distribution P (x) while the generator network is trained us- ing gradient signals sent by the discriminator by minimizing log(1 − D(G(z))). Goodfellow et al. (2014) have shown that, with respect to an opti- mal discriminator, the minimax formulation can  argue that part of the problem in training regular GANs is that it seeks to minimize the JSD between the G(z) and P (x). When the generator is trying to op- timized log(1 − D(G(z))), the gradients that it receives vanish as the discriminator is trained to optimality. The authors also show that when trying to optimize the more practical alternative, −log(D(G(z))), the generator might not suffer from vanishing gradients but receives unstable training signals. It is also important to consider the fact that highly structured data like images and language lie in low-dimensional manifolds (as is evident by studying their principal components). Wassterstein GANs ( ) over- come some of the problems in regular GAN train- ing by providing a softer metric to compare the distributions lying in low dimensional manifolds.A key contribution of this work was identifying the importance of a lipschitz constraint which is achieved by clamping the weights of the discrim- inator to lie in a fixed interval. The lipschitz constraint and training the discriminator multiple times for every generator gradient update creates a strong learning signal for the generator. Gulrajani et al. (2017) present an alternative to weight clamping that they call a gradient penalty to enforce lipschitzness since model performance was reported to be highly sensitive to the clamp- ing hyperparameters. They add the following penalty to the discriminator training objective -A potential concern regarding our strategy to train our discriminator to distinguish between sequence of 1-hot vectors from the true data distribution and a sequence of probabilities from the generator is that the discrim- inator can easily exploit the sparsity in the 1-hot vectors to reach optimality. However, Wasster- stein distance with a lipschitz constraint / gradi- ent penalty provides good gradients even under an optimal discriminator and so isn't a problem for us in practice. Even though it is possible to ex- tract some performance from a regular GAN ob- jective with the gradient penalty (as we show in one of our experiments), WGANs still provide bet- ter gradients to the generator since the discrimina- tor doesn't saturate often. Let z ∼ N (0, I) be the input to our generator network G from which we will attempt to gener- ate natural language. For implementation conve- nience, the sample z is of shape n × d where n is the length of sequence and d is a fixed length dimension of the noise vector at each time step. The generator then transforms z into a sequence of probability distributions over the vocabulary G(z) of size n×k where k is the size of our true data dis- tribution's vocabulary. The discriminator network D is provided with fake samples G(z) and sam- ples from the true data distribution P (x). Sam- ples from the true distribution are provided as a sequence of 1-hot vectors with each vector serv- ing as an indicator of the observed word in the sample. As described in section 2, the discrimi- nator is trained to discriminate between real and fake samples and the generator is trained to fool Recurrent Neural Networks (RNNs), particu- larly Long short-term memory networks (LSTMs) (Hochreiter and Schmidhuber, 1997) and Gated Recurrent Networks ( ) are power- ful models that have been successful at modeling sequential data ( Graves and Schmidhuber, 2009;Mikolov et al., 2010). They transform a sequence of input vectors x = x 1 . . . x n into a sequence of hidden states h = h 1 . . . h n where each hid- den state maintains a summary of the input up un- til then. RNN language models are autoregres- sive in nature since the input to the network at time t depends on the output at time t − 1. How- ever, in the context of generating sequences from noise, the inputs are pre-determined and there is no direct correspondence between the output at time t − 1 and the input at time t this fundamen- tally changes the auto-regressiveness of the RNN. The RNN does however carry forward informa- tion about its output at time t through subsequent time steps via its hidden states h as evident from its recurrent transition function. In order to incor- porate an explicit dependence between subsequent RNN outputs, we add a peephole connection be- tween the output probability distribution y t−1 at time t−1 and the hidden state h t at time t as show in the LSTM equations below. Typical RNN lan- guage models have a shared affine transformation matrix W out that is shared across time all steps that projects the hidden state vector to a vector of the same size as the target vocabulary to generate a sequence of outputs y = y 1 . . . y t . Subsequently a softmax function is applied to each vector to turn it into a probability distribution over the vocabulary.During inference, an output is sampled from the softmax distribution and becomes the input at the subsequent time step. While training the inputs are pre-determined. In all of our models, we perform greedy decoding where we always pick argmax y t . When using the LSTM as a discrim- inator we use a simple binary logistic regression layer on the last hidden state h n to determine the probability of the sample being from the genera- tor's data distribution or from the real data distri- bution.The LSTM update equations with an output peephole are : ual blocks into a sequence of un-normalized vec- tors for each element in the input sequence (noise). These vectors are then normalized using the soft- max function. All convolutions are 'same' con- volutions with a stride of 1 followed by batch- normalization ( Ioffe and Szegedy, 2015) and the ReLU ( Nair and Hinton, 2010;Glorot et al., 2011) activation function without any pooling so as to preserve the shape of the input. The discrimina- tor architecture is identical to that of the generator with the final output having a single output chan- nel.In likelihood based training of generative language models, models are only trained to make one-step ahead predictions and as a result it is possible to train these models on relatively long sequences even in the initial stages of training. However, in our adversarial formulation, our generator is en- couraged to generate entire sequences that match the true data distribution without explicit supervi- sion at each step of the generation process. As a way to provide training signals of incremen- tal difficulty, we use curriculum learning ( Bengio et al., 2009) and train our generator to produce se- quences of gradually increasing lengths as training progresses.where σ is the element-wise sigmoid function, is the hadamard product, tanh is the element-wise tanh function. W · and b · are learn-able parame- ters of the model and i t , f t , o t and c t constitute the input, forget, output and cell states of the LSTM respectively.Convolutional neural networks (CNNs) have also shown promise at modeling sequential data us- In the context of generating natural language, it is possible to come up with a simpler approach to evaluate compute the likelihoods of generated samples. We synthesize a data generating distri- bution under which we can compute likelihoods in a tractable manner. We propose a simple evalua- tion strategy for evaluating adversarial methods of generating natural language by constructing a data generating distribution from a CFG or P−CFG. It is possible to determine if a sample belongs to the CFG or the probability of a sample under a P−CFG by using a constituency parser that is pro- vided with all of the productions in a grammar. Yu et al. (2016) also present a simple idea to esti- mate the likelihood of generated samples by using a randomly initialized LSTM as their data gener- ating distribution. While this is a viable strategy to evaluate generative models of language, a ran- domly initialized LSTM provides little visibility into the complexity of the data distribution itself and presents no obvious way to increase its com- plexity. CFGs and PCFGs however, provide ex- plicit control of the complexity via their produc- tions. They can also be learned via grammar in- duction (Brill, 1993) on large treebanks of natural language and so the data generating distribution is not synthetic as in ( Yu et al., 2016).Typical language models are evaluated by mea- suring the likelihood of samples from the true data distribution under the model. However, with GANs it is impossible to measure likelihoods un- der the model itself and so we measure the like- lihood of the model's samples under the true data distribution instead.We divide our experiments into four categories:count the number of unique samples; while this as- sumes that all samples are orthogonal it still serves as a proxy measure of the entropy. We compare various generator, discriminator and GAN objec- tives on this problem.To construct a more challenging problem than a simple CFG, we use sections 0-21 of the WSJ sub- section of the Penn Treebank to induce a PCFG using simple count statistics of all productions.• Generating language that belongs to a toy CFG and an induced PCFG from the Penn Treebank ( Marcus et al., 1993).We train our model on all sentences in the treebank and restrict the output vocabulary to the top 2,000 most frequently occurring words. We evaluate our models on this task by measuring the likelihood of a sample using a Viterbi chart parser (Klein and Manning, 2003). While such a measure mostly captures the grammaticality of a sentence, it is still a reasonable proxy of sample quality.• Chinese poetry generation with comparisons to ( Yu et al., 2016) and (Che et al., 2017).• Generated samples from a dataset consisting of simple English sentences, the 1-billion- word and Penn Treebank datasets.• Conditional GANs that generate sentences conditioned on certain sentence attributes such as sentiment and questions.We use a simple and publicly available CFG 1 that contains 248 productions. We then generate two sets of data from this CFG -one consisting of sam- ples of length 5 and another of length 11. Each set contains 100,000 samples selected at random from the CFG. The first set has a vocabulary of 36 tokens while the second 45 tokens. We eval- uate our models on this task by measuring the fraction of generated samples that satisfy the rules of the grammar and also measure the diversity in our generated samples. We do this by generating 1,280 samples from noise and computing the frac- tion of those that are valid under our grammar us- ing the Earley parsing algorithm (Earley, 1970). In order to measure sample diversity, we simply the Zhang and Lapata (2014) present a dataset of Chi- nese poems that were used to evaluate adversarial training methods for natural language in ( Yu et al., 2016) and (Che et al., 2017). The dataset consists of 4-line poems with a variable number of charac- ters in each line. We treat each line in a poem as a training example and use lines of length 5 (poem- 5) and 7 (poem-7) with the train/validation/test split 2 specified in ( Che et al., 2017). We use BLEU-2 and BLEU-3 to measure model perfor- mance on this task. Since there is no obvious "tar- get" for each generated sentence, both works re- port corpus-level BLEU measures using the entire test set as the reference.We generate language from three different datasets of varying sizes and complexity. A dataset com- prising simple English sentences 3 which we will henceforth refer to as CMU−SE, the version of the Penn Treebank commonly used in language modeling experiments ( Zaremba et al., 2014) and the Google 1-billion word dataset ( Chelba et al., 2013). We perform experiments at generating lan- guage at the word as well as character-level. The CMU−SE dataset consists of 44,016 sentences with a vocabulary of 3,122 words, while the Penn Treebank consists of 42,068 sentences with a vo- cabulary of 10,000 words. We use a random sub- set of 3 million sentences from the 1-billion word dataset and constrain our vocabulary to the top 30,000 most frequently occurring words. We use a curriculum learning strategy in all of our LSTM models (with and without the output peephole con- nection) that starts training on sentences of length 5 at the word level and 13 for characters and in- creases the sequence length by 1 after a fixed num- ber of epochs based on the size of the data. Con- volutional methods in ( Gulrajani et al., 2017) are able to generate long sequences even without a curriculum, however we found it was critical in generating long sequences with an LSTM.in ( Zhang et al., 2015) and use the first 3 million short reviews with a vocabulary of the top 4,000 most frequently occurring words. Conditioning on sentence attributes is achieved by concatenating a single feature map containing either entirely ones or zeros to indicate the presence or absence of the attribute as in ( Radford et al., 2015) at the out- put of each convolutional layer. The conditioning is done on both the generator and the discrimina- tor. We experiment with conditional GANs using only convolutional methods since methods adding conditioning information has been well studied in these architectures.All models are trained using the back-propagation algorithm updating our parameters using the Adam optimization method ( Kingma and Ba, 2014) and stochastic gradient descent (SGD) with batch sizes of 64. A learning rate of 2 × 10 −3 , β 1 = 0.5 and β 2 = 0.999 is used in our LSTM generator and discriminators while convolutional architectures use a learning rate of 1 × 10 −4 . The noise prior and all LSTM hidden dimensions are set to 128 except for the Chinese poetry genera- tion task where we set it to 64.Figure 2: Negative log-likelihood of generated samples under the PCFG using an LSTM trained with the WGAN-GP, GAN-GP and a standard MLE objective on the PTB datasetGANs are able to leverage explicit condition- ing on high-level attributes of data ( Mirza and Osindero, 2014;Gauthier, 2014;Radford et al., 2015) to generate samples which contain these at- tributes. Recent work ( Hu et al., 2017) generates sentences conditioned on certain attributes of lan- guage such as sentiment using a variational au- toencoders (VAEs) ( Kingma and Welling, 2013) and holistic attribute discriminators. In this paper, we use two features inherent in language -sen- timent and questions. To generate sentences that are questions, we use the CMU−SE dataset and label sentences that contain a "?" as being ques- tions and the rest as been statements. To generate sentences of positive and negative sentiment we use the Amazon review polarity dataset collected Table. 1 presents quantitative results on generat- ing sentences that adhere to the simple CFG de- scribed in Section 4.1. The Acc column computes the accuracy with which our model generates sam- ples from the CFG using a sample of 1,280 gen- erations. We observe that all models are able to fit sequences of length 5 but only the WGAN, WGAN-GP objectives are able to generalize to longer sequences of length 11. This motivated us to use only the WGAN and WGAN-GP objectives in our subsequent experiments. The GAN-GP cri- terion appears to perform reasonably as well but we restrict our experiments to use the WGAN and WGAN-GP criteria only. GANs have been shown to exhibit the phenomenon of "mode dropping" where the generator fails to capture a large fraction of the modes present in the data generating distri- bution ( Che et al., 2016  Table 2: BLEU scores on the poem-5 and poem-7 datasets of diverse samples while also fitting the data dis- tribution well. Fig. 2 shows the negative-log-likelihood of gen- erated samples using a LSTM architecture using the WGAN-GP, GAN-GP and MLE criteria. All models used an LSTM generator. The sequence length is set to 7 and the likelihoods are evaluated at the end of every epoch on a set of 64 samples. Table. 2 contains quantitative results on the Chi- nese poetry generation dataset. The results indi- cate that our straightforward strategy to overcome back-propagating through discrete states is com- petitive and outperforms more complicated meth- ods.Table. 5 contains sequences generated by our model conditioned on sentiment (posi- tive/negative) and questions/statements. The model is able to pick up on certain consistent pat- terns in questions as well as when expressing sen- timent and use them while generating sentences. Tables 3 and 4 contain sequences generated at the word and character-level by our LSTM and CNN models. Both models are able to produce re- alistic sentences. The CNN model with a WGAN- GP objective appears to be able to maintain con- text over longer time spans.In conclusion, this work presents a straightforward but effective method to train GANs for natural lan- guage. The simplicity lies in forcing the discrimi- nator to operate on continuous values by present- ing it with a sequence of probability distributions from the generator and a sequence of 1-hot vec- tors corresponding to data from the true distribu- tion. We propose an evaluation strategy that in- volves learning the data distribution defined by a CFG or PCFG. This lets us evaluate the likeli- hood of a sample belonging to the data generating distribution. The use of WGAN and WGAN-GP objectives produce realistic sentences on datasets of varying complexity (CMU-SE, Penn Treebank and the 1-billion dataset). We also show that it is possible to perform conditional generation of text on high-level sentence features such as sentiment and questions. In future work, we would like to ex- plore GANs in other domains of NLP such as non goal-oriented dialog systems where a clear train-  I'm at the missouri burning the indexing manufacturing and through .&lt;s&gt;cruise pay the next in my replacement . &lt;/s&gt; &lt;s&gt;what 's in the friday food ? ? &lt;/s&gt; usuall the review omnium nothing non- functionable good buy homeostasis money well spent kickass cosamin of time and fun . extreme crap-not working and eeeeeew great britani ! I lovethis. a horrible poor imposing se400 QUESTION STATEMENT &lt;s&gt;when 's the friday convention on ? &lt;/s&gt; &lt;s&gt;i report my run on one mineral . &lt;/s&gt; &lt;s&gt;how many snatched crew you have ? &lt;/s&gt; &lt;s&gt;we have to record this now . &lt;/s&gt; &lt;s&gt;how can you open this hall ? &lt;/s&gt; &lt;s&gt;i think i deeply take your passenger .&lt;/s&gt; 
