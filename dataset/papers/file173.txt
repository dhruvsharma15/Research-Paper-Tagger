The human brain is a computational marvel compared to man-made systems, both in its ability to learn to execute highly complex cognitive tasks, as well as in its energy efficiency. The computational efficiency of the brain stems from its use of sparsely issued binary signals or spikes to encode and process information. Inspired by this, spiking neural networks (SNNs) have been proposed as a computational framework for learning and inference [1]. General purpose graphical processing units (GP-GPUs) have become an ideal platform for accelerated implementation of large scale machine learning algorithms [2]. There have been multiple GPU based implementations for simulating large SNNs [3]- [8], with most of these targeting the forward communication of spikes through large networks of spiking neurons and/or local weight update based on spike timing difference. In contrast, we demonstrate a highly optimized real time implementation scheme for spike based supervised learning on GPU platforms and use the framework for real time inference on digits captured from different users through a touch-screen interface.Previous efforts to develop deep convolutional spiking net- works started by using second generation artificial neural networks (ANNs) with back-propagation of errors to train the network and thereafter converting it into spiking versions [9]- [12]. There have been several supervised learning algorithms proposed to train the SNNs, by explicitly using the time of spikes of neurons to encode information, and to derive the appropriate weight update rules to minimize the distance between desired spike times and observed spike times in a network [13]- [17]. We use the Normalized Approximate Descent (NormAD) algorithm to design a system to identify handwritten digits. The NormAD algorithm has shown supe- rior convergence speed compared to other methods such as the Remote Supervised Method (ReSuMe) [13].Our SNN is trained on the MNIST database consisting of 60, 000 training images and 10, 000 test images [18]. The highest accuracy SNN for the MNIST was reported in [16], where a two-stage convolution neural network achieved an accuracy of 99.31% on the test set. Our network, in contrast, has just three layers, with about 82, 000 learning synapses (7× fewer parameters compared to [16]) and achieves an accuracy of 98.06% on the MNIST test dataset.The paper is organized as follows. The computational units of the SNN and the network architecture are described in section II. Section III details how the network simulation is divided among different CUDA kernels. The user-interface system and the image pre-processing steps are explained in Section IV. We present the results of our network simulation and speed related optimizations in Section V. Section VI concludes our GPU based system implementation study.The basic units of an SNN are spiking neurons and synapses interconnecting them. For computational tractability, we use the leaky integrate and fire (LIF) model of neurons, where the evolution of the membrane potential, V m (t) is described by:Here, the summed δ function represents the incoming spike train and the double decaying exponentials with τ 1 = 5 ms and τ 2 = 1.25 ms represent the synaptic kernel. These values closely match the biological time constants [19].in the output layer generates a spike train with a frequency close to 285 Hz and the other output neurons issue no spikes during the presentation duration, T (set to 100 ms in baseline experiments). T is also a hyper-parameter of our network, and its effect on the network's classification ability will be discussed in section V. This layer also has lateral inhibitory connections that helps to prevent the non-label neurons from spiking for a given input. The output neuron with the highest number of spikes is declared the winner of the classification.We use a three-layered network where hidden layer per- forms feature extraction and the output layer performs clas- sification (see Fig. 1). The network is designed to take input from 28×28 pixel MNIST digit image. We translate this pixel value into a set of spike streams, by passing the pixels as currents to a layer of 28 × 28 neurons (first layer). The current i(k) applied to a neuron corresponding to pixel value k, in the range [0,255] is obtained by the following linear relation:The 8112×10 synapses connecting the hidden layer neurons to the 10 output layer neurons are modified during the course of training using the NormAD rule [13]. The strength of the weights are adjusted based on the error between the observed and desired spike streams (e(t) = S d (t) − S o (t)) and the termˆdtermˆ termˆd(t), denoting the effect of incoming spike kernels on the neuron's membrane potential, according to the relation:where I p = 101.2 pA is a scaling factor, and I 0 = 2700 pA is the minimum current above which an LIF neuron can generate a spike (for the parameters chosen in equation 1). These spike streams are then weighted with twelve 3 × 3 synaptic weight maps (or filters), with a priori chosen values to generate equivalent current streams using equations 2 and 3. These 12 spatial filter maps are chosen to detect various edges and corners in the image.represents the neuron's impulse response with τ L = 1 ms, and r is the learning rate. The SNN is implemented on a GPU platform using the CUDA-C programming framework. A GPU is divided into streaming multiprocessors (SM), each of which consists of stream processors (SP) that are optimized to execute math operations. The CUDA-C programming framework exploits the hardware parallelism of GPUs and launches jobs on the GPU in a grid of blocks each mapped to an SM. The blocks are further divided into multiple threads, each of which is scheduled to run on an SP, also called a CUDA core. Since memory transfer between CPU and GPU local memory is one of the main bottlenecks, all network variables (i.e., neuron membrane potentials and synaptic currents) are declared in the global GPU memory in our implementation. The simulation equations (1), (2) and (3) are evaluated numerically in an iterative manner at each time step.Next time step Fig. 1: The 28×28 pixel images from the MNIST database are converted to spike trains, which are presented for a duration T , weighted with twelve 3 × 3 synaptic weight maps (below) resulting in twelve 26 × 26 current streams and then feed to the corresponding feature map neurons. There are 10 output neurons corresponding to each digit. The weights of the fully- connected feed-forward synapses to the output layer neurons (8112 × 10) are adjusted using the NormAD learning rule [13]. Additionally, the output layer neurons also have lateral inhibitory connections.  The output layer consists of 10 neurons, one for each of the ten digits. We train the network so that the correct neuron  Fig. 2 shows the forward pass and backward pass for weight update during the training phase. Image pixels read into the GPU memory are passed as currents to layer one neurons (grid size of 28 × 28) for the presentation duration, T . The filtering process involves 2D convolution of the incoming spike kernels and the weight matrix (3 × 3). The computation is parallelized across 12 CUDA kernels, each with a grid size of 26 × 26 threads. Each thread computes the current to the hidden layer neurons, indexed as a 2D-array i, j, {0 ≤ i, j, ≤ 25} at a time- step n, based on the following spatial convolution relation: update the synaptic weights in parallel. The evaluation of the total synaptic current and the norm is performed using parallel reduction in CUDA [20]. During the inference or testing phase, we calculate the synaptic currents and membrane potentials of neurons in both layers to determine spike times, but do not evaluate thê d term and the weight update.where c represents the synaptic kernel (equation 2) calculated from the spike trains of the 28 × 28 pixels and w conv (a, b) represents each of the weights from the 3 × 3 filter matrix.The membrane potential of an array of k LIF neurons, for applied current I(n) (as described in equation 1) is evaluated using the second order Runge-Kutta method as:Each thread k independently checks if the membrane potential has exceeded the threshold to artificially reset it.We used the CUDA based SNN described in the previous section, to design a user interface that can capture and identify the images of digits written by users in real-time from a touch- screen interface. The drawing application to capture the digit drawn by the user is built using OpenCV, an image processing library [21]. The captured image from the touch screen is pre-processed using standard methods similar to that used to generate the MNIST dataset images [18]. We convert the user drawn images to the required format which is a grayscale image of size 28 × 28 pixels. The network is implemented on the NVIDIA GTX 860M GPU which has 640 CUDA cores. The preprocessing phase takes about 15 ms and this image is then passed to the trained SNN for inference. The CUDA process takes about 300 ms to initialize the network in the GPU memory, after which the network simulation time depends on the presentation time T and the time step interval ∆t.Refractory period is implemented by storing the latest spike issue time, n last k of each neuron in a vector R; the membrane potential of a neuron is updated only when the current time step n &gt; n The synaptic current from neuron k in hidden layer to neuron l in output layer as given in equation 3 can be re-written to be evaluated in an iterative manner, thereby avoiding the evaluation of expensive exponential of the difference between the current time n and previous spike times n i k . The synaptic current computation, at time step n, for each of the (k, l) synapse is spawned in CUDA across 8112 × 10 kernels as:where a k (n) and b k (n) represent the rising and falling regions of the double exponential synaptic kernel. The strength of the synapses between the hidden and output layers is initialized to zero during training. At every time step, the error function for each output neuron is calculated, based on the difference between the observed and desired spikes. Next, ˆ d k (equation 5) for the spikes originating from neuron k is computed as: Fig. 3(a) shows the preprocessing steps used to create the input signal to the SNN from the captured image and Fig. 3(b) shows some sample pre-processed images. The image captured from the user is first binarized by thresholding and cropped to remove excess background. The image is resized to 20 pixels along its longer dimension, while maintaining its aspect ratio. Thereafter, the resized image is placed in a 28 × 28 bounding box such that the image's center of mass coincides with the center of the bounding box. Finally, the image is passed through a blurring filter to create gray-scale images similar to the ones in the MNIST dataset.d k (n) is evaluated, we compute its norm across all k neurons and determine the instantaneous ∆w k,l (n) for all the 81, 120 synapses in parallel, if there is a spike error. At the end of presentation, the accumulated ∆w k,l is used to We trained the network on the MNIST training data-set consisting of 60, 000 images, for 20 epochs. Our network achieves an error of 0.2% on the training set and 1.94% on the test set with a time step of ∆t = 0.1 ms when the network is simulated for T = 100 ms. Table I lists the state-of-the- art networks (ANN and SNN) for the MNIST classification problem. It can be seen that though these networks have classification accuracies exceeding 99%, they use more than 7× the number of parameters compared to our network, which is designed to simplify the computational load in developing real-time system. with non-local weight update rules on a GPU platform. At each time step, the neuronal spike transmission, synaptic current computation and weight update calculation for the network are all executed in parallel in this framework. Using this GPU implementation, we demonstrated a touch-screen based platform for real-time classification of user-generated images.Learning synapses Accuracy Deep Learning [22] 2, 508, 470 99.79% ANN converted to SNN [9] 1, 422, 848 99.12% 4-layer convolution SNN [16] 581, 520 99.31% SNN, with NormAD (this work) 81, 120 98.06%If the integration time step interval used during inference is 1 ms (i.e., approximating the neuronal integration) instead of 0.1 ms, the MNIST test error increases only by about 0.4% (see Fig. 4(a)), but there is a 10× reduction in the processing time. Hence, for our touch screen based interface system we simulate the SNN with ∆t of 1 ms to infer the users' digits. When each digit is presented for T = 75 ms, the network can be simulated in an average wall clock time of 65 ms, making real-time processing possible (Fig. 4(b)). We tested Time [ms] (b).Presentation time [ms] (a). the network's accuracy with ∆t = 1 ms on a set of 500 handwritten digits collected from various users through our user-interface system. At T = 75 ms, we measure an accuracy of 97.4% on our set of 500 captured images, while on the MNIST test-set it was 97.68%. The slight loss in performance compared to the MNIST dataset is attributed to the deviations from the statistical characteristics of the captured images compared to the MNIST dataset.We developed a simple three-layer spiking neural network that performs spike encoding, feature extraction, and classi- fication. All information processing and learning within the network is performed entirely in the spike domain. With approximately 7 times lesser number of synaptic weight pa- rameters compared to the state of the art spiking networks, we show that our approach achieves classification accuracy exceeding 99% on the training set of the MNIST database and 98.06% on its test set. The trained network implemented on the CUDA parallel computing platform is also able to successfully identify digits written by users in real-time, demonstrating its true generalization capability.We have also demonstrated a general framework for imple- menting spike based neural networks and supervised learning
