We consider the time-series prediction task of producing a desired output y t at each timestep t ∈ {1, . . . , T } given an observed input sequence x 1:t = {x 1 , x 2 , · · · , x t }, where x t ∈ R R and y t ∈ R S are vectors 1 . The Recurrent Neural Network (RNN) [17,43] is a powerful model that learns how to use a hidden state vector h t ∈ R M to encapsulate the relevant features of the entire input history x 1:t up to timestep t. Let h cat t−1 ∈ R R+M be the concatenation of the current input x t and the previous hidden state h t−1 :The update of the hidden state h t is defined as:where W h ∈ R (R+M )×M is the weight, b h ∈ R M the bias, a t ∈ R M the hidden activation, and φ(·) the element-wise tanh function. Finally, the output y t at timestep t is generated by:where W y ∈ R M×S and b y ∈ R S , and ϕ(·) can be any differentiable function, depending on the task.However, this vanilla RNN has difficulties in modeling long-range dependencies due to the van- ishing/exploding gradient problem [4]. Long Short-Term Memories (LSTMs) [19,24] alleviate these problems by employing memory cells to preserve information for longer, and adopting gating mechanisms to modulate the information flow. Given the success of the LSTM in sequence modeling, it is natural to consider how to increase the complexity of the model and thereby increase the set of tasks for which the LSTM can be profitably applied.We consider the capacity of a network to consist of two components: the width (the amount of information handled in parallel) and the depth (the number of computation steps) [5]. A naive way to widen the LSTM is to increase the number of units in a hidden layer; however, the parameter number scales quadratically with the number of units. To deepen the LSTM, the popular Stacked LSTM (sLSTM) stacks multiple LSTM layers [20]; however, runtime is proportional to the number of layers and information from the input is potentially lost (due to gradient vanishing/explosion) as it propagates vertically through the layers.In this paper, we introduce a way to both widen and deepen the LSTM whilst keeping the parameter number and runtime largely unchanged. In summary, we make the following contributions: (a) We tensorize RNN hidden state vectors into higher-dimensional tensors which allow more flexible parameter sharing and can be widened more efficiently without additional parameters. (b) Based on (a), we merge RNN deep computations into its temporal computations so that the network can be deepened with little additional runtime, resulting in a Tensorized RNN (tRNN). (c) We extend the tRNN to an LSTM, namely the Tensorized LSTM (tLSTM), which integrates a novel memory cell convolution to help to prevent the vanishing/exploding gradients.It can be seen from (2) that in an RNN, the parameter number scales quadratically with the size of the hidden state. A popular way to limit the parameter number when widening the network is to organize parameters as higher-dimensional tensors which can be factorized into lower-rank sub-tensors that contain significantly fewer elements [6,15,18,26,32,39,46,47,51], which is is known as tensor factorization. This implicitly widens the network since the hidden state vectors are in fact broadcast to interact with the tensorized parameters. Another common way to reduce the parameter number is to share a small set of parameters across different locations in the hidden state, similar to Convolutional Neural Networks (CNNs) [34,35].We adopt parameter sharing to cutdown the parameter number for RNNs, since compared with factorization, it has the following advantages: (i) scalability, i.e., the number of shared parameters can be set independent of the hidden state size, and (ii) separability, i.e., the information flow can be carefully managed by controlling the receptive field, allowing one to shift RNN deep computations to the temporal domain (see Sec. 2.2). We also explicitly tensorize the RNN hidden state vectors, since compared with vectors, tensors have a better: (i) flexibility, i.e., one can specify which dimensions to share parameters and then can just increase the size of those dimensions without introducing additional parameters, and (ii) efficiency, i.e., with higher-dimensional tensors, the network can be widened faster w.r.t. its depth when fixing the parameter number (see Sec. 2.3).For ease of exposition, we first consider 2D tensors (matrices): we tensorize the hidden state h t ∈ R M to become H t ∈ R P×M , where P is the tensor size, and M the channel size. We locally-connect the first dimension of H t in order to share parameters, and fully-connect the second dimension of H t to allow global interactions. This is analogous to the CNN which fully-connects one dimension (e.g., the RGB channel for input images) to globally fuse different feature planes. Also, if one compares H t to the hidden state of a Stacked RNN (sRNN) (see Fig. 1(a)), then P is akin to the number of stacked hidden layers, and M the size of each hidden layer. We start to describe our model based on 2D tensors, and finally show how to strengthen the model with higher-dimensional tensors.Since an RNN is already deep in its temporal direction, we can deepen an input-to-output computation by associating the input x t with a (delayed) future output. In doing this, we need to ensure that the output y t is separable, i.e., not influenced by any future input x t (t &gt; t). Thus, we concatenate the projection of x t to the top of the previous hidden state H t−1 , then gradually shift the input In each model, the blank circles in column 1 to 4 denote the hidden state at timestep t−1 to t+2, respectively, and the blue region denotes the receptive field of the current output y t . In (b)-(e), the outputs are delayed by L−1 = 2 timesteps, where L = 3 is the depth. information down when the temporal computation proceeds, and finally generate y t from the bottom of H t+L−1 , where L−1 is the number of delayed timesteps for computations of depth L. An example with L = 3 is shown in Fig. 1(b). This is in fact a skewed sRNN as used in [1] (also similar to [48]). However, our method does not need to change the network structure and also allows different kinds of interactions as long as the output is separable, e.g, one can increase the local connections and use feedback (see Fig. 1(c)), which can be beneficial for sRNNs [10]. In order to share parameters, we update H t using a convolution with a learnable kernel. In this manner we increase the complexity of the input-to-output mapping (by delaying outputs) and limit parameter growth (by sharing transition parameters using convolutions).To describe the resulting tRNN model, let H cat t−1 ∈ R (P +1)×M be the concatenated hidden state, and p ∈ Z + the location at a tensor. The channel vector hwhere W x ∈ R R×M and b x ∈ R M . Then, the update of tensor H t is implemented via a convolution:whereis the hidden activation, and is the convolution operator (see Appendix A.1 for a more detailed definition). Since the kernel convolves across different hidden layers, we call it the cross-layer convolution. The kernel enables interaction, both bottom-up and top-down across layers. Finally, we generate y t from the channel vector h t+L−1,P ∈ R M which is located at the bottom of H t+L−1 :where W y ∈ R M×S and b y ∈ R S . To guarantee that the receptive field of y t only covers the current and previous inputs x 1:t (see Fig. 1(c)), L, P , and K should satisfy the constraint:where is the ceil operation. For the derivation of (9), please see Appendix B.We call the model defined in (5)-(8) the Tensorized RNN (tRNN). The model can be widened by increasing the tensor size P , whilst the parameter number remains fixed (thanks to the convolution). Also, unlike the sRNN of runtime complexity O(T L), tRNN breaks down the runtime complexity to O(T +L), which means either increasing the sequence length T or the network depth L would not significantly increase the runtime.To allow the tRNN to capture long-range temporal dependencies, one can straightforwardly extend it to an LSTM by replacing the tRNN tensor update equations of (6)- (7) as follows:P×M are activations for the new content G t , input gate I t , forget gate F t , and output gate O t , respectively, σ(·) is the element-wise sigmoid function, and C t ∈ R P×M is the memory cell. However, since in (12) the previous memory cell C t−1 is only gated along the temporal direction (see Fig. 1(d)), long-range dependencies from the input to output might be lost when the tensor size P becomes large.Memory Cell Convolution. To capture long-range dependencies from multiple directions, we additionally introduce a novel memory cell convolution, by which the memory cells can have a larger receptive field (see Fig. 1(e)). We also dynamically generate this convolution kernel so that it is both time-and location-dependent, allowing for flexible control over long-range dependencies from different directions. This results in our tLSTM tensor update equations:where, in contrast to (10)-(13), the kernel {W h , b h } has additional output channels 2 to generate the activation A q t ∈ R P× for the dynamic kernel bank Q t ∈ R P× , q t,p ∈ R is the vectorized adaptive kernel at the location p of Q t , and W c t (p) ∈ R K×1×1 is the dynamic kernel of size K with a single input/output channel, which is reshaped from q t,p (see Fig. 2(a) for an illustration). In (17), each channel of the previous memory cell C t−1 is convolved with W c t (p) whose values vary with p, forming a memory cell convolution (see Appendix A.2 for a more detailed definition), which produces a convolved memory cell C conv Figure 2: Illustration of gener- ating the memory cell convolu- tion kernel, where (a) is for 2D tensors and (b) for 3D tensors. (15) we employ a softmax function ς(·) to normalize the channel dimension of Q t , which, similar to [37], can stabilize the value of memory cells and help to prevent the vanishing/exploding gradients (see Appendix C for details).The idea of dynamically generating network weights has been used in many works [6,14,15,23,44,46], where in [14] location- dependent convolutional kernels are also dynamically generated to improve CNNs. In contrast to these works, we focus on broadening the receptive field of tLSTM memory cells. Whilst the flexibility is retained, fewer parameters are required to generate the kernel since the kernel is shared by different memory cell channels.Channel Normalization. To improve training, we adapt Layer Normalization (LN) [3] to our tLSTM. Similar to the observation in [3] that LN does not work well in CNNs where channel vectors at different locations have very different statistics, we find that LN is also unsuitable for tLSTM where lower level information is near the input while higher level information is near the output. We therefore normalize the channel vectors at different locations with their own statistics, forming a Channel Normalization (CN), with its operator CN (·):where Z, Z, Γ, B ∈ R P ×M z are the original tensor, normalized tensor, gain parameter, and bias parameter, respectively. The m z -th channel of Z, i.e. z m z ∈ R P , is normalized element-wisely:where z µ , z σ ∈ R P are the mean and standard deviation along the channel dimension of Z, respec- tively, and z m z ∈ R P is the m z -th channel of Z. Note that the number of parameters introduced by CN/LN can be neglected as it is very small compared to the number of other parameters in the model.Using Higher-Dimensional Tensors. One can observe from (9) that when fixing the kernel size K, the tensor size P of a 2D tLSTM grows linearly w.r.t. its depth L. How can we expand the tensor volume more rapidly so that the network can be widened more efficiently? We can achieve this goal by leveraging higher-dimensional tensors. Based on previous definitions for 2D tLSTMs, we replace the 2D tensors withSince the hidden states are no longer matrices, we concatenate the projection of x t to one corner of H t−1 , and thus (5) is extended as:For the tensor update, the convolution kernel W h and W c t (·) also increase their dimensionality with kernel sizeis reshaped from the vector, as illustrated in Fig. 2(b). Correspondingly, we generate the output y t from the opposite corner of H t+L−1 , and therefore (8) is modified as:For convenience, we set P d = P and K d = K for d = 1, 2, . . . , D − 1 so that all dimensions of P and K can satisfy (9) with the same depth L. In addition, CN still normalizes the channel dimension of tensors.We evaluate tLSTM on five challenging sequence learning tasks under different configurations: To compare different configurations, we also use L to denote the number of layers of a sLSTM, and M to denote the hidden size of each sLSTM layer. We set the kernel size K to 2 for 2D tLSTM-F and 3 for other tLSTMs, in which case we have L = P according to (9).For each configuration, we fix the parameter number and increase the tensor size to see if the performance of tLSTM can be boosted without increasing the parameter number. We also investigate how the runtime is affected by the depth, where the runtime is measured by the average GPU milliseconds spent by a forward and backward pass over one timestep of a single example. Next, we compare tLSTM against the state-of-the-art methods to evaluate its ability. Finally, we visualize the internal working mechanism of tLSTM. Please see Appendix D for training details.The Hutter Prize Wikipedia dataset [25] consists of 100 million characters taken from 205 different characters including alpha- bets, XML markups and special symbols. We model the dataset at the character-level, and try to predict the next character of the input sequence.We fix the parameter number to 10M, corresponding to channel sizes M of 1120 for sLSTM and 2D tLSTM-F, 901 for other 2D tLSTMs, and 522 for 3D tLSTMs. All configurations are evaluated with depths L = 1, 2, 3, 4. We use Bits-per-character (BPC) to measure the model performance.  Whilst the runtime of sLSTM is al- most proportional to L, it is nearly constant in each tLSTM configuration and largely independent of L. We compare a larger model, i.e. a 3D tLSTM+CN with L = 6 and M = 1200, to the state-of-the-art methods on the test set, as reported in Table 1. Our model achieves 1.264 BPC with 50.1M parameters, and is competitive to the best performing methods [38,54] with similar parameter numbers.(a) Addition: The task is to sum two 15-digit integers. The network first reads two integers with one digit per timestep, and then predicts the summation. We follow the pro- cessing of [30], where a symbol '-' is used to delimit the integers as well as pad the input/target se- quence. A 3-digit integer addition task is of the form:Input: -1 2 3 -9 0 0 ----- Target: --------1 0 2 3 - We evaluate all configurations with L = 1, 4, 7, 10 on both tasks, where M is 400 for addition and 100 for memorization. The performance is measured by the symbol prediction accuracy. Fig. 4 show the results. In both tasks, large L degrades the performances of sLSTM and 2D tLSTM- M. In contrast, the performance of 2D tLSTM-F steadily improves with L increasing, and is further enhanced by using feedback connections, higher-dimensional tensors, and CN, while LN helps only when L = 1. Note that in both tasks, the correct solution can be found (when 100% test accuracy is achieved) due to the repetitive nature of the task. In our experiment, we also observe that for the addition task, 3D tLSTM+CN with L = 7 outperforms other configurations and finds the solution with only 298K training samples, while for the memorization task, 3D tLSTM+CN with L = 10 beats others configurations and achieves perfect memorization after seeing 54K training samples. Also, unlike in sLSTM, the runtime of all tLSTMs is largely unaffected by L. We further compare the best performing configurations to the state-of-the-art methods for both tasks (see Table 2). Our models solve both tasks significantly faster (i.e., using fewer training samples) than other models, achieving the new state-of-the-art results.The MNIST dataset [35] consists of 50000/10000/10000 handwritten digit images of size 28×28 for train- ing/validation/test. We have two tasks on this dataset:(a) Sequential MNIST: The goal is to classify the digit after sequen- tially reading the pixels in a scan- line order [33]. It is therefore a 784 timestep sequence learning task where a single output is produced at the last timestep; the task requires very long range dependencies in the sequence. We permute the original image pix- els in a fixed random order as in [2], resulting in a permuted MNIST (pMNIST) problem that has even longer range dependencies across pixels and is harder.In both tasks, all configurations are evaluated with M = 100 and L = 1, 3, 5. The model performance is measured by the classification accuracy.Results are shown in Fig. 5. sLSTM and 2D tLSTM-M no longer benefit from the increased depth when L = 5. Both increasing the depth and tensorization boost the performance of 2D tLSTM. However, removing feedback connections from 2D tLSTM seems not to affect the performance. On the other hand, CN enhances the 3D tLSTM and when L ≥ 3 it outperforms LN. 3D tLSTM+CN with L = 5 achieves the highest performances in both tasks, with a validation accuracy of 99.1% for MNIST and 95.6% for pMNIST. The runtime of tLSTMs is negligibly affected by L, and all tLSTMs become faster than sLSTM when L = 5.   [49] 96.9 94.1 sTANH [53] 98.1 94.0 BN-LSTM [13] 99.0 95.4 Dilated GRU [8] 99.2 94.6 Dilated CNN [40] in [8] 98.3 96.799.0 95.7We also compare the configura- tions of the highest test accuracies to the state-of-the-art methods (see Table 3). For sequential MNIST, our 3D tLSTM+CN with L = 3 performs as well as the state-of-the-art Dilated GRU model [8], with a test accu- racy of 99.2%. For the sequential pMNIST, our 3D tLSTM+CN with L = 5 has a test accuracy of 95.7%, which is close to the state-of-the-art of 96.7% produced by the Dilated CNN [40] in [8].The experimental results of different model configurations on different tasks suggest that the perfor- mance of tLSTMs can be improved by increasing the tensor size and network depth, requiring no additional parameters and little additional runtime. As the network gets wider and deeper, we found that the memory cell convolution mechanism is crucial to maintain improvement in performance. Also, we found that feedback connections are useful for tasks of sequential output (e.g., our Wikipedia and algorithmic tasks). Moreover, tLSTM can be further strengthened via tensorization or CN.It is also intriguing to examine the internal working mechanism of tLSTM. Thus, we visualize the memory cell which gives insight into how information is routed. For each task, the best performing tLSTM is run on a random example. We record the channel mean (the mean over channels, e.g., it is of size P ×P for 3D tLSTMs) of the memory cell at each timestep, and visualize the diagonal values of the channel mean from location p in = [1, 1] (near the input) to p out = [P, P ] (near the output).Visualization results in Fig. 6 reveal the distinct behaviors of tLSTM when dealing with different tasks: (i) Wikipedia: the input can be carried to the output location with less modification if it is sufficient to determine the next character, and vice versa; (ii) addition: the first integer is gradually encoded into memories and then interacts (performs addition) with the second integer, producing the sum; (iii) memorization: the network behaves like a shift register that continues to move the input symbol to the output location at the correct timestep; (iv) sequential MNIST: the network is more sensitive to the pixel value change (representing the contour, or topology of the digit) and can gradually accumulate evidence for the final prediction; (v) sequential pMNIST: the network is sensitive to high value pixels (representing the foreground digit), and we conjecture that this is because the permutation destroys the topology of the digit, making each high value pixel potentially important.From Fig. 6 we can also observe common phenomena for all tasks: (i) at each timestep, the values at different tensor locations are markedly different, implying that wider (larger) tensors can encode more information, with less effort to compress it; (ii) from the input to the output, the values become increasingly distinct and are shifted by time, revealing that deep computations are indeed performed together with temporal computations, with long-range dependencies carried by memory cells. Convolutional LSTMs. Convolutional LSTMs (cLSTMs) are proposed to parallelize the compu- tation of LSTMs when the input at each timestep is structured (see Fig. 7(a)), e.g., a vector array [48], a vector matrix [41,42,50,52], or a vector tensor [9,45]. Unlike cLSTMs, tLSTM aims to increase the capacity of LSTMs when the input at each timestep is non-structured, i.e., a single vector, and is advantageous over cLSTMs in that: (i) it performs the convolution across different hidden layers whose structure is independent of the input structure, and integrates information bottom-up and top-down; while cLSTM performs the convolution within each hidden layer whose structure is coupled with the input structure, thus will fall back to the vanilla LSTM if the input at each timestep is a single vector; (ii) it can be widened efficiently without additional parameters by increasing the tensor size; while cLSTM can be widened by increasing the kernel size or kernel channel, which significantly increases the number of parameters; (iii) it can be deepened with little additional run- time by delaying the output; while cLSTM can be deepened by using more hidden layers, which significantly increases the runtime; (iv) it captures long-range dependencies from multiple directions through the memory cell convolution; while cLSTM struggles to capture long-range dependencies from multiple directions since memory cells are only gated along one direction.Deep LSTMs. Deep LSTMs (dLSTMs) extend sLSTMs by making them deeper (see Fig. 7 [54] apply another RNN/LSTM along the depth direction of dLSTMs, which, however, multiplies the runtime. Though there are implementations to accelerate the deep computation [1,16], they generally aim at simple architectures such sLSTMs. Compared with dLSTMs, tLSTM performs the deep computation with little additional runtime, and employs a cross-layer convolution to enable the feedback mechanism. Moreover, the capacity of tLSTM can be increased more efficiently by using higher-dimensional tensors, whereas in dLSTM all hidden layers as a whole only equal to a 2D tensor (i.e., a stack of hidden vectors), the dimensionality of which is fixed.Other Parallelization Methods. Some methods [7,8,28,29,36,40] parallelize the temporal computation of the sequence (e.g., use the temporal convolution, as in Fig. 7(e)) during training, in which case full input/target sequences are accessible. However, during the online inference when the input presents sequentially, temporal computations can no longer be parallelized and will be blocked by deep computations of each timestep, making these methods potentially unsuitable for real-time applications that demand a high sampling/output frequency. Unlike these methods, tLSTM can speed up not only training but also online inference for many tasks since it performs the deep computation by the temporal computation, which is also human-like: we convert each signal to an action and meanwhile receive new signals in a non-blocking way. Note that for the online inference of tasks that use the previous output y t−1 for the current input x t (e.g., autoregressive sequence generation), tLSTM cannot parallel the deep computation since it requires to delay L−1 timesteps to get y t−1 .We introduced the Tensorized LSTM, which employs tensors to share parameters and utilizes the temporal computation to perform the deep computation for sequential tasks. We validated our model on a variety of tasks, showing its potential over other popular approaches.The hidden state convolution in (6) is defined as:where m o ∈ {1, 2, · · · , M o } and zero padding is applied to keep the tensor size.The memory cell convolution in (17) is defined as:To prevent the stored information from being flushed away, C t−1 is padded with the replication of its boundary values instead of zeros or input projections.B Derivation for the Constraint of L, P , and K Figure 8: Illustration of calculating the constraint of L, P , and K. Each column is a concatenated hidden state tensor with tensor size P +1 = 4 and channel size M . The volume of the output receptive field (blue region) is determined by the kernel radius K r . The output y t for current timestep t is delayed by L−1 = 2 timesteps.Here we derive the constraint of L, P , and K that is defined in (9). The kernel center location is ceiled in case that the kernel size K is not odd. Then, the kernel radius K r can be calculated by:As shown in Fig. 8, to guarantee the receptive field of y t covers x 1:t while does not cover x t+1:T , the following constraint should be satisfied:tan ∠AOD tan ∠BOD &lt; tan ∠COD (27) which means:Plugging (26) into (28), we get:C Memory Cell Convolution Helps to Prevent the Vanishing/Exploding Gradients Leifert et al. [37] have proved that the lambda gate, which is very similar to our memory cell convolution kernel, can help to prevent the vanishing/exploding gradients (see Theorem 17-18 in [37]). The differences between our approach and their lambda gate are: (i) we normalize the kernel values though a softmax function, while they normalize the gate values by dividing them with their sum, and (ii) we share the kernel for all channels, while they do not. However, as neither modifications affects the conditions of validity for Theorem 17-18 in [37], our memory cell convolution can also help to prevent the vanishing/exploding gradients.The training objective is to minimize the negative log-likelihood (NLL) of the training sequences w.r.t. the parameter θ (vectorized), i.e., where N is the number of training sequences, T n the length of the n-th training sequence, and p(y d n,t |f (x d n,1:t ; θ)) the likelihood of target y d n,t conditioned on its prediction y n,t = f (x d n,1:t ; θ). Since all experiment are classification problems, y d n,t is represented as the one-hot encoding of the class label, and the output function ϕ(·) is defined as a softmax function, which is used to generate the class distribution y n,t . Then, the likelihood can be calculated by p(y d n,t |y n,t ) = y n,t,s | y d n,t,s =1 .In all tasks, the NLL (see (30)) is used as the training objective and is minimized by Adam [31] with a learning rate of 0.001. Forget gate biases are set to 4 for image classification tasks and 1 [27] for others. All models are implemented by Torch7 [12] and accelerated by cuDNN on Tesla K80 GPUs.We only apply CN to the output of the tLSTM hidden state as we have tried different combinations and found this is the most robust way that can always improve the performance for all tasks. With CN, the output of hidden state becomes:As in [10], we split the dataset into 90M/5M/5M for training/validation/test. In each iteration, we feed the model with a mini-batch of 100 subsequences of length 50. During the forward pass, the hidden values at the last timestep are preserved to initialize the next iteration. We terminate training after 50 epochs.Following [30], for both tasks we randomly generate 5M samples for training and 100 samples for test, and set the mini-batch size to 15. Training proceeds for at most 1 epoch 3 and will be terminated if 100% test accuracy is achieved.We set the mini-batch size to 50 and use early stopping for training. The training loss is calculated at the last timestep.
