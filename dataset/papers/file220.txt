D EEP learning has achieved significant success in many perception tasks including seeing (visual object recognition), reading (text understanding), and hearing (speech recognition). These are undoubtedly fundamental tasks for a functioning comprehensive artificial intelligence (AI) or data engineering (DE) system. However, in order to build a real AI/DE system, simply being able to see, read, and hear is far from enough. It should, above all, possess the ability to think.Take medical diagnosis as an example. Besides seeing visible symptoms (or medical images from CT) and hearing descriptions from patients, a doctor has to look for relations among all the symptoms and preferably infer the corresponding etiology. Only after that can the doctor provide medical advice for the patients. In this example, although the abilities of seeing and hearing allow the doctor to acquire information from the patients, it is the thinking part that defines a doctor. Specifically, the ability to think here could involve causal inference, logic deduction, and dealing with uncertainty, which is apparently beyond the capability of conventional deep learning methods. Fortunately, another type of models, probabilistic graphical models (PGM), excels at causal inference and dealing with uncertainty. The problem is that PGM is not as good as deep learning models at perception tasks. To address the problem, it is, therefore, a natural choice to tightly integrate deep learning and PGM within a principled probabilistic framework, which we call Bayesian deep learning (BDL)  With the tight and principled integration in BDL, perception tasks and inference tasks are regarded as a whole and can benefit from each other. In the example above, being able to see the medical image could help with the doctor's diagnosis and inference. On the other hand, diagnosis and inference can in return help with understanding the medical image. Suppose a doctor is not sure what a dark spot in a medical image is. However, if she is able to infer the etiology of the symptoms and disease, it can help her better decide whether the dark spot is a tumor or not.As another example, to achieve high accuracy in recommender systems (RS) [1], [39], [40], [50], [67], we need to fully understand the content of the items (e.g., documents and movies) [46], analyze the profile and preferences of users [70], [73], and evaluate the similarity among the users [3], [11], [29]. Deep learning is good at the first subtask while PGM excels at the other two. Besides the fact that better understanding of item content would help with the analysis of user profiles, the estimated similarity among users could also provide valuable information for understanding item content in return. In order to fully utilize this bidirectional effect to boost recommendation accuracy, we might wish to unify deep learning and PGM in one single principled probabilistic framework, as seen in [67].Besides recommender systems, the need for BDL may also arise when we are dealing with the control of non-linear dynamic systems with raw images as input. Consider controlling a complex dynamical system according to the live video stream received from a camera. This problem can be transformed into iteratively performing two tasks, perception from raw images and control based on dynamic models. The perception task can be taken care of using multiple layers of simple nonlinear transformation (deep learning) while the control task usually needs more sophisticated models like hidden Markov models and Kalman filters [22]. The feedback loop is then completed by the fact that actions chosen by the control model can affect the received video stream in return. To enable an effective iterative process between the perception task and the control task, we need two-way information exchange between them. The perception component would be the basis on which the control component estimates its states and the control component with a built-in dynamic model would be able to predict the future trajectory (images). In such cases, BDL is a suitable choice [69].As mentioned in the examples above, BDL is particularly useful for tasks that involve both understanding of content (e.g., text, images, and videos) and inference/reasoning among variables. In such complex tasks, the perception component of BDL is responsible for the understanding of the content, and the task-specific component (e.g., the control component in dynamical systems) models the probabilistic relationship among different variables. Furthermore, the interaction between these two components creates synergy and further boosts the performance.Apart from the major advantage of BDL providing a principled way of unifying deep learning and PGM, another benefit comes from the implicit regularization built into BDL. Through imposing a prior on hidden units, parameters defining a neural network, or the model parameters specifying the causal inference, to some degree BDL can avoid overfitting, especially when there is not sufficient data. Usually, a BDL model consists of two components: (1) a perception component that is a Bayesian formulation of a certain type of neural networks and (2) a task-specific component that describes the relationship among different hidden or observed variables using PGM. Regularization is crucial for them both. Neural networks usually have large numbers of free parameters that need to be regularized properly. Regularization techniques such as weight decay and dropout [57] are shown to be effective in improving performance of neural networks and they both have Bayesian interpretations [15]. In terms of the task-specific component, expert knowledge or prior information, as a kind of regularization, can be incorporated into the model through the prior we imposed to guide the model when data are scarce.Yet another advantage of using BDL for complex tasks (tasks that need both perception and inference) is that it provides a principled Bayesian approach of handling parameter uncertainty. When BDL is applied to complex tasks, there are three kinds of parameter uncertainties that need to be taken into account:1) Uncertainty about the neural network parameters.2) Uncertainty about the task-specific parameters.3) Uncertainty about the exchange of information between the perception component and the task-specific component. Through representing the unknown parameters using distributions instead of point estimates, BDL offers a promising framework to handle these three kinds of uncertainty in a unified way. It is worth noting that the third uncertainty could only be handled under a unified framework such as BDL. If we train the perception component and the task-specific component separately, it is equivalent to assuming no uncertainty when exchanging information between the two components.Of course, there are challenges when applying BDL to real-world tasks. (1) First, it is nontrivial to design an efficient Bayesian formulation of neural networks with reasonable time complexity. This line of work has been pioneered by [25], [41], [44], but it has not been widely adopted due to its lack of scalability. Fortunately, some recent advances in this direction [2], [9], [23], [34], [66] seem to shed light on the practical adoption of Bayesian neural networks 1 . (2) The second challenge is to ensure efficient and effective information exchange between the perception component and the task-specific component. Ideally both the first-order and second-order information (e.g., the mean and the variance) should be able to flow back and forth between the two components. A natural way is to represent the perception component as a PGM and seamlessly connect it to the task-specific PGM, as done in [17], [64], [67].In this paper, we aim to give a comprehensive overview of BDL models for applications like recommender systems, topic models (and representation learning), and control. The rest of the paper is organized as follows: In Section 2, we provide a review of some basic deep learning models. Section 3 covers the main concepts and techniques for PGM. These two sections serve as the background for BDL, and the next section, Section 4, proposes a unified BDL framework and surveys the BDL models applied to areas such as recommender systems and topic models. Section 5 discusses some future research issues and concludes the paper.Deep learning normally refers to neural networks with more than two layers. To better understand deep learning, here we start with the simplest type of neural networks, multilayer perceptrons (MLP), as an example to show how conventional deep learning works. After that, we will review several other types of deep learning models based on MLP.Essentially a multilayer perceptron is a sequence of parametric nonlinear transformations. Suppose we want to train a multilayer perceptron to perform a regression task which maps a vector of M dimensions to a vector of D dimensions. We denote the input as a matrix X 0 (0 means it is the 0-th layer of the perceptron). The j-th row of X 0 , denoted as X 0,j * , is an M -dimensional vector representing one data point. The target (the output we want to fit) is denoted as Y. Similarly Y j * denotes a D-dimensional row vector. The problem of learning an L-layer multilayer perceptron can be formulated as the following optimization problem:Here we refer to Bayesian treatment of neural networks as Bayesian neural networks. The other term, Bayesian deep learning, is retained to refer to complex Bayesian models with both a perception component and a task-specific component. where σ(·) is an element-wise sigmoid function for a matrix and σ(x) = 1 1+exp (−x) . λ is a regularization parameter and · F denotes the Frobenius norm. The purpose of imposing σ(·) is to allow nonlinear transformation. Normally other transformations like tanh(x) and max(0, x) can be used as alternatives of the sigmoid function.Here X l (l = 1, 2, . . . , L − 1) is the hidden units. As we can see, X L can be easily computed once X 0 , W l , and b l are given. Since X 0 is given by the data, we only need to learn W l and b l here. Usually this is done using backpropagation and stochastic gradient descent (SGD). The key is to compute the gradients of the objective function with respect to W l and b l . If we denote the value of the objective function as E, we can compute the gradients using the chain rule as:of AE variants and as background for its applications on BDL-based recommender systems in Section 4.SDAE [59] is a feedforward neural network for learning representations (encoding) of the input data by learning to predict the clean input itself in the output, as shown in Figure 1. The hidden layer in the middle, i.e., X 2 in the figure, can be constrained to be a bottleneck to learn compact representations. The difference between traditional AE and SDAE is that the input layer X 0 is a corrupted version of the clean input data. Essentially an SDAE solves the following optimization problem:Here SDAE can be regarded as a multilayer perceptron for regression tasks described in the previous section. The input X 0 of the MLP is the corrupted version of the data and the target Y is the clean version of the data X c . For example, X c can be the raw data matrix, and we can randomly set 30% of the entries in X c to 0 and get X 0 . In a nutshell, SDAE learns a neural network that takes the noisy data as input and recovers the clean data in the last layer. This is what 'denoising' means. Normally, the output of the middle layer, i.e., X 2 in Figure 1, would be used to compactly represent the data.where l = 1, . . . , L and the regularization terms are omitted. The element-wise product is denoted as • and mean(·, 1) is the matlab operation on matrices. In practice, we only use a small part of the data (e.g., 128 data points) to compute the gradients for each update. This is called stochastic gradient descent.As we can see, in conventional deep learning models, only W l and b l are free parameters, which we will update in each iteration of the optimization. X l is not a free parameter since it can be computed exactly if W l and b l are given.Other commonly used deep learning models include convolutional neural networks (CNN) [31], [36], which apply convolution operators and pooling operators to process image or video data, and recurrent neural networks (RNN) [20], [26], which use recurrent computation to imitate human memory, and restricted Boltzmann machines (RBM) [24], which are undirected probabilistic neural networks with binary hidden and visible layers. Note that there is a vast literature on deep learning and neural networks. The introduction in this section intends to serve only as the background of BDL. Readers are referred to [20] for a comprehensive survey and more details.An autoencoder (AE) is a feedforward neural network to encode the input into a more compact representation and reconstruct the input with the learned representation. In its simplest form, an autoencoder is no more than a multilayer perceptron with a bottleneck layer (a layer with a small number of hidden units) in the middle. The idea of autoencoders has been around for decades [10], [20], [35] and abundant variants of autoencoders have been proposed to enhance representation learning including sparse AE [48], contractive AE [51], and denoising AE [59]. For more details, please refer to a nice recent book on deep learning [20]. Here we introduce a kind of multilayer denoising AE, known as stacked denoising autoencoders (SDAE), both as an example Probabilistic Graphical Models (PGM) use diagrammatic representations to describe random variables and relationships among them. Similar to a graph that contains nodes (vertices) and links (edges), PGM has nodes to represent random variables and links to express probabilistic relationships among them.As pointed out in [5], there are two main types of PGMs, directed PGMs (also known as Bayesian networks) and undirected PGMs (also known as Markov random fields), although there exist hybrid ones. In this paper we mainly focus on directed PGMs 2 . For details on undirected PGMs, readers are referred to [5].2. For convenience, PGM stands for directed PGM in this paper unless specified otherwise. Fig. 2. The probabilistic graphical model for LDA, J is the number of documents and D is the number of words in a document.A classic example of a PGM would be latent Dirichlet allocation (LDA), which is used as a topic model to analyze the generation of words and topics in documents. Usually PGM comes with a graphical representation of the model and a generative process to depict the story of how the random variables are generated step by step. Figure 2 shows the graphical model for LDA and the corresponding generative process is as follows:• For each document j (j = 1, 2, . . . , J), 1) Draw topic proportions θ j ∼ Dirichlet(α).2) For each word w jn of item (paper) w j , a) Draw topic assignment z jn ∼ Mult(θ j ). b) Draw word w jn ∼ Mult(β zjn ). The generative process above gives the story of how the random variables are generated. In the graphical model in Figure 2, the shaded node denotes observed variables while the others are latent variables (θ and z) or parameters (α and β). As we can see, once the model is defined, learning algorithms can be applied to automatically learn the latent variables and parameters.Due to its Bayesian nature, PGM like LDA is easy to extend to incorporate other information or to perform other tasks. For example, after LDA, different variants of topic models based on it have been proposed. The authors in [7], [61] proposed to incorporate temporal information and [6] extends LDA by assuming correlations among topics. To make it possible to process large datasets, [27] extends LDA from the batch mode to the online setting. On recommender systems, [60] extends LDA to incorporate rating information and make recommendations. This model is then further extended to incorporate social information [49], [62], [63].of the latent variable. Using MAP, the learning process is equivalent to minimizing (or maximizing) an objective function with regularization. One famous example is the probabilistic matrix factorization (PMF) [53]. The learning of the graphical model in PMF is equivalent to the factorization of a large matrix into two low-rank matrices with L2 regularization.MAP, as efficient as it is, gives us only point estimates of latent variables (and parameters). In order to take the uncertainty into account and harness the full power of Bayesian models, one would have to resort to Bayesian treatments such as variational inference and Markov chain Monte Carlo (MCMC). For example, the original LDA uses variational inference to approximate the true posterior with factorized variational distributions [8]. Learning of the latent variables and parameters then boils down to minimizing the KL-divergence between the variational distributions and the true posterior distributions. Besides variational inference, another choice for a Bayesian treatment is to use MCMC. For example, MCMC algorithms such as [47] have been proposed to learn the posterior distributions of LDA.With the background on deep learning and PGM, we are now ready to introduce the general framework and some concrete examples of BDL. Specifically, in this section we will list some recent BDL models with applications on recommender systems and topic models. A summary of these models is shown in Table 1.Strictly speaking, the process of finding the parameters (e.g., α and β in Figure 2) is called learning and the process of finding the latent variables (e.g., θ and z in Figure 2) given the parameters is called inference. However, given only the observed variables (e.g., w in Figure 2), learning and inference are often intertwined. Usually, the learning and inference of LDA would alternate between the updates of latent variables (which correspond to inference) and the updates of the parameters (which correspond to learning). Once the learning and inference of LDA is completed, we would have the parameters α and β. If a new document arrives, we can now fix the learned α and β and then perform inference alone to find the topic proportions θ j of the new document.As mentioned in Section 1, BDL is a principled probabilistic framework with two seamlessly integrated components: a perception component and a task-specific component.PGM for BDL: Figure 3 shows the PGM of a simple BDL model as an example. The part inside the red rectangle on the left represents the perception component and the part inside the blue rectangle on the right is the task-specific component. Typically, the perception component would be a probabilistic formulation of a deep learning model with multiple nonlinear processing layers represented as a chain structure in the PGM. While the nodes and edges in the perception component are relatively simple, those in the task-specific component often describe more complex distributions and relationships among variables (as in LDA).Three Sets of Variables: There are three sets of variables in a BDL model: perception variables, hinge variables, and task variables: (1) In this paper, we use Ω p to denote the set of perception variables (e.g., A, B, and C in Figure 3), which are the variables in the perception component. Usually Ω p would include the weights and neurons in the probabilistic formulation of a deep learning model. (2) We use Ω h to Summary of BDL Models. Ω h is the set of hinge variables mentioned in Section 4.1. V and U are the item latent matrix and the user latent matrix (Section 4.2.1). S is the relational latent matrix (Section 4.3.1), and X is the content matrix (Section 4.3.2). to the degree of flexibility, there are three types of variance for Ω h (for simplicity we assume the joint likelihood of BDL is Equation (5), Ω p = {p}, Ω h = {h}, and p(Ω h |Ω p ) = N (h|p, s) in our example): denote the set of hinge variables (e.g. J in Figure 3). These variables directly interact with the perception component from the task-specific component. Table 1 shows the set of hinge variables Ω h for each listed BDL models. (3) The set of task variables (e.g. G, I, and H in Figure 3), i.e., variables in the task-specific component without direct relation to the perception component, is denoted as Ω t . The I.I.D. Requirement: Note that hinge variables are always in the task-specific component. Normally, the connections between hinge variables Ω h and the perception component (e.g., C → J in Figure 3) should be i.i.d. for convenience of parallel computation in the perception component. For example, each row in J is related to only one corresponding row in C. Although it is not mandatory in BDL models, meeting this requirement would significantly increase the efficiency of parallel computation in model training.Joint Distribution Decomposition: If the edges between the two components point towards Ω h (as shown in Figure 3, where Ω p = {A, B, C, D, E, F}, Ω h = {J}, and Ω t = {I, G, H}), the joint distribution of all variables can be written as:• Zero-Variance: Zero-Variance (ZV) assumes no uncertainty during the information exchange between the two components. In the example, zero-variance means directly setting s to 0.• Hyper-Variance: Hyper-Variance (HV) assumes that uncertainty during the information exchange is defined through hyperparameters. In the example, HV means that s is a hyperparameter that is manually tuned.• Learnable Variance: Learnable Variance (LV) uses learnable parameters to represent uncertainty during the information exchange. In the example, s is the learnable parameter.As shown above, we can see that in terms of model flexibility, LV &gt; HV &gt; ZV. Normally, if the models are properly regularized, an LV model would outperform an HV model, which is superior to a ZV model. In Table 1, we show the types of variance for Ω h in different BDL models. Note that although each model in the table has a specific type, one can always adjust the models to devise their counterparts of other types. For example, while CDL in the table is an HV model, we can easily adjust p(Ω h |Ω p ) in CDL to devise its ZV and LV counterparts. In [67], authors compare the performance of an HV CDL and a ZV CDL and finds that the former performs significantly better, meaning that sophisticatedly modeling uncertainty between two components is essential for performance.If the edges between the two components originate from Ω h (similar to Figure 3 except that the edge points from J to C), the joint distribution of all variables can be written as:Learning Algorithms: Due to the nature of BDL, practical learning algorithms need to meet these criteria:Apparently, it is possible for BDL to have some edges between the two components pointing towards Ω h and some originating from Ω h , in which case the decomposition of the joint distribution would be more complex.Variance Related to Ω h : As mentioned in Section 1, one of the motivations for BDL is to model the uncertainty of exchanging information between the perception component and the task-specific component, which boils down to modeling the uncertainty related to Ω h . For example, this kind of uncertainty is reflected in the variance of the conditional density p(Ω h |Ω p ) in Equation (5) 4 . According 1) They should be online algorithms in order to scale well for large datasets. 2) They should be efficient enough to scale linearly with the number of free parameters in the perception component.4. For models with the joint likelihood decomposed as in Equation (6), the uncertainty is reflected in the variance of p(Ωp|Ω h ).Criterion (1) implies that conventional variational inference or MCMC methods are not applicable. Usually an online version of them is needed [28]. Most SGD-based methods do not work either unless only MAP inference (as opposed to Bayesian treatments) is performed. Criterion (2) is needed because there are typically a large number of free parameters in the perception component. This means methods based on Laplace approximation [41] are not realistic since they involve the computation of a Hessian matrix that scales quadratically with the number of free parameters.Despite the successful applications of deep learning on natural language processing and computer vision, very few attempts have been made to develop deep learning models for CF. The authors in [54] use restricted Boltzmann machines instead of the conventional matrix factorization formulation to perform CF and [19] extends this work by incorporating user-user and item-item correlations. Although these methods involve both deep learning and CF, they actually belong to CF-based methods because they do not incorporate content information as in CTR [60], which is crucial for accurate recommendation. The authors in [52] use low-rank matrix factorization in the last weight layer of a deep network to significantly reduce the number of model parameters and speed up training, however it is for classification instead of recommendation tasks. On music recommendation, [45], [68] directly use conventional CNN or deep belief networks (DBN) to assist representation learning for content information, but the deep learning components of their models are deterministic without modeling the noise and hence they are less robust. The models achieve performance boost mainly by loosely coupled methods without exploiting the interaction between content information and ratings. Besides, the CNN is linked directly to the rating matrix, which means the models will perform poorly due to serious overfitting when the ratings are sparse. denoted by X 0 . The output of layer l of the SDAE is denoted by X l which is a J-by-K l matrix, where K l is the number of units in layer l. Similar to X c , row j of X l is denoted by X l,j * . W l and b l are the weight matrix and bias vector, respectively, of layer l, W l, * n denotes column n of W l , and L is the number of layers. For convenience, we use W + to denote the collection of all layers of weight matrices and biases. Note that an L/2-layer SDAE corresponds to an L-layer network.Generalized Bayesian SDAE: Following the introduction of SDAE in Section 2.2, if we assume that both the clean input X c and the corrupted input X 0 are observed, similar to [4], [5], [12], [41], we can define the following generative process of generalized Bayesian SDAE: 1) For each layer l of the SDAE network, a) For each column n of the weight matrix W l , drawTo address the challenges above, a hierarchical Bayesian model called collaborative deep learning (CDL) as a novel tightly coupled method for RS is introduced in [67]. Based on a Bayesian formulation of SDAE, CDL tightly couples deep representation learning for the content information and collaborative filtering for the rating (feedback) matrix, allowing two-way interaction between the two. Experiments show that CDL significantly outperforms the state of the art.In the following text, we will start with the introduction of the notation used during our presentation of CDL. After that we will review the design and learning of CDL.Notation and Problem Formulation: Similar to the work in [60], the recommendation task considered in CDL takes implicit feedback [30] as the training and test data. The entire collection of J items (articles or movies) is represented by a J-by-B matrix X c , where row j is the bag-of-words vector X c,j * for item j based on a vocabulary of size B. With I users, we define an I-by-J binary rating matrix R = [R ij ] I×J . For example, in the dataset citeulike-a [60], [62], [67] R ij = 1 if user i has article j in his or her personal library and R ij = 0 otherwise. Given part of the ratings in R and the content information X c , the problem is to predict the other ratings in R. Note that although CDL in its current form focuses on movie recommendation (where plots of movies are considered as content information) and article recommendation like [60] in this section, it is general enough to handle other recommendation tasks (e.g., tag recommendation).Matrix X c plays the role of clean input to the SDAE while the noise-corrupted matrix, also a J-by-B matrix, is n I B ). Note that if λ s goes to infinity, the Gaussian distribution in Equation (7) will become a Dirac delta distribution [58] centered at σ(X l−1,j * W l + b l ), where σ(·) is the sigmoid function. The model will degenerate to be a Bayesian formulation of SDAE. That is why we call it generalized SDAE.Note that the first L/2 layers of the network act as an encoder and the last L/2 layers act as a decoder. Maximization of the posterior probability is equivalent to minimization of the reconstruction error with weight decay taken into consideration.Collaborative Deep Learning: Using the Bayesian SDAE as a component, the generative process of CDL is defined as follows:1) Generate variables of generalized Bayesian SDAE.2) For each item j, a) Draw the latent item offset vector j ∼ N (0, λ −1 v I K ) and then set the latent item vector:3) Draw a latent user vector for each user i:Here λ w , λ n , λ u , λ s , and λ v are hyperparameters and C ij is a confidence parameter similar to that for CTR [60] (C ij = a if R ij = 1 and C ij = b otherwise). Note that the middle layer X L/2 serves as a bridge between the ratings and content information. This middle layer, along with the latent offset j , is the key that enables CDL to simultaneously learn an effective feature representation and capture the 5. Note that while generation of the clean input Xc from X L is part of the generative process of the Bayesian SDAE, generation of the noise-corrupted input X 0 from Xc is an artificial noise injection process to help the SDAE learn a more robust feature representation. similarity and (implicit) relationship between items (and users). Similar to the generalized SDAE, for computational efficiency, we can also take λ s to infinity.The graphical model of CDL when λ s approaches positive infinity is shown in Figure 4, where, for notational simplicity, we use x 0 , x L/2 , and x C in place of Xand X T c,j * , respectively. Note that according the definition in Section 4.1, here the perception variables Ω p = {{W l }, {b l }, {X l }, X c }, the hinge variables Ω h = {V}, and the task variables Ω t = {U, R}, where V = (v j )Learning: Based on the CDL model above, all parameters could be treated as random variables so that fully Bayesian methods such as Markov chain Monte Carlo (MCMC) or variational approximation methods [32] may be applied. However, such treatment typically incurs high computational cost. Consequently, CDL uses an EM-style algorithm for obtaining the MAP estimates, as in [60].As in CTR [60], maximizing the posterior probability is equivalent to maximizing the joint log-likelihood of U, V, {X l }, X c , {W l }, {b l }, and R given λ u , λ v , λ w , λ s , and λ n :If λ s goes to infinity, the likelihood becomes:where the encoder function f e (·, W + ) takes the corrupted content vector X 0,j * of item j as input and computes the encoding of the item, and the function f r (·, W + ) also takes X 0,j * as input, computes the encoding and then reconstructs the content vector of item j. For example, if the number of layers L = 6, f e (X 0,j * , W + ) is the output of the third layer while f r (X 0,j * , W + ) is the output of the sixth layer. From the optimization perspective, the third term in the objective function (8) above is equivalent to a multi-layer perceptron using the latent item vectors v j as the target while the fourth term is equivalent to an SDAE minimizing the reconstruction error. From the perspective of neural networks (NN), when λ s approaches positive infinity, training of the probabilistic graphical model of CDL in Figure 4(left) would degenerate to simultaneously training two neural networks overlaid together with a common input layer (the corrupted input) but different output layers, as shown in Figure 5. Note that the second network is much more complex than typical neural networks due to the involvement of the rating matrix.When the ratio λ n /λ v approaches positive infinity, it will degenerate to a two-step model in which the latent representation learned using SDAE is put directly into the CTR. The interaction between the perception component and the task-specific component is one-way (from the perception component to the task-specific component), meaning that the perception component will not be affected by the task-specific component. Another extreme happens when λ n /λ v goes to zero where the decoder of the SDAE essentially vanishes. On the right of Figure 4 is the graphical model of the degenerated CDL when λ n /λ v goes to zero. As demonstrated in the experiments, the predictive performance will suffer greatly for both extreme cases [67]. This verifies that (1) the information from the task-specific component can improve the perception component, and (2) mutual boosting effect is crucial to BDL.For u i and v j , block coordinate descent similar to [30],  where U = (u i )T is a column vector containing all the ratings of user i, and C ij reflects the confidence controlled by a and b as discussed in [30]. C j and R j are defined similarly for item j.Given U and V, we can learn the weights W l and biases b l for each layer using the back-propagation learning algorithm. The gradients of the likelihood with respect to W l and b l are as follows: Table 2 shows the recall of recommendation with 300 recommended items for different methods in the dataset citeulike-a. Please refer to [67] for more details.In the following text, we provide several extensions of CDL from different perspectives.Besides the MAP estimates, a sampling-based algorithm for the Bayesian treatment of CDL is also proposed in [67]. This algorithm turns out to be a Bayesian and generalized version of the well-known back-propagation (BP) learning algorithm. We list the key conditional densities as follows:For W+: We denote the concatenation of W l, * n and b  By alternating the update of U, V, W l , and b l , we can find a local optimum for L . Several commonly used techniques such as using a momentum term may be applied to alleviate the local optimum problem. Note that a carefully designed BDL model (according to the i.i.d. requirement and with proper variance models as stated in Section 4.1) can minimize the overhead of seamlessly combining the perception component and the task-specific component. In CDL, the computational complexity (per iteration) of the perception component is O(JBK 1 ) and that of the task-specific component is O(, where N R is the number of non-zero entries in the rating matrix andNote that for the last layer (l = L) the second Gaussian would be N (X c,j * |X l,j * , λ. The computational complexity (per iteration) for the whole model isPrediction: Let D be the observed test data. Similar to [60], CDL uses the point estimates of u i , W + and j to calculate the predicted rating:where E[·] denotes the expectation operation. In other words, we approximate the predicted rating as:Note that for any new item j with no rating in the training data, its offset Interestingly, if λ s goes to infinity and adaptive rejection Metropolis sampling (which involves using the gradients of the objective function to approximate the proposal distribution) is used, the sampling for W + turns out to be a Bayesian generalized version of BP. Specifically, as Figure 6 shows, after getting the gradient of the loss function at one point (the red dashed line on the left), the next sample would be drawn in the region under that line, which is * j will be 0. equivalent to a probabilistic version of BP. If a sample is above the curve of the loss function, a new tangent line (the black dashed line on the right) would be added to better approximate the distribution corresponding to the joint log-likelihood. After that, samples would be drawn from the region under both lines. During the sampling, besides searching for local optima using the gradients (MAP), the algorithm also takes the variance into consideration. That is why it is called Bayesian generalized back-propagation.2) For each pair-wise preference (j, k) ∈ P i , whereFollowing the generative process, the last term of Equation (8) In SDAE, corrupted input goes through encoding and decoding to recover the clean input. Usually, different epochs of training use different corrupted versions as input.Hence generally, SDAE needs to go through enough epochs of training to see sufficient corrupted versions of the input. Marginalized SDAE (mSDAE) [13] seeks to avoid this by marginalizing out the corrupted input and obtaining closed-form solutions directly. In this sense, mSDAE is more computationally efficient than SDAE. As mentioned in [37], using mSDAE instead of the Bayesian SDAE could lead to more efficient learning algorithms. For example, in [37], the objective when using a one-layer mSDAE can be written as follows:Similar algorithms can be used to learn the parameters in CDR. As reported in [71], using the ranking objective leads to significant improvement in the recommendation performance.Following the definition in Section 4.1, CDR's perception variables Ω p = {{W l }, {b l }, {X l }, X c }, the hinge variables Ω h = {V}, and the task variables Ω t = {U, ∆}.Models like [67], [71] focus the deep learning component on modeling the item content. Besides the content information from the items, attributes of users sometimes contain much more important information. It is therefore desirable to extend CDL to model user attributes as well [37]. We call this variant symmetric CDL. For example, using an extra mSDAE on the user attributes adds two extra terms in Equation (9)where X 0,j * is the collection of k different corrupted versions of X 0,j * (a k-by-B matrix) and X c,j * is the k-time repeated version of X c,j * (also a k-by-B matrix). P 1 is the transformation matrix for item latent factors.The solution for W 1 would be:for user attributes) is the collection of k different corrupted versions of Y 0,j * and Y c,i * (also a k-by-D matrix) is the k-time repeated version of Y c,i * (the clean user attributes). P 2 is the transformation matrix for user latent factors and D is the number of user attributes. Similar to the marginalized CDL, the solution for W 2 given other parameters is:wherec X c . A solver for the expectation in the equation above is provided in [13]. Note that this is a linear and one-layer case which can be generalized to the nonlinear and multi-layer case using the same techniques as in [12], [13].As we can see, in marginalized CDL, the perception variables Ω p = {X 0 , X c , W 1 }, the hinge variables Ω h = {V}, and the task variables, the hinge variables Ω h = {V, U}, and the task variables Ω t = {P 1 , P 2 , R}.CDL assumes a collaborative filtering setting to model the ratings directly. However, the output of recommender systems is often a ranked list, which means it would be more natural to use ranking rather than ratings as the objective. With this motivation, collaborative deep ranking (CDR) is proposed [71] to jointly perform representation learning and collaborative ranking. The corresponding generative process is the same as that of CDL except for Step 3 and 4, which should be replaced with:• For each user i, 1) Draw a latent user vector for each user i:4.2.6 Discussion CDL is the first hierarchical Bayesian model to bridge the gap between state-of-the-art deep learning models and RS. By performing deep learning collaboratively, CDL and its variants can simultaneously extract an effective deep feature representation from the content and capture the similarity and implicit relationship between items (and users). This way, the perception component and the task-specific component are able to interact with each other to create synergy and further boost the recommendation accuracy. The learned representation may also be used for tasks other than recommendation. Unlike previous deep learning models which use a simple target such as classification [33] and reconstruction [59], CDL-based models 6 use CF as a more complex target in a probabilistic framework.As mentioned in Section 1, the synergy created by information exchange between two components is crucial6. During the review process of this paper, there are some newly published works based on BDL (e.g., some CDL-based works [65], [72]).to the performance of BDL. In the CDL-based models above, the exchange is achieved by assuming Gaussian distributions that connect the hinge variables and the variables in the perception component (drawing the hinge variableis a perception variable), which is simple but effective and efficient in computation. Among the five CDL-based models in Table 1, three of them are HV models and the others are LV models, according to the definition in Section 4.1. Since it has been verified that the HV CDL significantly outperforms its ZV counterpart [67], we can expect extra performance boosts from the LV counterparts of the three HV models.Besides efficient information exchange, the designs of the models also meet the i.i.d. requirement of the distribution concerning hinge variables discussed in Section 4.1 and are hence easily parallelizable. In some models to be introduced later, we will see alternative designs to enable efficient and i.i.d. information exchange between the two components of BDL. Fig. 7. Graphical model of RSDAE for L = 4. λs is not shown here to prevent clutter.1) Draw the relational latent matrix S from a matrix variate normal distribution [21]:2) For layer l of the SDAE where l = 1, 2, . . . ,3) For layer L 2 In this section, we review some examples of using BDL for topic models. These models combine the merits of PGM (which naturally incorporates the probabilistic relationships among variables) and NN (which learns deep representations efficiently), leading to significant performance boost.of the SDAE network, draw the representation vector for item j from the product of two Gaussians (PoG) [16]: From the perspective of SDAE, the J-by-B matrix X c represents the clean input to the SDAE and the noise-corrupted matrix of the same size is denoted by X 0 . Besides, we denote the output of layer l of the SDAE, a J-by-K l matrix, by X l . Row j of X l is denoted by X l,j * , W l and b l are the weight matrix and bias vector of layer l, W l, * n denotes column n of W l , and L is the number of layers. As a shorthand, we refer to the collection of weight matrices and biases in all layers as W + . Note that an L/2-layer SDAE corresponds to an L-layer network.Model Formulation: Here we will use the Bayesian SDAE introduced before as a building block for the relational stacked denoising autoencoder (RSDAE) model.As mentioned in [64], RSDAE is formulated as a novel probabilistic model which can seamlessly integrate layered representation learning and the relational information available. This way, the model can simultaneously learn the feature representation from the content information and the relation between items. The graphical model of RSDAE is shown in Figure 7 and the generative process is listed as follows:is the dimensionality of the learned representation vector for each item, S denotes the K × J relational latent matrix in which column j is the relational latent vector s j for item j. Note that N K,J (0, (10) is a matrix variate normal distribution defined as in [21]:where the operator ⊗ denotes the Kronecker product of two matrices [21], tr(·) denotes the trace of a matrix, and L a is the Laplacian matrix incorporating the relational information. L a = D − A, where D is a diagonal matrix whose diagonal elements D ii = j A ij and A is the adjacency matrix representing the relational information with binary entries indicating the links (or relations) between items. A jj = 1 indicates that there is a link between item j and item j and and the Gaussian N (s, which is also a Gaussian [16].According to the generative process above, maximizing the posterior probability is equivalent to maximizing the joint log-likelihood of {X l }, X c , S, {W l }, and {b l } given λ s , λ w , λ l , λ r , and λ n : complexity for each iteration is O(JBK 1 + KJ). Similar to CDL, no significant overhead is introduced. Table 3 shows the recall for different methods in the dataset movielens-plot when the learned representation is used for tag recommendation (with 300 recommended tags for each item). As we can see, RSDAE significantly outperforms SDAE, which means that the relational information from the task-specific component is crucial to the performance boost. Please refer to [64] for more details.Note that the first term −The Poisson distribution with support over nonnegative integers is known as a natural choice to model counts. It is, therefore, desirable to use it as a building block for topic models [8]. With this motivation, [75] proposed a model, dubbed Poisson factor analysis (PFA), for latent nonnegative matrix factorization via Poisson distributions. Poisson Factor Analysis: PFA assumes a discrete N -by-P matrix X containing word counts of N documents with a vocabulary size of P [17], [75]. In a nutshell, PFA can be described using the following equation:corresponds to log p(S) in the matrix variate distribution in Equation (12). By simple manipulation, wek * L a S k * , where S k * denotes the k-th row of S. As we can see, maximizing − λ l 2 tr(S T L a S) is equivalent to making s j closer to s j if item j and item j are linked (namely A jj = 1).In RSDAE, the perception variables Ω p = {{X l }, X c , {W l }, {b l }}, the hinge variables Ω h = {S}, and the task variables Ω t = {A}.Learning Relational Representation and Topics: [64] provides an EM-style algorithm for MAP estimation. Here we review some of the key steps as follows.In terms of the relational latent matrix S, we first fix all rows of S except the k-th one S k * and then update S k * . Specifically, we take the gradient of L with respect to S k * , set it to 0, and get the following linear system:where Φ (of size K-by-P where K is the number of topics) denotes the factor loading matrix in factor analysis with the k-th row φ k encoding the importance of each word in topic k. The N -by-K matrix Θ is the factor score matrix with the n-th row θ n containing topic proportions for document n. The N -by-K matrix H is a latent binary matrix with the n-th row h n defining a set of topics associated with document n.Different priors correspond to different models. For example, Dirichlet priors on φ k and θ n with an all-one matrix H would recover LDA [8] while a beta-Bernoulli prior on h n leads to the negative binomial focused topic model (NB-FTM) model in [74]. In [17], a deep-structured prior based on sigmoid belief networks (SBN) [43] (an MLP variant with binary hidden units) is imposed on h n to form a deep PFA model for topic modeling.Deep Poisson Factor Analysis: In the deep PFA model [17], the generative process can be summarized as follows:A naive approach is to solve the linear system by settingthe complexity is O(J 3 ) for one single update. Similar to [38], the steepest descent method [55] is used to iteratively update S k * :As discussed in [38], the use of steepest descent method dramatically reduces the computation cost in each iteration from O(J 3 ) to O(J). Given S, we can learn W l and b l for each layer using the back-propagation algorithm. By alternating the update of S, W l , and b l , a local optimum for L can be found. Also, techniques such as including a momentum term may help to avoid being trapped in a local optimum. The computational where L is the number of layers in SBN, which corresponds to Equation (15) and (16). x np is an entry in the matrix X, h (l) n is the n-th row of H l , and x npk is the count of word p that comes from topic k in document n.In this model, the perception variables Ω p = {{H l }, {W l }, {b l }}, the hinge variables Ω h = {X}, and the task variables Ω t = {{φ k }, {r k }, Θ, γ 0 }. W l is the weight matrix containing columns of w Filtering: Efficient learning algorithms are needed for Bayesian treatments of deep PFA. [17] proposed to use an online version of MCMC called Bayesian conditional density filtering (BCDF) to learn both the global parameters Ψ g = ({φ k }, {r k }, γ 0 , {W l }, {b l }) and the local variablesThe key conditional densities used for the Gibbs updates are as follows:where(1)x npk , and ζ npk ∝ φ kp θ nk . For nk where l &gt; 1, the same techniques as in [18] can be used.Learning Using Stochastic Gradient Thermostats: An alternative way of learning deep PFA is through the use of stochastic gradient Nóse-Hoover thermostats (SGNHT), which is more accurate and scalable. Specifically, the following stochastic differential equations (SDE) can be used: of the topic hierarchy would facilitate accurate modeling of words and topics, providing valuable information for learning inter-document relations. On the other hand, accurately modeling the words, topics, and inter-document relations could help with the discovery of topic hierarchy and learning of compact document representations.As we can see, the information exchange mechanism in some BDL-based topic models is different from that in Section 4.2. For example, in the SBN-based DPFA model, the exchange is natural since the bottom layer of SBN, H 1 , and the relationship between H 1 and Ω h = {X} are both inherently probabilistic, as shown in Equation (16) and (17), which means additional assumptions about the distribution are not necessary. The SBN-based DPFA model is equivalent to assuming that H in PFA (see Equation (14)) is generated from a Dirac delta distribution (a Gaussian distribution with zero variance) centered at the bottom layer of the SBN, H 1 . Hence both DPFA models in Table 1 are ZV models, according to the definition in Section 4.1. It is worth noting that RSDAE is an HV model (see Equation (11), where S is the hinge variable and the others are perception variables), and naively modifying this model to be its ZV counterpart would violate the i.i.d. requirement in Section 4.1.where f (Ψ g ) = −∇ Ψg U (Ψ g ) and U (Ψ g ) is the negative log-posterior of the model. t indexes time and W denotes the standard Wiener process. ξ is the thermostats variable to make sure the system has a constant temperature. D is the injected variance which is a constant.Similar to the deep PFA above, the restricted Boltzmann machine (RBM) [24] can be used in place of SBN [17]. If RBM is used, Equation (15) and (16) would be defined using the energy [24]:. For the learning, similar algorithms as the deep PFA with SBN can be used. Specifically, the sampling process would alternate between {{φ k }, {γ k }, γ 0 } and {{W l }, {b l }}. For {{φ k }, {γ k }, γ 0 }, similar conditional density as the SBN-based DPFA is used. For {{W l }, {b l }}, they use the contrastive divergence algorithm.As mentioned in Section 1, BDL can also be applied to applications beyond data engineering and data mining (e.g., the control of nonlinear dynamical systems from raw images or medical diagnosis with medical images).Consider controlling a complex dynamical system according to the live video stream received from a camera. One way of solving this control problem is by iteration between two tasks, perception from raw images and control based on dynamic models. The perception task can be taken care of using multiple layers of simple nonlinear transformation (deep learning) while the control task usually needs more sophisticated models such as hidden Markov models and Kalman filters [22], [42]. To enable an effective iterative process between the perception task and the control task, two-way information exchange between them is often necessary. The perception component would be the basis on which the control component estimates its states and on the other hand, the control component with a built-in dynamic model would be able to predict the future trajectory (images) by reversing the perception process. For example, [69] proposed a BDL-based model that performs control based on the received raw images (videos). Their key generative process is as follows:x t+1 ∼ P θ (X|Z) = Bernoulli(p t ),In BDL-based topic models, the perception component is responsible for inferring the topic hierarchy from documents while the task-specific component is in charge of modeling the word generation, topic generation, word-topic relation, or inter-document relation. The synergy between these two components comes from the bidirectional interaction between them. On the one hand, knowledge where Q φ (Z|X) is the encoding model which encodes the raw images X into latent states Z. Q ψ ( Z|Z, u) is the transition model which predicts the next latent state Z given the current latent state Z and the applied control u. P θ (X|Z) is the reconstruction (decoding) model which reconstructs the raw images X from latent states Z. The parameters µ t , Σ t , A t , B t , o t , C t , and p t are then further parameterized by neural networks.It is worth noting that in terms of information exchange between the two components, this BDL-based control model uses a different mechanism from the ones in Section 4.2 and Section 4.3: it uses neural networks to separately parameterize the mean and covariance of hinge variables (e.g., µ t and Σ t in the encoding model), which is more flexible (with more free parameters) than models such as CDL and CDR in Section 4.2, where Gaussian distributions with fixed variance are also used. Note that this BDL-based control model is an LV model, and since the covariance is assumed to be diagonal [69], the model still meets the i.i.d. requirement in Section 4.1.In this paper, we identified a current trend of merging probabilistic graphical models and neural networks (deep learning), proposed a BDL framework, and reviewed relevant recent work on BDL, which strives to combine the merits of PGM and NN by organically integrating them in a single principled probabilistic framework. To learn parameters in BDL, several algorithms have been proposed, ranging from block coordinate descent, Bayesian conditional density filtering, and stochastic gradient thermostats to stochastic gradient variational Bayes.BDL has gained its popularity both from the success of PGM and from recent promising advances in deep learning. Since many real-world tasks involve both perception and inference, BDL is a natural choice for harnessing the perception ability from NN and the (causal and logical) inference ability from PGM. Although current applications of BDL focus on recommender systems, topic models, and stochastic optimal control, in the future, we can expect an increasing number of other applications such as link prediction, community detection, active learning, Bayesian reinforcement learning, and many other complex tasks that need interaction between perception and causal inference. In these complex tasks, BDL with interconnected perception components (to handle perception) and task-specific components (to handle inference/reasoning) possesses great performance-boosting potential. Besides, with the advances of efficient Bayesian neural networks (BNN), BDL with BNN as an important component is expected to be more and more scalable.
