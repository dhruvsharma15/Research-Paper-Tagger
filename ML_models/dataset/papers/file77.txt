Recurrent Neural Networks ( Goodfellow et al., 2016, Chapter 10) have re- cently shown remarkable success in sequential data prediction and have been applied to such NLP tasks as Language Modelling ( Mikolov et al., 2010), Machine Translation ( Sutskever et al., 2014;Bahdanau et al., 2015), Parsing ( Vinyals et al., 2014), Natural Language Generation ( Wen et al., 2015) and Dialogue ( Vinyals and Le, 2015), to name only a few. Specially popular RNN architectures in these applications have been models able to exploit long-distance correlations, such as LSTMs (Hochreiter and Schmidhuber, 1997;Gers et al., 2000) and GRUs ( Cho et al., 2014), which have led to groundbreaking performances.RNNs (or more generally, Neural Networks), at the core, are machines that take as input a real vector and output a real vector, through a combi- nation of linear and non-linear operations.When working with symbolic data, some conversion from these real vec- tors from and to discrete values, for instance words in a certain vocabulary, becomes necessary. However most RNNs have taken an oversimplified view of this mapping. In particular, for converting output vectors into distri- butions over symbolic values, the mapping has mostly been done through a softmax operation, which assumes that the RNN is able to compute a real value for each individual member of the vocabulary, and then converts this value into a probability through a direct exponentiation followed by a normalization.This rather crude "softmax approach", which implies that the output vector has the same dimensionality as the vocabulary, has had some serious consequences.To focus on only one symptomatic defect of this approach, consider the following. When using words as symbols, even large vocabularies cannot account for all the actual words found either in training or in test, and the models need to resort to a catch-all "unknown" symbol unk, which provides a poor support for prediction and requires to be supplemented by diverse pre-and post-processing steps ( Luong et al., 2014;Jean et al., 2015). Even for words inside the vocabulary, unless they have been witnessed many times in the training data, prediction tends to be poor because each word is an "is- land", completely distinct from and without relation to other words, which needs to be predicted individually.One partial solution to the above problem consists in changing the gran- ularity by moving from word to character symbols (Sutskever et al., 2011;Ling et al., 2015). This has the benefit that the vocabulary becomes much  smaller, and that all the characters can be observed many times in the train- ing data. While character-based RNNs have thus some advantages over word-based ones, they also tend to produce non-words and to necessitate longer prediction chains than words, so the jury is still out, with emerging hybrid architectures that attempt to capitalize on both levels (Luong and Manning, 2016). Here, we propose a different approach, which removes the constraint that the dimensionality of the RNN output vector has to be equal to the size of the vocabulary and allows generalization across related words. However, its crucial benefit is that it introduces a principled and powerful way of incorporating prior knowledge inside the models.The approach involves a very direct and natural extension of the softmax, by considering it as a special case of an conditional exponential family, a class of models better known as log-linear models and widely used in "pre- NN" NLP. We argue that this simple extension of the softmax allows the resulting "log-linear RNN" to compound the aptitude of log-linear models for exploiting prior knowledge and predefined features with the aptitude of RNNs for discovering complex new combinations of predictive traits.Let us first recap briefly the generic notion of RNN, abstracting away from different styles of implementation (LSTM (Hochreiter and Schmidhuber, 1997;Graves, 2012), GRU ( Cho et al., 2014), attention models ( Bahdanau et al., 2015), different number of layers, etc.).An RNN is a generative process for predicting a sequence of symbols x 1 , x 2 , . . . , x t , . . ., where the symbols are taken in some vocabulary V , and where the prediction can be conditioned by a certain observed context C. This generative process can be written as:where θ is a real-valued parameter vector. 1 Generically, this conditional probability is computed according to:Here h t−1 is the hidden state at the previous step t − 1, x t is the output symbol produced at that step and f θ is a neural-network based function (e.g. a LSTM network) that computes the next hidden state h t based on C, x t , and h t−1 . The function g θ , 2 is then typically computed through an MLP, which returns a real-valued vector a θ,t of dimension |V |. This vector is then normalized into a probability distribution over V through the softmax transformation:with the normalization factor:We will sometimes write this as p θ (xt+1|C; x1, x2, . . . , xt) to stress the difference be- tween the "context" C and the prefix x1, x2, . . . , xt. Note that some RNNs are "non- conditional", i.e. do not exploit a context C. 2 We do not distinguish between the parameters for f and for g, and write θ for both.and finally the next symbol x t+1 is sampled from this distribution. See Figure 1.Training of such a model is typically done through back-propagation of the cross-entropy loss:where ¯ x t+1 is the actual symbol observed in the training set.Log-linear models play a considerable role in statistics and machine learning; special classes are often known through different names depending on the ap- plication domains and on various details: exponential families (typically for unconditional versions of the models) (Nielsen and Garcia, 2009) maximum entropy models ( Berger et al., 1996;Jaynes, 1957), conditional random fields ( Lafferty et al., 2001), binomial and multinomial logistic regression ( Hastie et al., 2001, Chapter 4). These models have been especially popular in NLP, for example in Language Modelling (Rosenfeld, 1996), in sequence labelling ( Lafferty et al., 2001), in machine translation ( Berger et al., 1996;Och and Ney, 2002), to name only a few.Here we follow the exposition (Jebara, 2013), which is useful for its broad applicability, and which defines a conditional log-linear model -which we could also call a conditional exponential family -as a model of the form (in our own notation):Let us describe the notation:• x is a variable in a set V , which we will take here to be discrete (i.e. countable), and sometimes finite. 3 We will use the terms domain or vocabulary for this set.• K is the conditioning variable (also called condition).• a is a parameter vector in R d , which (for reasons that will appear later) we will call the adaptor vector. 4• φ is a feature function (K, x) → R d ; note that we sometimes write (x; K) or (K; x) instead of (K, x) to stress the fact that K is a condi- tion.• b is a nonnegative function (K, x) → R + ; we will call it the background function of the model. 5• Z(K, a), called the partition function, is a normalization factor:When the context is unambiguous, we will sometimes leave the condition K as well as the parameter vector a implicit, and also simply write Z instead of Z(K, a); thus we will write:or more compactly:The background as a "prior"If in equation (7) the background function is actually a normalized proba- bility distribution over V (that is, x b(x) = 1) and if the parameter vector a is null, then the distribution p is identical to b.Suppose that we have an initial belief that the parameter vector a should be close to a 0 , then by reparametrizing equation (7) in the form:with b (x) = b(x) exp(a 0 φ(x)) and a = a − a 0 , then our initial belief is represented by taking a = 0. In other words, we can always assume that our initial belief is represented by the background probability b along with a null parameter vector a = 0. Deviations from this initial belief are then representation by variations of the parameter vector away from 0 and a simple form of regularization can be obtained by penalizing some p-norm ||a || p of this parameter vector. 6 An important property of log-linear models is that they enjoy an extremely intuitive form for the gradient of their log-likelihood (aka cross-entropy loss).If ¯ x is a training instance observed under condition K, and if the current model is p(x|a, K) according to equation (5), its likelihood loss at ¯ x is defined as: − log L = − log p(¯ x|a, K). Then a simple calculation shows that the gradient ∂ log L ∂a (also called the "Fisher score" at ¯ x) is given by:x∈V In other words, the gradient is minus the difference between the model expectation of the feature vector and its actual value at ¯ x. 7We can now define what we mean by a log-linear RNN. The model, illus- trated in Figure 2, is similar to a standard RNN up to two differences:The first difference is that we allow a more general form of input to the network at each time step; namely, instead of allowing only the latest symbol x t to be used as input, along with the condition C, we now allow an arbitrary feature vector ψ(C, x 1 , . . . , x t ) to be used as input; this feature vector is of fixed dimensionality |ψ|, and we allow it to be computed in 6 Contrarily to the generality of the presentation by Jebara (2013), many presentations of log-linear models in the NLP context do not make an explicit reference to b, which is then implicitely taken to be uniform. However, the more statistically oriented presenta- tions (Jordan, 20XX;Nielsen and Garcia, 2009) of the strongly related (unconditional) exponential family models do, which makes the mathematics neater and is necessary in presence of non-finite or continuous spaces. One advantage of the explicit introduction of b, even for finite spaces, is that it makes it easier to speak about the prior knowledge we have about the overall process.7 More generally, if we have a training set consisting of N pairs of the form (¯ xn; Kn), then the gradient of the log-likelihood for this training set is given by: an arbitrary (but deterministic) way from the combination of the currently known prefix x 1 , . . . , x t−1 , x t and the context C. This is a relatively minor change, but one that usefully expands the expressive power of the network. We will sometimes call the ψ features the input features.The second, major, difference is the following. We do compute a θ,t in the same way as previously from h t , however, after this point, rather than applying a softmax to obtain a distribution over V , we now apply a log-linear model. While for the standard RNN we had:in the LL-RNN, we define:In other words, we assume that we have a priori fixed a certain background function b(K, x), where the condition K is given by K = (C, x 1 , . . . , x t ), and also defined M features defining a feature vector φ(K, x t+1 ), of fixed dimensionality |φ| = M . We will sometimes call these features the output features. Note that both the background and the features have access to the context K = (C, x 1 , . . . , x t ).In Figure 2, we have indicated with LL (LogLinear) the operation (10) that combines a θ,t with the feature vector φ(C, x 1 , . . . , x t , x t+1 ) and the back- ground b(C, x 1 , . . . , x t , x t+1 ) to produce the probability distribution p θ,t (x t+1 ) over V . We note that, here, a θ,t is a vector of size |φ|, which may or may not be equal to the size |V | of the vocabulary, by contrast to the case of the softmax of Figure 1.Overall, the LL-RNN is then computed through the following equations:For prediction, we now use the combined process p θ , and we train this pro- cess, similarly to the RNN case, according to its cross-entropy loss relative to the actually observed symbol ¯ x:At training time, in order to use this loss for backpropagation in the RNN, we have to be able to compute its gradient relative to the previous layer, namely a θ,t . From equation (9), we see that this gradient is given by:This equation provides a particularly intuitive formula for the gradient, namely, as the difference between the expectation of φ(K; x) according to the log-linear model with parameters a θ,t and the observed value φ(K; ¯ x t+1 ). However, this expectation can be difficult to compute. For a finite (and not too large) vocabulary V , the simplest approach is to simply evaluate the right-hand side of equation (13) for each x ∈ V , to normalize by the sum to obtain p θ,t (x), and to weight each φ(K; x) accordingly. For standard RNNs (which are special cases of LL-RNNs, see below), this is actually what the simpler approaches to computing the softmax gradient do, but more sophis- ticated approaches have been proposed, such as employing a "hierarchical softmax" (Morin and Bengio, 2005). In the general case (large or infinite V ), the expectation term in (19) needs to be approximated, and different tech- niques may be employed, some specific to log-linear models (Elkan, 2008;Jebara, 2013), some more generic, such as contrastive divergence (Hinton, 2002) or Importance Sampling; a recent introduction to these generic meth- ods is provided in ( Goodfellow et al., 2016, Chapter 18), but, despite its practical importance, we will not pursue this topic further here.It is easy to see that LL-RNNs generalize RNNs. Consider a finite vocab- ulary V , and the |V |-dim "one-hot" representation of x ∈ V , relative to a certain fixed ordering of the elements of V :We assume (as we implicitly did in the discussion of standard RNNs) that C is coded through some fixed-vector and we then define:where ⊕ denotes vector concatenation; thus we "forget" about the initial portion x 1 , . . . , x t−1 of the prefix, and only take into account C and x t , encoded in a similar way as in the case of RNNs. We then define b(x) to be uniformly 1 for all x ∈ V ("uniform back- ground"), and φ to be:Neither b nor φ depend on C, x 1 , . . . , x t , and we have:in other words:Thus, we are back to the definition of RNNs in equations (1-4). As for the gradient computation of equation (19):x∈V it takes the simple form:x∈V in other words this gradient is the vector ∇ of dimension |V |, with coordi- nates i ∈ 1, . . . , |V | corresponding to the different elements x (i) of V , where:This corresponds to the computation in the usual softmax case.We now come back to the our starting point in the introduction: the problem of unknown or rare words, and indicate a way to handle this problem with LL-RNNs, which may also help building intuition about these models.Let us consider some moderately-sized corpus of English sentences, tok- enized at the word level, and then consider the vocabulary V 1 , of size 10K, consisting of the 9999 most frequent words to occur in this corpus plus one special symbol UNK used for tokens not among those words ("unknown words").After replacing the unknown words in the corpus by UNK, we can train a language model for the corpus by training a standard RNN, say of the LSTM type. Note that if translated into a LL-RNN according to section 2.4, this model has 10K features (9999 features for identity with a specific frequent word, the last one for identity with the symbol UNK), along with a uniform background b.This model however has some serious shortcomings, in particular:• Suppose that none of the two tokens Grenoble and 37 belong to V 1 (i.e. to the 9999 most frequent words of the corpus), then the learnt model cannot distinguish the probability of the two test sentences: the cost was 37 euros / the cost was Grenoble euros.• Suppose that several sentences of the form the cost was NN euros ap- pear in the corpus, with NN taking (say) values 9, 13, 21, all belonging to V 1 , and that on the other hand 15 also belongs to V 1 , but appears in non-cost contexts; then the learnt model cannot give a reasonable probability to the cost was 15 euros, because it is unable to notice the similarity between 15 and the tokens 9, 13, 21.Let's see how we can improve the situation by moving to a LL-RNN. We start by extending V 1 to a much larger finite set of words V 2 , in particular one that includes all the words in the union of the training and test corpora, 8 and we keep b uniform over V 2 . Concerning the ψ (input) features, for now we keep them at their standard RNN values (namely as in (17)). Concerning the φ features, we keep the 9999 word-identity features that we had, but not the UNK-identity one; however, we do add some new features (say φ 10000 − φ 10020 ):• A binary feature φ 10000 (x) = φ number (x) that tells us whether the token x can be a number;• A binary feature φ 10001 (x) = φ location (x) that tells us whether the token x can be a location, such as a city or a country;• A few binary features φ noun (x), φ adj (x), ..., covering the main POS's for English tokens. Note that a single word may have simultaneously several such features firing, for instance flies is both a noun and a verb. 9• Some other features, covering other important classes of words.Each of the φ 1 , ..., φ 10020 features has a corresponding weight that we index in a similar way a 1 , ..., a 10020 .Note again that we do allow the features to overlap freely, nothing pre- venting a word to be both a location and an adjective, for example (e.g. Nice in We visited Nice / Nice flowers were seen everywhere), and to also appear in the 9999 most frequent words. For exposition reasons (ie in order to simplify the explanations below) we will suppose that a number N will always fire the feature φ number , but no other feature, apart from the case where it also belongs to V 1 , in which case it will also fire the word-identity feature that corresponds to it, which we will denote by φ ˜ N , with˜Nwith˜ with˜N ≤ 9999.Why is this model superior to the standard RNN one? To answer this question, let's consider the encoding of N in φ feature space, when N is a number. There are two slightly different cases to look at:1. N does not belong to V 1 . Then we have φ 10000 = φ number = 1, and φ i = 0 for other i's.2. N belongs to V 1 . Then we have φ 10000 = φ number = 1, φ ˜ N = 1 and φ i = 0 for other i's.Let us now consider the behavior of the LL-RNN during training, when at a certain point, let's say after having observed the prefix the cost was, it is now coming to the prediction of the next item x t+1 = x, which we assume is actually a number ¯ x = N in the training sample. We start by assuming that N does not belong to V 1 . Let us consider the current value a = a θ,t of the weight vector calculated by the network at this point. According to equation (9), the gradient is:where L is the cross-entropy loss and p is the probability distribution asso- ciated with the log-linear weights a.In our case the first term is a vector that is null everywhere but on coordinate φ number , on which it is equal to 1. As for the second term, it can be seen as the model average of the feature vector φ(x) when x is sampled according to p(x|a). One can see that this vector has all its coordinates in the interval [0,1], and in fact strictly between 0 and 1. 10 As a consequence, the gradient ∂ log L ∂a is strictly positive on the coordinate φ number and strictly negative on all the other coordinates. In other words, the backpropagation signal sent to the neural network at this point is that it should modify its parameters θ in such a way as to increase the a number weight, and decrease all the other weights in a.A slightly different situation occurs if we assume now that N belongs to V 1 . In that case φ(N ) is null everywhere but on its two coordinates φ number and φ ˜ N , on which it is equal to 1. By the same reasoning as before we see that the gradientis then strictly positive on the two corresponding coordinates, and strictly negative everywhere else. Thus, the signal sent to the network is to modify its parameter towards increasing the a number and a ˜ N weights, and decrease them everywhere else.Overall, on each occurrence of a number in the training set, the network is then learning to increase the weights corresponding to the features (either both a number and a ˜ N or only a number , depending on whether N is in V 1 or not) firing on this number, and to decrease the weights for all the other features. This contrasts with the behavior of the previous RNN model where only in the case of N ∈ V 1 did the weight a ˜ N change. This means that at the end of training, when predicting the word x t+1 that follows the prefix The cost was, the LL-RNN network will have a tendency to produce a weight vector a θ,t with especially high weight on a number , some positive weights on those a ˜ N for which N has appeared in similar contexts, and negative weights on features not firing in similar contexts. 11 Now, to come back to our initial example, let us compare the situa- tion with the two next-word predictions The cost was 37 and The cost was Grenoble. The LL-RNN model predicts the next word x t+1 with probability:While the prediction x t+1 = 37 fires the feature φ number , the prediction x t+1 = Grenoble does not fire any of the features that tend to be active in the context of the prefix The cost was, and therefore p θ,t (37) p θ,t (Grenoble). This is in stark contrast to the behavior of the original RNN, for which both 37 and Grenoble were undistinguishable unknown words. We note that, while the model is able to capitalize on the generic notion of number through its feature φ number , it is also able to learn to privilege certain specific numbers belonging to V 1 if they tend to appear more fre- quently in certain contexts. A log-linear model has the important advantage of being able to handle redundant features 12 such as φ number and φ ˜ 3 which both fire on 3. Depending on prior expectations about typical texts in the domain being handled, it may then be useful to introduce features for distin- guishing between different classes of numbers, for instance "small numbers" or "year-like numbers", allowing the LL-RNN to make useful generalizations based on these features. Such features need not be binary, for example a small-number feature could take values decreasing from 1 to 0, with the higher values reserved for the smaller numbers.While our example focussed on the case of numbers, it is clear that our observations equally apply to other features that we mentioned, such as φ location (x), which can serve to generalize predictions in such contexts as We are travelling to.In principle, generally speaking, any features that can support gener- alization, such as features representing semantic classes (e.g. nodes in the Wordnet hierarchy), morphosyntactic classes (lemma, gender, number, etc.) or the like, can be useful.The extension from softmax to log-linear outputs, while formally simple, opens a significant range of potential applications other than the handling of rare words. We now briefly sketch a few directions.A priori constrained sequences For some applications, sequences to be generated may have to respect certain a priori constraints. One such case is the approach to semantic parsing of ( Xiao et al., 2016), where starting from a natural language question an RNN decoder produces a sequential encoding of a logical form, which has to conform to a certain grammar. The model used is implicitely a simple case of LL-RNN, where (in our present terminology) the output feature vector φ remains the usual oneHot, but the background b is not uniform anymore, but constrains the generated sequence to conform to the grammar.Language model adaptation We saw earlier that by taking b to be uni- form and φ to be a oneHot, an LL-RNN is just a standard RNN. The opposite extreme case is obtained by supposing that we already know the exact gen- erative process for producing x t+1 from the context K = C, x 1 , x 2 , . . . , x t . If we define b(K; ·) = b(K; x) to be identical to this true underlying process, then in order to have the best performance in test, it is sufficient for the adaptor vector a θ,t to be equal to the null vector, because then, according to (13), p θ,t (x) ∝ b(K; x) is equal to the underlying process. The task for the RNN to learn a θ such that a θ,t is null or close to null is an easy one (just take the higher level parameter matrices to be null or close to null), and in this case the adaptor has actually nothing to adapt to.A more interesting, intermediary, case is when b(K; x) is not too far from the true process. For example, b could be a word-based language model (n-gram type, LSTM type, etc.) trained on some large monolingual corpus, while the current focus is on modeling a specific domain for which much less data is available. Then training the RNN-based adaptor a θ on the specific domain data would still be able to rely on b for test words not seen in the specific data, but learn to upweight the prediction of words often seen in these specific data. 13 Input features In a standard RNN, a word x t is vector-encoded through a one-hot representation both when it is produced as the current output of the network but also when it is used as the next input to the network. In section 3, we saw the interest of defining the "output" features φ to go beyond word-identity features -i.e. beyond the identification φ(x) = oneHot(x) -, but we kept the "input" features as in standard RNNs, namely we kept ψ(x) = oneHot(x) . However, let us note an issue there. This usual encoding of the input x means that if x = 37 has rarely (or not at all) been seen in the training data, then the network will have few clues to distinguish this word from another rarely observed word (for example the adjective preposterous) when computing f θ in equation 11. The network, in the context of the prefix the cost was, is able to give a reasonable probability to 37 thanks to φ. However, when assessing the probability of euros in the context of the prefix the cost was 37, this is not distinguished by the network from the prefix the cost was preposterous, which would not allow euros as the next word. A promising way to solve this problem here is to take ψ = φ, namely to encode the input x using the same features as the output x. This allows the network to "see" that 37 is a number and that preposterous is an adjective, and to compute its hidden state based on this information. We should note, however, that there is no requirement that ψ be equal to φ in general; the point is that we can include in ψ features which can help the network predict the next word.Infinite domains In the example of section 3, the vocabulary V 2 was large, but finite. This is quite artificial, especially if we want to account for words representing numbers, or words taken in some open-ended set, such as entity names. Let us go back to the equation (5) defining log-linear models, and let us ignore the context K for simplicity:, with. When V is finite, then the normalization factor Z(a) is also finite, and therefore the probability p(x|a) is well defined; in particular, it is well-defined when b(x) = 1 uniformly. However, when V is (countably) infinite, then this is unfortunately not true anymore. For instance, with b(x) = 1 uniformly, and with a = 0, then Z(a) is infinite and the probability is undefined. By contrast, let's assume that the background function b is in L 1 (V ), i.e. x∈V b(x) &lt; ∞. Let's also suppose that the feature vector φ is uniformly bounded (that is, all its coordinates φ i are such that ∀x ∈ V, φ i (x) ∈ [α i , β i ], for α i , β i ∈ R). Then, for any a, Z(a) is finite, and therefore p(x|a) is well-defined.Thus, the standard RNNs, which have (implicitely) a uniform background b, have no way to handle infinite vocabularies, while LL-RNNs, by using a finite-mass b, can. One simple way to ensure that property on tokens representing numbers, for example, is to associate them with a geometric background distribution, decaying fast with their length, and a similar treat- ment can be done for named entities.Condition-based priming Many applications of RNNs, such as machine translation ) or natural language generation (Wen et al., 2015), etc., depend on a condition C (source sentence, semantic repre- sentation, etc.). When translated into LL-RNNs, this condition is taken into account through the input feature vector ψ(C, x 1 , . . . ,However, there is opportunity for exploiting the condition inside b or φ. To sketch a simple example, in NLG, one may be able to predefine some weak unigram language model for the realization that depends on the semantic input C, for example by constraining named entities that appear in the realization to have some evidence in the input. Such a language model can be usefully represented through the background process b(C, x 1 , . . . , x t ; x t+1 ) = b(C; x t+1 ), providing a form of "priming" for the combined LL-RNN, helping it to avoid irrelevant tokens.A similar approach was recently exploited in Goyal et al. (2016), in the context of a character-based seq2seq LSTM for generating utterances from input "dialog acts". In this approach, the background b, formulated as a weighted finite-state automaton over characters, is used both for encour- aging the system to generate character strings that correspond to possible dictionary words, as well as to allow it to generate strings corresponding to such non-dictionary tokens as named-entities, numbers, addresses, and the like, but only when such strings have evidence in the input dialog act.Our datasets are based on the annotated French corpora 14 provided by the Universal Dependencies initiative 15 . These corpora are tagged at the POS level as well as at the dependency level. In our experiments, we only exploit the POS annotations, and we use lowercased versions of the corpora. Table 2 shows the sentence sizes of our different datasets, and  The corpora provide POS and Morphological tags for each word token in the context of the sentence in which it appears. Table 3 shows the 52 tags that we use, which we treat as binary features. In addition, we select the M most frequent word types appearing in the entire corpus, and we use M + 1 additional binary features which identify whether a given word is identical to one of the M most frequent words, or whether it is outside this set. In total, we then use M + 53 binary features. We collect all the word types appearing in the entire corpus and we associate with each a binary vector of size M + 53 which is the boolean union of the binary vectors associated with all the tokens for that type. In case of an ambiguous word, the binary vector may have ones on several POS simultaneously. 16 Thus, here, we basically use the corpus as a proxy for a morphological analyser of French, and we do not use the contextual information provided by the token-level tags.In these experiments, we use a finite word vocabulary V consisting of the 42894 types found in the entire corpus (including the validation and test sets). We then compare our LL-RNN with a vanilla RNN, both over this vocabulary V . Thus none of the models has unknown words. Both models are implemented in Keras (Chollet, 2015) over a Theano (Theano Develop- ment Team, 2016) backend.The baseline RNN is using one-hot encodings for the words in V , and consists of an embedding layer of dimension 256 followed by two LSTM (Hochreiter and Schmidhuber, 1997) layers of dimension 256, followed by a dense layer and finally a softmax layer both of dimension |V |. The LSTM sequence length for predicting the next word is fixed at 8 words. SGD is done through rmsprop and the learning rate is fixed at 0.001.The LL-RNN has the same architecture and parameters, but for the following differences. First, the direct embedding of the input words is replaced by an embedding of dimension 256 of the representation of the words in the space of the M + 53 features (that is the input feature vector ψ is of dimension M + 53). This is followed by the same two LSTMs as before, both of dimension 256. This is now followed by a dense layer of output dimension M + 53 (the a θ weights over the output feature vector φ, here identical to ψ.). This layer is then transformed in a deterministic way into a probability distribution over V , after incorporation of a fixed background probability distribution b over V . This background b has been precomputed as the unigram probability distribution of the word types over the entire corpus. 17   Table 4: Log-perplexities per word (base e) of different models. The per- plexity per word corresponding to a log-perplexity of 5.08 (resp. 6.07) is 161 (resp. 433).We observe a considerable improvement of perplexity between the base- line and all the LL-RNN models, the largest one being for M = 2500 - where the perplexity is divided by a factor of 433/161 2.7 -with some tendency of the models to degrade when M becomes either very large or very small.An initial, informal, qualitative look at the sentences generated by the RNN model on the one hand and by the best LL-RNN model on the other hand, seems to indicate a much better ability of the LL-RNN to account for agreement in gender and number at moderate distances (see Table 5), but a proper evaluation has not yet been performed.  Table 5: Example of a sentence generated by LL-RNN (2500). The right column shows the non-null features for each word. Note that représentée, which is not among the most frequent 2500 words (TOPFORM:@notTop), has proper agreement (Gender:Fem, Number:Sing) with the distant pronoun elle. 19 19 As a side remark, we observe some flawed features, due to a small number of gold- annotation errors, such as the fact thatàthat`thatà appears both with the correct POS:ADP (ad- position -a generic term covering prepositions), but also some impossible POS's (AUX, NOUN,VERB). We have not attempted to filter out these (relatively rare) gold-annotation mistakes, but doing so could only improve the results.LL-RNNs simply extend RNNs by replacing the softmax parametrization of the output with a log-linear one, but this elementary move has two major consequences.The first consequence is that two elements x, x ∈ V , rather than being individuals without connections, can now share attributes. This is a funda- mental property for linguistics, where classical approaches represent words as combination of "linguistic features", such as POS, lemma, number, gen- der, case, tense, aspect, register, etc. With the standard RNN softmax approach, two words that are different on even a single dimension have to be predicted independently, which can only be done effectively in presence of large training sets. In the LL-RNN approach, by associating different φ features to the different linguistic "features", the model can learn to pre- dict a plural number based on observation of plural numbers, an accusative based on the observation of accusatives, and so on, and then predict word forms that are combinations that have never been observed in the training data. We saw an example of this phenomenon in the experiments of section 5. 20 If the linguistic features encompass semantic classes (possibly provided by Wordnet, or else by semantically-oriented embeddings) then generaliza- tions become possible over these semantic classes also. By contrast, in the softmax case, not only the models are deficient in presence of sparsity of training data for word forms, but they also require to waste capacity of the RNN parameters θ to make them able to map to the large a θ vectors that are required to discriminate between the many elements of V ; with LL-based RNNs, the parametrization a θ can in principle be smaller, because fewer φ features need to be specified to obtain word level predictions.The second consequence is that we can exploit rich prior knowledge through the input features ψ, the background b, and the output features φ. We already gave some illustrations of incorporating prior knowledge in this way, but there are many other possibilities. For example, in a dialogue application that requires some answer utterances to contain numerical data that can only be obtained by access to a knowledge base, a certain binary "expert feature" φ e (K; x) could take the value 1 if and only if x is either a non-number word or a specific number n obtained by some (more or less complex) process exploiting the context K in conjunction with the knowl- edge base. In combination with a background b and other features in φ, who would be responsible for the linguistic quality of the answer utterance, the φ e feature, when activated, would ensure that if a number is produced at this point, it is equal to n, but would not try to decide at exactly which point a number should be produced (this is better left to the "language specialists": b and the other features). Whether the feature φ e is activated would be decided by the RNN: a large value of the e coordinate of a θ,t would activate the feature, a small (close to null) value deactivate it. 21 We conclude by a remark concerning the complementarity of the log- linear component and the neural network component in the LL-RNN ap- proach. On its own, as has been amply demonstrated in recent years, a standard softmax-based RNN is already quite powerful. On its own, a stand-alone log-linear model is also quite powerful, as older research also demonstrated. Roughly, the difference between a log-linear model and a LL-RNN model is that in the first, the log-linear weights (in our notation, a) are fixed after training, while in the LL-RNN they dynamically vary un- der the control of the neural network component. 22 However, the strengths of the two classes of models lie in different areas. The log-linear model is very good at exploiting prior knowledge in the form of complex features, but it has no ability to discover new combinations of features. On the other hand, the RNN is very good at discovering which combinations of character- istics of its input are predictive of the output (representation learning), but is ill-equipped for exploiting prior knowledge. We argue that the LL-RNN approach is a way to capitalize on these complementary qualities. 21 The idea is reminiscent of the approach of Le et al. (2016), who use LSTM-based mixtures of experts for a similar purpose; the big difference is that here, instead of using a linear mixture, we use a "log-linear mixture", i.e. our features are combined multi- plicatively rather than additively, with exponents given by the RNN, that is they are "collaborating", while in their approach the experts are "competing": their expert cor- responding to φe needs to decide on its own at which exact point it should produce the number, rather than relying on the linguistic specialist to do it. This "multiplicative" aspect of the LL-RNNs can be related to the product of experts in- troduced by Hinton (2002). However, in his case, the focus is on learning the individual experts, which are then combined through a direct product, not involving exponentiations, and therefore not in the log-linear class. In our case, the focus is on exploiting predefined experts (or features), but on letting a "controlling" RNN decide about their exponents. 22 Note how a standard log-linear model with oneHot features over V would not make sense: with a fixed, it would always predict the same distribution for the next word. By contrast, a LL-RNN over the same features does make sense: it is a standard RNN. Standard log-linear models have to employ more interesting features.
