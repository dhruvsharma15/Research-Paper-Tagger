Many practical applications build on graph-structured data, and thus we often want to perform ma- chine learning tasks that take graphs as inputs. Standard approaches to the problem include engineer- ing custom features of an input graph, graph kernels ( Kashima et al., 2003;Shervashidze et al., 2011), and methods that define graph features in terms of random walks on graphs ( Perozzi et al., 2014). More closely related to our goal in this work are methods that learn features on graphs, including Graph Neural Networks ( Gori et al., 2005;Scarselli et al., 2009), spectral networks ( Bruna et al., 2013) and recent work on learning graph fingerprints for classification tasks on graph representations of chemical molecules (Duvenaud et al., 2015).Our main contribution is an extension of Graph Neural Networks that outputs sequences. Previous work on feature learning for graph-structured inputs has focused on models that produce single outputs such as graph-level classifications, but many problems with graph inputs require outputting sequences. Examples include paths on a graph, enumerations of graph nodes with desirable properties, or sequences of global classifications mixed with, for example, a start and end node. We are not aware of existing graph feature learning work suitable for this problem. Our motivating application comes from program verification and requires outputting logical formulas, which we formulate as a sequential output problem. A secondary contribution is highlighting that Graph Neural Networks (and further extensions we develop here) are a broadly useful class of neural network model that is applicable to many problems currently facing the field.There are two settings for feature learning on graphs: (1) learning a representation of the input graph, and (2) learning representations of the internal state during the process of producing a sequence of outputs. Here, (1) is mostly achieved by previous work on Graph Neural Networks ( Scarselli et al., 2009); we make several minor adaptations of this framework, including changing it to use modern practices around Recurrent Neural Networks. (2) is important because we desire outputs from graph- structured problems that are not solely individual classifications. In these cases, the challenge is how to learn features on the graph that encode the partial output sequence that has already been produced (e.g., the path so far if outputting a path) and that still needs to be produced (e.g., the remaining path). We will show how the GNN framework can be adapted to these settings, leading to a novel graph-based neural network model that we call Gated Graph Sequence Neural Networks (GGS-NNs).We illustrate aspects of this general model in experiments on bAbI tasks ( Weston et al., 2015) and graph algorithm learning tasks that illustrate the capabilities of the model. We then present an application to the verification of computer programs. When attempting to prove properties such as memory safety (i.e., that there are no null pointer dereferences in a program), a core problem is to find mathematical descriptions of the data structures used in a program. Following Brockschmidt et al. (2015), we have phrased this as a machine learning problem where we will learn to map from a set of input graphs, representing the state of memory, to a logical description of the data structures that have been instantiated. Whereas Brockschmidt et al. (2015) relied on a large amount of hand-engineering of features, we show that the system can be replaced with a GGS-NN at no cost in accuracy.In this section, we review Graph Neural Networks (GNNs) ( Gori et al., 2005;Scarselli et al., 2009) and introduce notation and concepts that will be used throughout.GNNs are a general neural network architecture defined according to a graph structure G = (V, E). Nodes v ∈ V take unique values from 1, . . . , |V|, and edges are pairs e = (v, v ) ∈ V × V. We will focus in this work on directed graphs, so (v, v ) represents a directed edge v → v , but we note that the framework can easily be adapted to undirected graphs; see Scarselli et al. (2009). The node vector (or node representation or node embedding) for node v is denoted by h v ∈ R D . Graphs may also contain node labels l v ∈ {1, . . . , L V } for each node v and edge labels or edge types l e ∈ {1, . . . , L E } for each edge. We will overload notation and let h S = {h v | v ∈ S} when S is a set of nodes, and l S = {l e | e ∈ S} when S is a set of edges. The function IN(v) = {v | (v , v) ∈ E} returns the set of predecessor nodes v with v → v. Analogously, OUT(v) = {v | (v, v ) ∈ E} is the set of successor nodes v with edges v → v . The set of all nodes neighboring v is NBR(v) = IN(v) ∪ OUT(v), and the set of all edges incoming to or outgoing from v is CO(v) GNNs map graphs to outputs via two steps. First, there is a propagation step that computes node rep- resentations for each node; second, an output model o v = g(h v , l v ) maps from node representations and corresponding labels to an output o v for each v ∈ V. In the notation for g, we leave the depen- dence on parameters implicit, and we will continue to do this throughout. The system is differentiable from end-to-end, so all parameters are learned jointly using gradient-based optimization.Here, an iterative procedure propagates node representations. Initial node representations hv are set to arbitrary values, then each node representation is updated following the recurrence below until convergence, where t denotes the timestep: v) ). Several variants are discussed in Scarselli et al. (2009) including positional graph forms, node-specific updates, and alternative representations of neighborhoods. Concretely, Scarselli et al. (2009) suggest decomposing f * (·) to be a sum of per-edge terms:where f (·) is either a linear function of h v or a neural network. The parameters of f depends on the configuration of labels, e.g. in the following linear case, A and b are learnable parameters,The output model is defined per node and is a differentiable function g(h v , l v ) that maps to an output. This is generally a linear or neural network mapping. Scarselli et al. (2009) focus on outputs that are Published as a conference paper at ICLR 2016 independent per node, which are implemented by mapping the final node representations hv , l v ) for each node v ∈ V. To handle graph-level classifications, they suggest to create a dummy "super node" that is connected to all other nodes by a special type of edge. Thus, graph-level regression or classification can be handled in the same manner as node-level regression or classification.Learning is done via the Almeida-Pineda algorithm (Almeida, 1990;Pineda, 1987), which works by running the propagation to convergence, and then computing gradients based upon the converged solution. This has the advantage of not needing to store intermediate states in order to compute gradients. The disadvantage is that parameters must be constrained so that the propagation step is a contraction map. This is needed to ensure convergence, but it may limit the expressivity of the model. When f (·) is a neural network, this is encouraged using a penalty term on the 1-norm of the network's Jacobian. See Appendix A for an example that gives the intuition that contraction maps have trouble propagating information across a long range in a graph.We now describe Gated Graph Neural Networks (GG-NNs), our adaptation of GNNs that is suitable for non-sequential outputs. We will describe sequential outputs in the next section. The biggest mod- ification of GNNs is that we use Gated Recurrent Units ( Cho et al., 2014) and unroll the recurrence for a fixed number of steps T and use backpropagation through time in order to compute gradients. This requires more memory than the Almeida-Pineda algorithm, but it removes the need to constrain parameters to ensure convergence. We also extend the underlying representations and output model.In GNNs, there is no point in initializing node representations because the contraction map constraint ensures that the fixed point is independent of the initializations. This is no longer the case with GG-NNs, which lets us incorporate node labels as additional inputs. To distinguish these node labels used as inputs from the ones introduced before, we call them node annotations, and use vector x to denote these annotations.To illustrate how the node annotations are used, consider an example task of training a graph neural network to predict whether node t can be reached from node s on a given graph. For this task, there are two problem-related special nodes, s and t. To mark these nodes as special, we give them an initial annotation. The first node s gets the annotation x s = [1,0] , and the second node t gets the annotation x t = [0,1] . All other nodes v have their initial annotation set to x v = [0,0] . Intuitively, this marks s as the first input argument and t as the second input argument. We then initialize the node state vectors h (1) v using these label vectors by copying x v into the first dimensions and padding with extra 0's to allow hidden states that are larger than the annotation size.In the reachability example, it is easy for the propagation model to learn to propagate the node annota- tion for s to all nodes reachable from s, for example by setting the propagation matrix associated with forward edges to have a 1 in position (0,0). This will cause the first dimension of node representation to be copied along forward edges. With this setting of parameters, the propagation step will cause all nodes reachable from s to have their first bit of node representation set to 1. The output step classifier can then easily tell whether node t is reachable from s by looking whether some node has nonzero entries in the first two dimensions of its representation vector.The basic recurrence of the propagation model isOutgoing EdgesIncoming Edges 1 2 3 4 The matrix A ∈ R D|V|×2D|V| determines how nodes in the graph communicate with each other. The sparsity structure and parameter tying in A is illustrated in Fig. 1. The sparsity structure corresponds to the edges of the graph, and the parameters in each submatrix are determined by the edge type and direction. A v: ∈ R D|V|×2D are the two columns of blocks in A (out) and A (in) corresponding to node v. Eq. 1 is the initialization step, which copies node annotations into the first components of the hidden state and pads the rest with zeros. Eq. 2 is the step that passes information between different nodes of the graph via incoming and outgoing edges with parameters dependent on the edge type and direction. acontains activations from edges in both directions. The remaining are GRU-like updates that incorporate information from the other nodes and from the previous timestep to update each node's hidden state. z and r are the update and reset gates, σ(x) = 1/(1 + e −x ) is the logistic sigmoid function, and is element-wise multiplication. We initially experimented with a vanilla recurrent neural network-style update, but in preliminary experiments we found this GRU-like propagation step to be more effective.There are several types of one-step outputs that we would like to produce in different situations. First, GG-NNs support node selection tasks by making o v = g(h (T ) v , x v ) for each node v ∈ V output node scores and applying a softmax over node scores. Second, for graph-level outputs, we define a graph level representation vector asv∈V where σ(i(hv , x v )) acts as a soft attention mechanism that decides which nodes are relevant to the current graph-level task. i and j are neural networks that take the concatenation of h (T ) v and x v as input and outputs real-valued vectors. The tanh functions can also be replaced with the identity.Here we describe Gated Graph Sequence Neural Networks (GGS-NNs), in which several GG-NNs operate in sequence to produce an output sequence o (1) . . . o (K) .For the k th output step, we denote the matrix of node annotations ascan be seen as the states carried over from step k to k + 1.X contain a propagation model and an output model. In the propagation models, we denote the matrix of node vectors at the t th propagation step of the k th output step asAs before, in step k, we set H (k,1) by 0-extending X (k) per node. An overview of the model is shown in Fig. 2 . . . We introduce a node annotation output model for predicting X (k+1) from H (k,T ) . The prediction is done for each node independently using a neural network j(hv as input and outputs a vector of real-valued scores:There are two settings for training GGS-NNs: specifying all intermediate annotations X (k) , or train- ing the full model end-to-end given only X (1) , graphs and target sequences. The former can improve performance when we have domain knowledge about specific intermediate information that should be represented in the internal state of nodes, while the latter is more general. We describe both.Sequence outputs with observed annotations Consider the task of making a sequence of predic- tions for a graph, where each prediction is only about a part of the graph. In order to ensure we predict an output for each part of the graph exactly once, it suffices to have one bit per node, indicat- ing whether the node has been "explained" so far. In some settings, a small number of annotations are sufficient to capture the state of the output procedure. When this is the case, we may want to directly input this information into the model via labels indicating target intermediate annotations. In some cases, these annotations may be sufficient, in that we can define a model where the GG-NNs are rendered conditionally independent given the annotations.In this case, at training time, given the annotations X (k) the sequence prediction task decomposes into single step prediction tasks and can be trained as separate GG-NNs. At test time, predicted annotations from one step will be used as input to the next step. This is analogous to training directed graphical models when data is fully observed.Sequence outputs with latent annotations More generally, when intermediate node annotationsare not available during training, we treat them as hidden units in the network, and train the whole model jointly by backpropagating through the whole sequence.In this section we present example applications that concretely illustrate the use of GGS-NNs. We focus on a selection of bAbI artificial intelligence (AI) tasks (Weston et al., 2015) and two graph algorithm learning tasks.The bAbI tasks are meant to test reasoning capabilities that AI systems should be capable of. In the bAbI suite, there are 20 tasks that test basic forms of reasoning like deduction, induction, counting, and path-finding.We have defined a basic transformation procedure that maps bAbI tasks to GG-NNs or GGS-NNs. We use the --symbolic option from the released bAbI code to get stories that just involve sequences of relations between entities, which are then converted into a graph. Each entity is mapped to a node, and each relation is mapped to an edge with edge label given by the relation. The full story is consumed and mapped to a single graph. Questions are marked by eval in the data and are comprised of a question type (e.g., has fear), and some argument (e.g., one or more nodes). The arguments are converted into initial node annotations, with the i-th bit of the i-th argument node's annotation vector set to 1. For example, if the eval line is eval E &gt; A true, then E gets initial annotation x (1) (1), and for all other nodes v,. Question type is 1 (for '&gt;') and output is class 1 (for 'true'). Some tasks have multiple question types, for example Task 4 which has 4 question types: e, s, w, n. For such tasks we simply train a separate GG- NN for each task. We do not use the strong supervision labels or give the GGS-NNs any intermediate annotations in any experiments.While simple, this transformation does not preserve all information about the story (e.g., it discards temporal order of the inputs), and it does not easily handle ternary and higher order relations (e.g., Yesterday John went to the garden is not easily mapped to a simple edge). We also emphasize that it is a non-trivial task to map general natural language to symbolic form, 1 so we could not directly apply this approach to arbitrary natural language. Relaxing these restrictions is left for future work.However, even with this simple transformation, there are a variety of bAbI tasks that can be formu- lated, including Task 19 (Path Finding), which is arguably the hardest task. We provide baselines to show that the symbolic representation does not help RNNs or LSTMs significantly, and show that GGS-NNs solve the problem with a small number of training instances. We also develop two new bAbI-like tasks that involve outputting sequences on graphs: shortest paths, and a simple form of Eulerian circuits (on random connected 2-regular graphs). The point of these experiments is to illustrate the capabilities of GGS-NNs across a variety of problems. Example 1. As an example, below is an instance from the symbolic dataset for bAbI task 15, Basic Deduction.Here the first 8 lines describe the facts, the GG-NN will use these facts to build a graph. Capital letters are nodes, is and has fear are interpreted as edge labels or edge types. The last 4 lines are 4 questions asked for this input data. has fear in these lines are interpreted as a question type. For this task, in each question only one node is special, e.g. the B in eval B has fear, and we assign a single value 1 to the annotation vector for this special node and 0 to all the other nodes.For RNN and LSTM the data is converted into token sequences like below: n6 e1 n1 eol n6 e1 n5 eol n1 e1 n2 eol n4 e1 n5 eol n3 e1 n4 eol n3 e1 n5 eol n6 e1 n4 eol q1 n6 n2 ans 1where n&lt;id&gt; are nodes, e&lt;id&gt; are edges, q&lt;id&gt; are question types, extra tokens eol (end-of- line) and ans (answer) are added to give the RNN &amp; LSTM access to the complete information available in the dataset. The final number is the class label.Example 2. As a second example, below is an instance from the symbolic dataset for bAbI task 19, Path Finding.Here the first 4 lines describe edges, s, n, w, e (e does not appear in this example) are all different edge types. The last line is a path question, the answer is a sequence of directions w,s, as the path going from B to A is to first go west to E then go south to A. The s, n, w, e in the question lines are treated as output classes.More Training Details. For all tasks in this section, we generate 1000 training examples and 1000 test examples, 50 of the training examples are used for validation. When evaluating model performance, for all bAbI tasks that contain more than one questions in one example, the predictions for different questions were evaluated independently. As there is randomness in the dataset generation process, we generated 10 such datasets for each task, and report the mean and standard deviation of the evaluation performance across the 10 datasets.For all explanatory tasks, we start by training different models on only 50 training examples, and gradually increase the number of training examples to 100, 250, 500, and 950 (50 of the training examples are reserved for validation) until the model's test accuracy reaches 95% or above, a success by bAbI standard Weston et al. (2015). For each method, we report the minimum number of training examples it needs to reach 95% accuracy along with the accuracy it reaches with that amount of training examples. In all these cases, we unrolled the propagation process for 5 steps. For bAbI task 4, 15, 16, 18, 19, we used GG-NN with the size of node vectors h X share a single propagation model. For shortest path and Eulerian circuit tasks, we used D = 20. All models are trained long enough with Adam (Kingma &amp; Ba, 2014), and the validation set is used to choose the best model to evaluate and avoid models that are overfitting.We choose four bAbI tasks that are suited to the restrictions described above and require single step outputs: 4 (Two Argument Relations), 15 (Basic Deduction), 16 (Basic Induction), and 18 (Size Reasoning). For Task 4, 15 and 16, a node selection GG-NN is used. For Task 18 we used a graph- level classification version. All the GGNN networks contain less than 600 parameters 2 .As baselines, we train RNN and LSTM models on the symbolic data in raw sequence form. The RNNs and LSTMs use 50 dimensional embeddings and 50 dimensional hidden layers; they predict a single output at the end of the sequences and the output is treated as a classification problem, the loss is cross entropy. The RNNs and LSTMs contain around 5k and 30k parameters, respectively.Test results appear in Table 1. For all tasks GG-NN achieves perfect test accuracy using only 50 training examples, while the RNN/LSTM baselines either use more training examples (Task 4) or fail to solve the tasks (Task 15, 16 and 18).In Table 2, we further break down performance of the baselines for task 4 as the amount of training data varies. While both the RNN and LSTM are able to solve the task almost perfectly, the GG- NN reaches 100% accuracy with much less data.  Table 2: Performance breakdown of RNN and LSTM on bAbI task 4 as the amount of training data changes.The bAbI Task 19 (Path Finding) is arguably the hardest task among all bAbI tasks (see e.g., (Sukhbaatar et al., 2015), which reports an accuracy of less than 20% for all methods that do not use the strong supervision). We apply a GGS-NN to this problem, again on the symbolic form of the data (so results are not comparable to those in ( Sukhbaatar et al., 2015)). An extra 'end' class is added to the end of each output sequence; at test time the network will keep making predictions until it predicts the 'end' class.The results for this task are given in Table 3. Both RNN and LSTM fail on this task. However, with only 50 training examples, our GGS-NNs achieve much better test accuracy than RNN and LSTM.  We further developed two new bAbI-like tasks based on algorithmic problems on graphs: Shortest Paths, and Eulerian Circuits. For the first, we generate random graphs and produce a story that lists all edges in the graphs. Questions come from choosing two random nodes A and B and asking for the shortest path (expressed as a sequence of nodes) that connects the two chosen nodes. We constrain the data generation to only produce questions where there is a unique shortest path from A to B of length at least 2. For Eulerian circuits, we generate a random two-regular connected graph and a separate random distractor graph. The question gives two nodes A and B to start the circuit, then the question is to return the Eulerian circuit (again expressed as a sequence of nodes) on the given subgraph that starts by going from A to B. Results are shown in the Table 3. RNN and LSTM fail on both tasks, but GGS-NNs learns to make perfect predictions using only 50 training examples. To prove that this program indeed concatenates the two lists a and b and that all pointer dereferences are valid, we need to (mathematically) characterize the program's heap in each iteration of the loop. For this, we use separation logic (O' Hearn et al., 2001;Reynolds, 2002), which uses inductive predicates to describe abstract data structures. For example, a list segment is defined as ls(x, y) ≡ x = y ∨ ∃v, n.ls(n, y) * x → {val : v, next : n}, where x → {val : v, next : n} means that x points to a memory region that contains a structure with val and next fields whose values are in turn v and n. The * connective is a conjunction as ∧ in Boolean logic, but additionally requires that its operators refer to "separate" parts of the heap. Thus, ls(cur, NULL) implies that cur is either NULL, or that it points to two values v, n on the heap, where n is described by ls again. The formula ∃t.ls(a, cur) * ls(cur, NULL) * ls(b, t) is an invariant of the loop (i.e., it holds when entering the loop, and after every iteration). Using it, we can prove that no program run will fail due to dereferencing an unallocated memory address (this property is called memory safety) and that the function indeed concatenates two lists using a Hoare-style verification scheme (Hoare, 1969).The hardest part of this process is coming up with formulas that describe data structures, and this is where we propose to use machine learning. Given a program, we run it a few times and extract the state of memory (represented as a graph; see below) at relevant program locations, and then predict a separation logic formula. Static program analysis tools (e.g., (Piskac et al., 2014)) can check whether a candidate formula is sufficient to prove the desired properties (e.g., memory safety).Representing Heap State as a Graph As inputs we consider directed, possibly cyclic graphs representing the heap of a program. These graphs can be automatically constructed from a program's memory state. Each graph node v corresponds to an address in memory at which a sequence of pointers v 0 , . . . , v k is stored (we ignore non-pointer values in this work). Graph edges reflect these pointer values, i.e., v has edges labeled with 0, . . . , k that point to nodes v 0 , . . . , v k , respectively. A subset of nodes are labeled as corresponding to program variables.An example input graph is displayed as "Input" in Fig. 3. In it, the node id (i.e., memory address) is displayed in the node. Edge labels correspond to specific fields in the program, e.g., 0 in our example corresponds to the next pointer in our example function from the previous section. For binary trees there are two more types of pointers left and right pointing to the left and right children of a tree node.Output Representation Our aim is to mathematically describe the shape of the heap. In our model, we restrict ourselves to a syntactically restricted version of separation logic, in which formulas are of the form ∃x 1 , . . . , x n .a 1 * . . . * a m , where each atomic formula a i is either ls(x, y) (a list from x to y), tree(x) (a binary tree starting in x), or none(x) (no data structure at x). Existential quantifiers are used to give names to heap nodes which are needed to describe a shape, but not labeled by a program variable. For example, to describe a "panhandle list" (a list that ends in a cycle), the first list element on the cycle needs to be named. In separation logic, this can be expressed as ∃t.ls(x, t) * ls(t, t).Data We can generate synthetic (labeled) datasets for this problem. For this, we fix a set of pred- icates such as ls and tree (extensions could consider doubly-linked list segments, multi-trees, . . .) together with their inductive definitions. Then we enumerate separation logic formulas instantiat- ing our predicates using a given set of program variables. Finally, for each formula, we enumerate heap graphs satisfying that formula. The result is a dataset consisting of pairs of heap graphs and associated formulas that are used by our learning procedures.It is easy to obtain the node annotations for the intermediate prediction steps from the data generation process. So we train a variant of GGS-NN with observed annotations (observed at training time; not test time) to infer formulas from heap graphs. Note that it is also possible to use an unobserved GGS-Step Labeled Graph OutStep Labeled Graph Out NN variant and do end-to-end learning. The procedure breaks down the production of a separation logic formula into a sequence of steps. We first decide whether to declare existential variables, and if so, choose which node corresponds to the variable. Once we have declared existentials, we iterate over all variable names and produce a separation logic formula describing the data structure rooted at the node corresponding to the current variable.The full algorithm for predicting separation logic formula appears below, as Alg. 1. We use three explicit node annotations, namely is-named (heap node labeled by program variable or declared existentially quantified variable), active (cf. algorithm) and is-explained (heap node is part of data structure already predicted). Initial node labels can be directly computed from the input graph: "is- named" is on for nodes labeled by program variables, "active" and "is-explained" are always off (done in line 2). The commented lines in the algorithm are implemented using a GG-NN, i.e., Alg. 1 is an instance of our GGS-NN model. An illustration of the beginning of a run of the algorithm is shown in Fig. 3, where each step is related to one line of the algorithm.Input: Heap graph G with named program variables 1: X ← compute initial labels from G 2: H ← initialize node vectors by 0-extending X 3: while ∃ quantifier needed do Graph-level Classification ( †)t ← fresh variable name 5: v ← pick node Node Selection ( ‡)6:X ← turn on "is-named" for v in Xprint "∃t." 8: end while 9: for node v with label "is-named" in X doH ← initialize node vectors, turn on "active" label for v in Xpred ← pick data structure predicate Graph-level Classification (if pred = ls thenend ← pick list end node Node Selection (♥)print "ls( end ) * "15:print "pred ( * " X have separate propagation models. For all the GG-NN components in the GGS-NN pipeline, we unrolled the propagation process for 10 time steps. The GGS-NNs associated with step ( †) (deciding wheter more existentially quantified variable need to be declared) and ( ‡) (identify which node need to be declared as existentially quantified) uses D = 16 dimensional node representations. For all other GGS-NN components, D = 8 is used. Adam (Kingma &amp; Ba, 2014) is used for optimization, the models are trained on minibatches of 20 graphs, and optimized until training error is very low. For the graph-level classification tasks, we also artificially balanced classes to have even number of examples from each class in each minibatch. All the GGS-NN components contain less than 5k parameters and no overfitting is observed during training.In practice, a set of heap graphs will be given as input and a single output formula is expected to describe and be consistent with all the input graphs. The different heap graphs can be snapshots of the heap state at different points in the program execution process, or different runs of the same program with different inputs. We call this the "batch prediction" setup contrasting with the single graph prediction described in the main paper.To make batch predictions, we run one GGS-NN for each graph simultaneously. For each prediction step, the outputs of all the GGS-NNs at that step across the batch of graphs are aggregated.For node selection outputs, the common named variables link nodes on different graphs togeter, which is the key for aggregating predictions in a batch. We compute the score for a particular named variable t asVg(t) , where V g (t) maps variable name t to a node in graph g, and oVg(t) is the output score for named variable t in graph g. When applying a softmax over all names using o t as scores, this is equivalent to a model that computes p(toselect = t) = g p g (toselect = V g (t)). For graph-level classification outputs, we add up scores of a particular class across the batch of graphs, or equivalently compute p(class = k) = g p g (class = k). Node annotation outputs are updated for each graph independently as different graphs have completely different set of nodes. However, when the algorithm tries to update the annotation for one named variable, the nodes associated with that variable in all graphs are updated. During training, all labels for intermediate steps are available to us from the data generation process, so the training process again can be decomposed to single output single graph training.A more complex scenario allowing for nested data structures (e.g., list of lists) was discussed in Brockschmidt et al. (2015). We have also successfully extended the GGS-NN model to this case. More details on this can be found in Appendix C.For this paper, we produced a dataset of 327 formulas that involves three program variables, with 498 graphs per formula, yielding around 160,000 formula/heap graph combinations. To evaluate, we split the data into training, validation and test sets using a 6:2:2 split on the formulas (i.e., the formulas in the test set were not in the training set). We measure correctness by whether the formula predicted at test time is logically equivalent to the ground truth; equivalence is approximated by canonicalizing names and order of the formulas and then comparing for exact equality.We compared our GGS-NN-based model with a method we developed earlier (Brockschmidt et al., 2015). The earlier approach treats each prediction step as standard classification, and requires com- plex, manual, problem-specific feature engineering, to achieve an accuracy of 89.11%. In contrast, our new model was trained with no feature engineering and very little domain knowledge and achieved an accuracy of 89.96%.An example heap graph and the corresponding separation logic formula found by our GGS-NN model is shown in Fig. 4. This example also involves nested data structures and the batching extension developed in the previous section.We have also successfully used our new model in a program verification framework, supplying needed program invariants to a theorem prover to prove correctness of a collection of list-manipulating algorithms such as insertion sort. The following Table 4 lists a set of benchmark list manipulation programs and the separation logic formula invariants found by the GGS-NN model, which were successfully used in a verification framework to prove the correctness of corresponding programs.  Table 4: Example list manipulation programs and the separation logic formula invariants the GGS- NN model founds from a set of input graphs. The " =" parts are produced by a deterministic procedure that goes through all the named program variables in all graphs and checks for inequality.A further extension of the current pipeline has been shown to be able to successfully prove more sophisticated programs like sorting programs and various other list-manipulating programs.The most closely related work is GNNs, which we have discussed at length above. Micheli (2009) proposed another closely related model that differs from GNNs mainly in the output model. GNNs have been applied in several domains ( Gori et al., 2005;Di Massa et al., 2006;Scarselli et al., 2009;Uwents et al., 2011), but they do not appear to be in widespread use in the ICLR community. Part of our aim here is to publicize GNNs as a useful and interesting neural network variant.An analogy can be drawn between our adaptation from GNNs to GG-NNs, to the work of Domke (2011) and Stoyanov et al. (2011) in the structured prediction setting. There belief propagation (which must be run to near convergence to get good gradients) is replaced with truncated belief propagation updates, and then the model is trained so that the truncated iteration produce good results after a fixed number of iterations. Similarly, Recursive Neural Networks (Goller &amp; Kuchler, 1996;Socher et al., 2011) being extended to Tree LSTMs ( Tai et al., 2015) is analogous to our using of GRU updates in GG-NNs instead of the standard GNN recurrence with the aim of improving the long-term propagation of information across a graph structure.The general idea expressed in this paper of assembling problem-specific neural networks as a compo- sition of learned components has a long history, dating back at least to the work of Hinton (1988) on assembling neural networks according to a family tree structure in order to predict relations between people. Similar ideas appear in Hammer &amp; Jain (2004) and Bottou (2014).Graph kernels (Shervashidze et al., 2011;Kashima et al., 2003) can be used for a variety of kernel- based learning tasks with graph-structured inputs, but we are not aware of work that learns the kernels and outputs sequences. Perozzi et al. (2014) convert graphs into sequences by following random walks on the graph then learns node embeddings using sequence-based methods. Sperduti &amp; Starita (1997) map graphs to graph vectors then classify using an output neural network. There are several models that make use of similar propagation of node representations on a graph structure. Bruna et al. (2013) generalize convolutions to graph structures. The difference between their work and GNNs is analogous to the difference between convolutional and recurrent networks. Duvenaud et al. (2015) also consider convolutional like operations on graphs, building a learnable, differentiable variant of a successful graph feature. Lusci et al. (2013) converts an arbitrary undirected graph to a number of different DAGs with different orientations and then propagates node representations inwards towards each root, training an ensemble of models. In all of the above, the focus is on one-step problems.GNNs and our extensions have many of the same desirable properties of pointer networks (Vinyals et al., 2015); when using node selection output layers, nodes from the input can be chosen as outputs.There are two main differences: first, in GNNs the graph structure is explicit, which makes the models less general but may provide stronger generalization ability; second, pointer networks require that each node has properties (e.g., a location in space), while GNNs can represent nodes that are defined only by their position in the graph, which makes them more general along a different dimension.GGS-NNs are related to soft alignment and attentional models (e.g., Bahdanau et al. (2014); Kumar et al. (2015); Sukhbaatar et al. (2015)) in two respects: first, the graph representation in Eq. 7 uses context to focus attention on which nodes are important to the current decision; second, node annotations in the program verification example keep track of which nodes have been explained so far, which gives an explicit mechanism for making sure that each node in the input has been used over the sequence of producing an output.What is being learned? It is instructive to consider what is being learned by the GG-NNs. To do so, we can draw analogy between how the bAbI task 15 would be solved via a logical formulation. As an example, consider the subset of lines needed to answer one example on the right.To do logical reasoning, we would need not only a logical encoding of the facts present in the story but also the background world knowledge encoded as inference rules such as is(x, y) ∧ has-fear(y, z) =⇒ has-fear(x, z).Our encoding of the tasks simplifies the parsing of the story into graph form, but it does not provide any of the background knowledge. The GG-NN model can be seen as learning this, with results stored in the neural network weights.The results in the paper show that GGS-NNs have desirable inductive biases across a range of problems that have some intrinsic graph structure to them, and we believe there to be many more cases where GGS-NNs will be useful. There are, however, some limitations that need to be overcome to make them apply even more broadly. Two limitations that we mentioned previously are that the bAbI task translation does not incorporate temporal order of inputs or ternary and higher order relations. We can imagine several possibilities for lifting these restrictions, such as concatenating a series of GG-NNs, where there is one GG-NNs for each edge, and representing higher order relations as factor graphs. A more significant challenge is how to handle less structured input representations. For example, in the bAbI tasks it would be desirable not to use the symbolic form of the inputs. One possible approach is to incorporate less structured inputs, and latent vectors, in our GGS-NNs. However, experimentation is needed to find the best way of addressing these issues.The current GGS-NNs formulation specifies a question only after all the facts have been consumed. This implies that the network must try to derive all consequences of the seen facts and store all pertinent information to a node within its node representation. This is likely not ideal; it would be preferable to develop methods that take the question as an initial input, and then dynamically derive the facts needed to answer the question.We are optimistic about the further applications of GGS-NNs. We are particularly interested in continuing to develop end-to-end learnable systems that can learn about semantic properties of programs, that can learn more complicated graph algorithms, and in applying these ideas to problems that require reasoning over knowledge bases and databases. More generally, we consider these graph neural networks as representing a step towards a model that can combine structured representations with the powerful algorithms of deep learning, with the aim of taking advantage of known structure while learning and inferring how to reason with and extend these representations.Consider a linear 1-hidden unit cycle-structured GNN with N nodes {1, . . . , N }. For simplicity we ignored all edge labels and node labels, equivalently this is a simple example with L V = 1 and L E = 1. At each timestep t we update hidden states h 1 , . . . , h N asfor each i, where m i and b i are parameters of the propagation model. We use the convention that h j cycles around and refers to h N +j when j ≤ 0. Let. We can write the joint update for all i asRestrict the update to define a contraction mapping in the Euclidean metric. This means that there is some ρ &lt; 1 such that for any h, h ,or in other words,We can immediately see that this implies that |m i | &lt; ρ for each i by letting h be the elementary vector that is all zero except for a 1 in position i − 1 and letting h be the all zeros vector.Expanding Eq. 10, we getIn the GNN model, node label l i controls which values of m i and b i are used during the propagation. Looking at this expansion and noting that m i &lt; ρ for all i, we see that information about labels of nodes δ away will decay at a rate of 1 ρ δ . Thus, at least in this simple case, the restriction that T be a contraction means that it is not able to maintain long-range dependencies.The same analysis can be applied to a nonlinear update, i.e.where σ is any nonlinear function. Thenwherei . The contraction map definition Eq. 13 implies that each entry of the Jacobian matrix of T is bounded by ρ, i.e.To see this, consider two vectors h and h , where h k = h k , ∀k = j and h j + ∆ = h j . The definition in Eq. 13 implies that for all i,Thereforewhere the left hand side is ∂Ti ∂hj by definition as ∆ → 0.Also, because of the special cycle graph structure, for all other js we have ∂Ti ∂hj = 0. Applying this to the update at timestep t, we get1 could affect h t . Using the chain rule and the special graph structure, we haveAs ρ &lt; 1, this derivative will approach 0 exponentially fast as t grows. Intuitively, this means that the impact one node has on another node far away will decay exponetially, therefore making it difficult to model long range dependencies.RNN and LSTM performance on the sequence prediction tasks, i.e. bAbI task 19, shortest path and Eulerian circuit, are very poor compared to single output tasks. The Eulerian circuit task is the one that RNN and LSTM fail most dramatically. A typical training example for this task looks like the following,3 connected-to 7 7 connected-to 3 1 connected-to 2 2 connected-to 1 5 connected-to 7 7 connected-to 5 0 connected-to 4 4 connected-to 0 1 connected-to 0 0 connected-to 1 8 connected-to 6 6 connected-to 8 3 connected-to 6 6 connected-to 3 5 connected-to 8 8 connected-to 5 4 connected-to 2 2 connected-to 4 eval eulerian-circuit 5 7 5,7,3,6,8This describes a graph with two cycles 3-7-5-8-6 and 1-2-4-0, where 3-7-5-8-6 is the target cycle and 1-2-4-0 is a smaller distractor graph. All edges are presented twice in both directions for symmetry. The task is to find the cycle that starts with the given two nodes and in the direction from the first to the second. The distractor graph is added to increase the difficulty of this task, this also makes the output cycle not strictly "Eulerian".For RNN and LSTM the above training example is further transformed into a sequence of tokens, n4 e1 n8 eol n8 e1 n4 eol n2 e1 n3 eol n3 e1 n2 eol n6 e1 n8 eol n8 e1 n6 eol n1 e1 n5 eol n5 e1 n1 eol n2 e1 n1 eol n1 e1 n2 eol n9 e1 n7 eol n7 e1 n9 eol n4 e1 n7 eol n7 e1 n4 eol n6 e1 n9 eol n9 e1 n6 eol n5 e1 n3 eol n3 e1 n5 eol q1 n6 n8 ans 6 8 4 7 9Note the node IDs here are different from the ones in the original symbolic data. The RNN and LSTM read through the whole sequence, and start to predict the first output when reading the ans token. Then for each prediction step, the ans token is fed as the input and the target node ID (treated as a class label) is expected as the output. In this current setup, the output of each prediction step is not fed as the input for the next. Our GGS-NN model uses the same setup, where the output of one step is not used as input to the next, only the predicted node annotations X (k) carry over from one step to the next, so the comparison is still fair for RNN and LSTM. Changing both our method and the baselines to make use of previous predictions is left as future work.From this example we can see that the sequences the RNN and LSTM have to handle is quite long, close to 80 tokens before the predictions are made. Some predictions really depend on long range memory, for example the first edge (3-7) and first a few tokens (n4 e1 n8) in the sequence are needed to make prediction in the third prediction step (3 in the original symbolic data, and 4 in the tokenized RNN data). Keeping long range memory in RNNs is challenging, LSTMs do better than RNNs but still can't completely solve the problem. Another challenge about this task is the output sequence does not appear in the same order as in the input sequence. In fact, the data has no sequential nature at all, even when the edges are randomly permutated, the target output sequence should not change. The same applies for bAbI task 19 and the shortest path task. GGS-NNs are good at handling this type of "static" data, while RNN and LSTM are not. However future work is needed to determine how best to apply GGS-NNs to temporal sequential data which RNN and LSTM are good at. This is one limitation of the GGS-NNs model which we discussed in Section 8.Data structures like list of lists are nested data structures, in which the val pointer of each node in a data structure points to another data structure. Such data structures can be represented in sep- aration logic by allowing predicates to be nested. For example, a list of lists can be represented as ls(x, y, λt → ls(t, NULL)), where λt → ls(t, NULL) is a lambda expression and says that for each node in the list from x to y, its val pointer t satisfies ls(t, NULL). So there is a list from x to y, where each node in that list points to another list. A simple list without nested structures can be represented as ls(x, y, where represents an empty predicate. Note that unlike the non-nested case where the val pointer always points to NULL, we have to consider the val pointers here in order to describe and handle nested data structures.To make our GGS-NNs able to predict nested formulas, we adapt Alg. 1 to Alg. 2. Where an outer loop goes through each named variable once and generate a nested predicate with the node associated with that variable as the active node. The nested prediction procedure handles prediction similarly as in Alg. 1. Before calling the nested prediction procedure recursively, the node annotation update in line 32 not only annotates nodes in the current structure as "is-explained", but also annotates nodes linked to via the "val" pointer from all nodes in the current structure as "active". For the list of lists example, after predicting "ls(x, y,", the annotation step annotates all nodes in the list from x to y as "is-explained" and all nodes the val pointer points to from the list as "active". This knowledge is not hard coded into the algorithm, the annotation model can learn this behavior from data.Algorithm 2 Nested separation logic formula prediction procedure 1: procedure OUTERLOOP(G) Graph G with named program variables 2:X ← compute initial labels from Gfor each variable name var do 4:v ← node associated with var 5:turn on "active" bit for v in X 6:PREDICTNESTEDFORMULA(G, X , var)end for 8: end procedure while ∃ quantifier needed do Graph-level Classification ( †)e ← fresh existentially quantified variable name 14: v ← pick node Node Selection ( ‡)15:X ← turn on "is-named" for v in Xprint "∃e."end whileif var is a lambda variable name thenprint "λ var."end ifpred ← pick data structure predicate Graph-level Classification (if pred = ls then X ← update node annotations in X Node Annotation (♠)t ← fresh lambda variable name 34: PREDICTNESTEDFORMULA(G, X , t) Recursively predict all nested formulas.print ") * " 36: end procedure
