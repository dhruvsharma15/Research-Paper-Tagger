Regularization is one of the key elements of machine learning, particularly of deep learn- ing ( Goodfellow et al., 2016), allowing to generalize well to unseen data even when training on a finite training set or with an imperfect optimization procedure. In the traditional sense of optimization and also in older neural networks literature, the term "regularization" is reserved solely for a penalty term in the loss function (Bishop, 1995a). Recently, the term has adopted a broader meaning: Goodfellow et al. (2016, Chap. 5) loosely define it as "any modification we make to a learning algorithm that is intended to reduce its test error but not its training error". We find this definition slightly restrictive and present our working definition of regularization, since many techniques considered as regularization do reduce the training error (e.g. weight decay in AlexNet ( Krizhevsky et al., 2012)). Definition 1. Regularization is any supplementary technique that aims at making the model generalize better, i.e. produce better results on the test set.This can include various properties of the loss function, the loss optimization algorithm, or other techniques. Note that this definition is more in line with machine learning literature than with inverse problems literature, the latter using a more restrictive definition.Before we proceed to the presentation of our taxonomy, we revisit some basic machine learn- ing theory in Section 2. This will provide a justification of the top level of the taxonomy. In Sections 3-7, we continue with a finer division of the individual classes of the regularization techniques, followed by our practical recommendations in Section 8. We are aware that the many research works discussed in this taxonomy cannot be summarized in a single sentence. For the sake of structuring the multitude of papers, we decided to merely describe a certain subset of their properties according to the focus of our taxonomy. 1 The central task of our interest is model fitting: finding a function f that can well approx- imate a desired mapping from inputs x to desired outputs f (x). A given input x can have an associated target t which dictates the desired output f (x) directly (or in some applica- tions indirectly ( Ulyanov et al., 2016;Johnson et al., 2016)). A typical example of having available targets t is supervised learning. Data samples (x, t) then follow a ground truth probability distribution P .In many applications, neural networks have proven to be a good family of functions to choose f from. A neural network is a function f w : x → y with trainable weights w ∈ W . Training the network means finding a weight configuration w * minimizing a loss function L : W → R as follows:w Usually the loss function takes the form of expected risk :where we identify two parts, an error function E and a regularization term R. The error function depends on the targets and assigns a penalty to model predictions according to their consistency with the targets. The regularization term assigns a penalty to the model based on other criteria. It may depend on anything except the targets, for example on the weights (see Section 6).The expected risk cannot be minimized directly since the data distribution P is unknown. Instead, a training set D sampled from the distribution is given. The minimization of the expected risk can be then approximated by minimizing the empirical riskˆLriskˆ riskˆL:where (x i , t i ) are samples from D.Now we have the minimal background to formalize the division of regularization methods into a systematic taxonomy. In the minimization of the empirical risk, Eq. (3), we can identify the following elements that are responsible for the value of the learned weights, and thus can contribute to regularization:• D: The training set, discussed in Section 3• f : The selected model family, discussed in Section 4• E: The error function, briefly discussed in Section 5• R: The regularization term, discussed in Section 6• The optimization procedure itself, discussed in Section 7Ambiguity regarding the splitting of methods into these categories and their subcategories is discussed in Appendix A using notation from Section 3.The quality of a trained model depends largely on the training data. Apart from acquisi- tion/selection of appropriate training data, it is possible to employ regularization via data. This is done by applying some transformation to the training set D, resulting in a new set D R . Some transformations perform feature extraction or pre-processing, modifying the feature space or the distribution of the data to some representation simplifying the learning task. Other methods allow generating new samples to create a larger, possibly infinite, augmented dataset. These two principles are somewhat independent and may be combined. The goal of regularization via data is either one of them, or the other, or both. They both rely on transformations with (stochastic) parameters:Definition 2. Transformation with stochastic parameters is a function τ θ with pa- rameters θ which follow some probability distribution.In this context we consider τ θ which can operate on network inputs, activations in hid- den layers, or targets. An example of a transformation with stochastic parameters is the corruption of inputs by Gaussian noise (Bishop, 1995b;An, 1996):The stochasticity of the transformation parameters is responsible for generating new sam- ples, i.e. data augmentation. Note that the term data augmentation often refers specifically to transformations of inputs or hidden activations, but here we also list transformations of targets for completeness. The exception to the stochasticity is when θ follows a delta distri- bution, in which case the transformation parameters become deterministic and the dataset size is not augmented.We can categorize the data-based methods according to the properties of the used trans- formation and of the distribution of its parameters. We identify the following criteria for categorization (some of them later serve as columns in Tables 1-2):Stochasticity of the transformation parameters θ• Deterministic parameters: Parameters θ follow a delta distribution, size of the dataset remains unchanged • Stochastic parameters: Allow generation of a larger, possibly infinite, dataset. Var- ious strategies for sampling of θ exist:-Random: Draw a random θ from the specified distribution -Adaptive: Value of θ is the result of an optimization procedure, usually with the objective of maximizing the network error on the transformed sample (such "challenging" sample is considered to be the most informative one at current training stage), or minimizing the difference between the network prediction and a predefined fake target t ′ * Constrained optimization: θ found by maximizing error under hard con- straints (support of the distribution of θ controls the strongest allowed transformation) * Unconstrained optimization: θ found by maximizing modified error func- tion, using the distribution of θ as weighting (proposed herein for complete- ness, not yet tested) * Stochastic: θ found by taking a fixed number of samples of θ and using the one yielding the highest errorEffect on the data representation• Representation-preserving transformations: Preserve the feature space and attempt to preserve the data distribution • Representation-modifying transformations: Map the data to a different represen- tation (different distribution or even new feature space) that may disentangle the underlying factors of the original representation and make the learning problem easier• Input: Transformation is applied to x • Hidden-feature space: Transformation is applied to some deep-layer representation of samples (this also uses parts of f and w to map the input into the hidden-feature space; such transformations act inside the network f w and thus can be considered part of the architecture, additionally fitting Section 4) • Target: Transformation is applied to t (can only be used during the training phase since labels are not shown to the model at test time)• Generic: Applicable to all data domains • Domain-specific: Specific (handcrafted) for the problem at hand, for example image rotationsDependence of the distribution of θ• p(θ): distribution of θ is the same for all samples • p(θ|t): distribution of θ can be different for each target (class)• p(θ|t ′ ): distribution of θ depends on desired (fake) target t ′• p(θ|x): distribution of θ can be different for each input vector (with implicit depen- dence on f and w if the transformation is in hidden-feature space) • p(θ|D): distribution of θ depends on the whole training dataset• p(θ|x): distribution of θ depends on a batch of training inputs (for example (parts of) the current mini-batch, or also previous mini-batches) • p(θ|time): distribution of θ depends on time (current training iteration)• p(θ|π): distribution of θ depends on some trainable parameters π subject to loss minimization (i.e. the parameters π evolve during training along with the network weights w) • Combinations of the above, e.g. A review of existing methods that use generic transformations can be found in Table 1. Dropout in its original form Srivastava et al., 2014) is one of the most popular methods from the generic group, but also several variants of Dropout have been proposed that provide additional theoretical motivation and improved empirical results (Standout ( Ba and Frey, 2013), Random dropout probability ( Bouthillier et al., 2015), Bayesian dropout (Maeda, 2014), Test-time dropout (Gal and Ghahramani, 2016)). Table 2 contains a list of some domain-specific methods focused especially on the image domain. Here the most used method is rigid and elastic image deformation.Target-preserving data augmentation In the following, we discuss an important group of methods: target-preserving data augmentation. These methods use stochastic transfor- mations in input and hidden-feature spaces, while preserving the original target t. As can be seen in the respective two columns in Tables 1-2, most of the listed methods have exactly these properties. These methods transform the training set to a distribution Q, which is used for training instead. In other words, the training samples (x i , t i ) ∈ D are replaced in the empirical risk loss function (Eq. (3)) by augmented training samples (τ θ (x i ), t i ) ∼ Q. By randomly sampling the transformation parameters θ and thus creating many new sam- ples (τ θ (x i ), t i ) from each original training sample (x i , t i ), data augmentation attempts to bridge the limited-data gap between the expected and the empirical risk, Eqs. (2)-(3). While unlimited sampling from Q provides more data than the original dataset D, both of them usually are merely approximations of the ground truth data distribution or of an ideal train- ing dataset; both D and Q have their own distinct biases, advantages and disadvantages. For example, elastic image deformations result in images that are not perfectly realistic; this is not necessarily a disadvantage, but it is a bias compared to the ground truth data distribution; in any case, the advantages (having more training data) often prevail. In some cases, it may be even desired for Q to be deliberately different from the ground truth data   Table 2: Existing domain-specific data-based methods classified according to our taxonomy. Table columns are described in Section 3. Note that these methods are never applied on the hidden features, because domain knowledge cannot be applied on them.distribution. For example, in case of class imbalance (unbalanced abundance or importance of classes), a common regularization strategy is to undersample or oversample the data, sometimes leading to a less realistic Q but better models. This is how an ideal training dataset may be different from the ground truth data distribution.If the transformation is additionally representation-preserving, then the distribution Q created by the transformation τ θ attempts to mimic the ground truth data distribution P . Otherwise, the notion of a "ground truth data distribution" in the modified representation may be vague. We provide more details about the transition from D to Q in Appendix B.Summary of data-based methods Data-based regularization is a popular and very useful way to improve the results of deep learning. In this section we formalized this group of methods and showed that seemingly unrelated techniques such as Target-preserving data augmentation, Dropout, or Batch normalization are methodologically surprisingly close to each other. In Section 8 we discuss future directions that we find promising.A network architecture f can be selected to have certain properties or match certain as- sumptions in order to have a regularizing effect.Assumptions about the mapping An input-output mapping f w must have certain properties in order to fit the data P well. Although it may be intractable to enforce the precise properties of an ideal mapping, it may be possible to approximate them by simplified assumptions about the mapping. These properties and assumptions can then be imposed upon model fitting in a hard or soft manner. This limits the search space of models and allows finding better solutions. An example is the decision about the number of layers andMethod class Assumptions about an appropriate learnable input-output mapping Any chosen (not overly complex) architecture * Mapping can be well approximated by functions from the chosen family which are easily accessible by optimization.Small network * Mapping is simple (complexity of the mapping depends on the number of network units and layers).Deep network * The mapping is complex, but can be decomposed into a composition (or generally into a directed acyclic graph) of simple nonlinear transformations, e.g. affine transformation followed by simple nonlinearity (fully-connected layer), "multi-channel convolution" followed by simple nonlinearity (convo- lutional layer), etc.Hard bottleneck (layer with few neurons); soft bottleneck (e.g. Jacobian penalty ( Rifai et al., 2011c), see Section 6)Layer operation Data concentrates around a lower-dimensional manifold; has few factors of variation.Convolutional networks (Fukushima and Miyake, 1982;Rumelhart et al., 1986, pp. 348-352;LeCun et al., 1989;Simard et al., 2003) Layer operation Spatially local and shift-equivariant feature extraction is all we need.Layer operation Like convolutional networks. Additionally: Sparse sampling of wide local neighborhoods provides relevant information, and better preserves rele- vant high-resolution information than architectures with downscaling and upsampling.Strided convolutions (see Dumoulin and Visin, 2016) Layer operation The mapping is reliable at reacting to features that do not vary too abruptly in space, i.e. which are present in several neighboring pixels and can be detected even if the filter center skips some of the pixels. The out- put is robust towards slight changes of the location of features, and changes of strength/presence of spatially strongly varying features.Layer operation The output is invariant to slight spatial distortions of the input (slight changes of the location of (deep) features  units, which allows the mapping to be neither too simple nor too complex (thus avoiding underfitting and overfitting). Another example are certain invariances of the mapping, such as locality and shift-equivariance of feature extraction hardwired in convolutional layers. Overall, the approach of imposing assumptions about the input-output mapping discussed in this section is the selection of the network architecture f . The choice of architecture f on the one hand hardwires certain properties of the mapping; additionally, in an interplay between f and the optimization algorithm (Section 7), certain weight configurations are more likely accessible by optimization than others, further limiting the likely search space in a soft way. A complementary way of imposing certain assumptions about the mapping are regularization terms (Section 6), as well as invariances present in the (augmented) data set (Section 3).Assumptions can be hardwired into the definition of the operation performed by certain layers, and/or into the connections between layers. This distinction is made in Table 3, where these and other methods are listed.In Section 3 about data, we mentioned regularization methods that transform data in the hidden-feature space. They can be considered part of the architecture. In other words, they fit both Sections 3 (data) and 4 (architecture). These methods are listed in Table 1 with hidden features as their transformation space.Weight sharing Reusing a certain trainable parameter in several parts of the network is referred to as weight sharing. This usually makes the model less complex than using separately trainable parameters. An example are convolutional networks ( LeCun et al., 1989). Here the weight sharing does not merely reduce the number of weights that need to be learned; it also encodes the prior knowledge about the shift-equivariance and locality of feature extraction. Another example is weight sharing in autoencoders.Activation functions Choosing the right activation function is quite important; for ex- ample, using Rectified linear units (ReLUs) improved the performance of many deep ar- chitectures both in the sense of training times and accuracy (Jarrett et al., 2009;Nair and Hinton, 2010;Glorot et al., 2011). The success of ReLUs can be attributed to the fact that they help avoiding the vanishing gradient problem, but also to the fact that they provide more expressive families of mappings (the classical sigmoid nonlinearity can be approxi- mated very well 2 with only two ReLUs, but it takes an infinite number of sigmoid units to approximate a ReLU) and their affine extrapolation to unknown regions of data space seems to provide better generalization in practice than the "stagnating" extrapolation of sigmoid units. Some activation functions were designed explicitly for regularization. For Dropout, Maxout units ( Goodfellow et al., 2013) allow a more precise approximation of the geometric mean of the model ensemble predictions at test time. Stochastic pooling (Zeiler and Fergus, 2013), on the other hand, is a noisy version of max-pooling. The authors claim that this allows modelling distributions of activations instead of taking just the maximum.Noisy models Stochastic pooling was one example of a stochastic generalization of a deterministic model. Some models are stochastic by injecting random noise into various parts of the model. The most frequently used noisy model is Dropout ( Hinton et al., 2012;Srivastava et al., 2014).Multi-task learning A special type of regularization is multi-task learning (see Caruana, 1998;Ruder, 2017). It can be combined with semi-supervised learning to utilize unlabeled data on an auxiliary task ( Rasmus et al., 2015). A similar concept of sharing knowledge between tasks is also utilized in meta-learning, where multiple tasks from the same domain are learned sequentially, using previously gained knowledge as bias for new tasks (Baxter, 2000); and transfer learning, where knowledge from one domain is transferred into another domain (Pan and Yang, 2010).Model selection The best among several trained models (e.g. with different architec- tures) can be selected by evaluating the predictions on a validation set. It should be noted that this holds for selecting the best combination of all techniques (Sections 3-7), not just architecture; and that the validation set used for model selection in the "outer loop" should be different from the validation set used e.g. for Early stopping (Section 7), and differ- ent from the test set (Cawley and Talbot, 2010). However, there are also model selection methods that specifically target the selection of the number of units in a specific network ar- chitecture, e.g. using network growing and network pruning (see Bishop, 1995a, Sec. 9.5), or additionally do not require a validation set, e.g. the Network information criterion to com- pare models based on the training error and second derivatives of the loss function ( Murata et al., 1994).Ideally, the error function E reflects an appropriate notion of quality, and in some cases some assumptions about the data distribution. Typical examples are mean squared error or cross-entropy. The error function E can also have a regularizing effect. An example is Dice coefficient optimization ( Milletari et al., 2016) which is robust to class imbalance. Moreover, the overall form of the loss function can be different than Eq. (3). For example, in certain loss functions that are robust to class imbalance, the sum is taken over pairwise combinations D×D of training samples ( Yan et al., 2003), rather than over training samples. But such alternatives to Eq. (3) are rather rare, and similar principles apply. If additional tasks are added for a regularizing effect (multi-task learning (see Caruana, 1998;Ruder, 2017)), then targets t are modified to consist of several tasks, the mapping f w is modified to produce an according output y, and E is modified to account for the modified t and y. Besides, there are regularization terms that depend on ∂E/∂x. They depend on t and thus in our definition are considered part of E rather than of R, but they are listed in Section 6 among R (rather than here) for a better overview.Regularization can be achieved by adding a regularizer R into the loss function. Unlike the error function E (which expresses consistency of outputs with targets), the regularization term is independent of the targets. Instead, it is used to encode other properties of the desired model, to provide inductive bias (i.e. assumptions about the mapping other than consistency of outputs with targets). The value of R can thus be computed for an unlabeled test sample, whereas the value of E cannot.The independence of R from t has an important implication: it allows additionally using unlabeled samples (semi-supervised learning) to improve the learned model based on its compliance with some desired properties ( Sajjadi et al., 2016). For example, semi-supervised learning with ladder networks (Rasmus et al., 2015) combines a supervised task with an unsupervised auxiliary denoising task in a "multi-task" learning fashion. (For alternative interpretations, see Appendix A.) Unlabeled samples are extremely useful when labeled samples are scarce. A Bayesian perspective on the combination of labeled and unlabeled data in a semi-supervised manner is offered by Lasserre et al. (2006).A classical regularizer is weight decay (see Plaut et al., 1986;Lang and Hinton, 1990; Good- fellow et al., 2016, Chap. 7):where λ is a weighting term controlling the importance of the regularization over the con- sistency. From the Bayesian perspective, weight decay corresponds to using a symmetric multivariate normal distribution as prior for the weights: p(w) = N (w|0, λ −1 I) (Nowlan and Hinton, 1992). Indeed, − log N (w|0, λ −1 I) ∝ − log exp − λ λ 2 2 2 2 = 2 2 = R(w). Weight decay has gained big popularity, and it is being successfully used; Krizhevsky et al. (2012) even observe reduction of the error on the training set.Another common prior assumption that can be expressed via the regularization term is "smoothness" of the learned mapping (see Bengio et al., 2013, Section 3.2): if x 1 ≈ x 2 , then f w (x 1 ) ≈ f w (x 2 ). It can be expressed by the following loss term:where F denotes the Frobenius norm, and J fw (x) is the Jacobian of the neural network input-to-output mapping f w for some fixed network weights w. This term penalizes map- pings with large derivatives, and is used in contractive autoencoders ( Rifai et al., 2011c).The domain of loss regularizers is very heterogeneous. We propose a natural way to cat- egorize them by their dependence. We saw in Eq. (5) that weight decay depends on w only, whereas the Jacobian penalty in Eq. (6) depends on w, f , and x. More precisely, the Jacobian penalty uses the derivative ∂y/∂x of output y = f w (x) w.r.t. input x. (We use vector-by-vector derivative notation from matrix calculus, i.e. ∂y/∂x = ∂f w (x)/∂x = J fw is the Jacobian of f w with fixed weights w.) We identify the following dependencies of R:• Dependence on the weights w • Dependence on the network output y = f w (x)• Dependence on the derivative ∂y/∂w of the output y = f w (x) w.r.t. the weights w • Dependence on the derivative ∂y/∂x of the output y = f w (x) w.r.t. the input x • Dependence on the derivative ∂E/∂x of the error term E w.r.t. the input x (E de- pends on t, and according to our definition such methods belong to Section 5, but they are listed here for overview)A review of existing methods can be found in Table 4. Weight decay seems to be still the most popular of the regularization terms. Some of the methods are equivalent or nearly equivalent to other methods from different taxonomy branches. For example, Tangent prop simulates minimal data augmentation (Simard et al., 1992); Injection of small-variance Gaussian noise (Bishop, 1995b;An, 1996) is an approximation of Jacobian penalty ( Rifai et al., 2011c); and Fast dropout ( Wang and Manning, 2013) is (in shallow networks) a deterministic approximation of Dropout. This is indicated in the Equivalence column in Table 4.The last class of the regularization methods according to our taxonomy is the regularization through optimization. Stochastic gradient descent (SGD) (see Bottou, 1998) (along with its derivations) is the most frequently used optimization algorithm in the context of deep neural networks and is the center of our attention. We also list some alternative methods below.Stochastic gradient descent is an iterative optimization algorithm using the following update rule:where ∇L(w t , d t ) is the gradient of the loss L evaluated on a mini-batch d t from the training set D. It is frequently used in combination with momentum and other tweaks improving the convergence speed (see Wilson et al., 2017). Moreover, the noise induced by the varying mini-batches helps the algorithm escape saddle points (Ge et al., 2015); this can be further reinforced by adding supplementary gradient noise ( Neelakantan et al., 2015;Chaudhari and Soatto, 2015).If the algorithm reaches a low training error in a reasonable time (linear in the size of the training set, allowing multiple passes through D), the solution generalizes well under certain mild assumptions; in that sense SGD works as an implicit regularizer : a short training time prevents overfitting even without any additional regularizer used (Hardt et al., 2016). This is in line with ( Zhang et al., 2017) who find in a series of experiments that regularization (such as Dropout, data augmentation, and weight decay) is by itself neither necessary nor sufficient for good generalization. Weight decay (see Plaut et al., 1986;Lang and Hinton, 1990;Goodfellow et al., 2016, Chap. 7) L 2 norm on network weights (not biases).Favors smaller weights, thus for usual architectures tends to make the mapping less "extreme", more robust to noise in the input.Weight smoothing (Lang and Hinton, 1990  Gaussians (Nowlan and Hinton, 1992;Blundell et al., 2015) Weights come from two Gaussians, a narrow and a broad one. Special case of Soft weight-sharing.Fast dropout approximation ( Wang and Manning, 2013) Approximates the loss that dropout minimizes.Weighted L 2 weight penalty. Only for shallow networks.Mutual exclusivity ( Sajjadi et al., 2016) Unlabeled samples push decision boundaries to low-density regions in input space, promoting sharp (con- fident) predictions.  Penalty for sharp minima, i.e. for weight configurations where small weight perturbation leads to high error increase. Flat minima have low Minimum description length (i.e. exhibit ideal balance between training error and model complex- ity) and thus should generalize bet- ter (Rissanen, 1986).Tangent prop (Simard et al., 1992) L 2 penalty on directional derivative of mapping in the predefined tan- gent directions that correspond to known input-space transformations.Simple data augmentation Jacobian penalty ( Rifai et al., 2011c) L 2 penalty on the Jacobian of (parts of) the network mapping- smoothness prior.Noise on inputs injection (not exact (see An, 1996)) Manifold tangent classifier ( Rifai et al., 2011a) Like tangent prop, but the input "tangent" directions are extracted from manifold learned by a stack of contractive autoencoders and then performing SVD of the Jacobian at each input sample.     Table 4: Regularization terms, with dependencies marked by ✖. Methods that depend on ∂E/∂x implicitly depend on targets t and thus can be considered part of the error function (Section 5) rather than regularization term (Section 6).We divide the methods into three groups: initialization/warm-start methods, update meth- ods, and termination methods, discussed in the following.Initialization and warm-start methods These methods affect the initial selection of the model weights. Currently the most frequently used method is sampling the initial weights from a carefully tuned distribution. There are multiple strategies based on the architecture choice, aiming at keeping the variance of activations in all layers around 1, thus preventing vanishing or exploding activations (and gradients) in deeper layers (Glorot and Bengio, 2010, Sec. 4.2;He et al., 2015).Another (complementary) option is pre-training on different data, or with a different objec- tive, or with partially different architecture. This can prime the learning algorithm towards a good solution before the fine-tuning on the actual objective starts. Pre-training the model on a different task in the same domain may lead to learning useful features, making the pri- mary task easier. However, pre-trained models are also often misused as a lazy approach to problems where training from scratch or using thorough domain adaptation, transfer learn- ing, or multi-task learning methods would be worth trying. On the other hand, pre-training or similar techniques may be a useful part of such methods.Finally, with some methods such as Curriculum learning ( Bengio et al., 2009), the transition between pre-training and fine-tuning is smooth. We refer to them as warm-start methods.• Initialization without pre-training -Random weight initialization (Rumelhart et al., 1986, p. 330;Glorot and Bengio, 2010;He et al., 2015;Hendrycks and Gimpel, 2016) -Orthogonal weight matrices ( Saxe et al., 2013) -Data-dependent weight initialization ( Krähenbühl et al., 2015) • Initialization with pre-training -Greedy layer-wise pre-training ( Hinton et al., 2006;Bengio et al., 2007;Erhan et al., 2010) (has become less important due to advances (e.g. ReLUs) in effective end-to-end training that optimizes all parameters simultaneously) -Curriculum learning ( Bengio et al., 2009) -Spatial contrasting (Hoffer et al., 2016) -Subtask splitting ( Gülçehre and Bengio, 2016) Update methods This class of methods affects individual weight updates. There are two complementary subgroups: Update rules modify the form of the update formula; Weight and gradient filters are methods that affect the value of the gradient or weights, which are used in the update formula, e.g. by injecting noise into the gradient ( Neelakantan et al., 2015).Again, it is not entirely clear which of the methods only speed up the optimization and which actually help the generalization. Wilson et al. (2017) show that some of the methods such as AdaGrad or Adam even lose the regularization abilities of SGD.• Update rules  -Annealed noise on targets ( Wang and Principe, 1999) (works as noise on gra- dient, but belongs rather to data-based methods, Section 3) Termination methods There are numerous possible stopping criteria and selecting the right moment to stop the optimization procedure may improve the generalization by reducing the error caused by the discrepancy between the minimizers of expected and empirical risk:The network first learns general concepts that work for all samples from the ground truth distribution P before fitting the specific sample D and its noise ( Krueger et al., 2017).The most successful and popular termination methods put a portion of the labeled data aside as a validation set and use it to evaluate performance (validation error ). The most prominent example is Early stopping (see Prechelt, 1998). In scenarios where the training data are scarce it is possible to resort to termination methods that do not use a validation set. The simplest case is fixing the number of passes through the training set.• Termination using a validation set -Early stopping (see Morgan and Bourlard, 1990;Prechelt, 1998) -Choice of validation set size based on test set size ( Amari et al., 1997) • Termination without using a validation set -Fixed number of iterations -Optimized approximation algorithm ( Liu et al., 2008) 8 Recommendations, discussion, conclusionsWe see the main benefits of our taxonomy to be two-fold: Firstly, it provides an overview of the existing techniques to the users of regularization methods and gives them a better idea of how to choose the ideal combination of regularization techniques for their problem. Secondly, it is useful for development of new methods, as it gives a comprehensive overview of the main principles that can be exploited to regularize the models. We summarize our recommendations in the following paragraphs:Recommendations for users of existing regularization methods Overall, using the information contained in data as well as prior knowledge as much as possible, and primarily starting with popular methods, the following procedure can be helpful:• Common recommendations for the first steps:-Deep learning is about disentangling the factors of variation. An appropriate data representation should be chosen; known meaningful data transformations should not be outsourced to the learning. Redundantly providing the same information in several representations is okay. -Output nonlinearity and error function should reflect the learning goals.-A good starting point are techniques that usually work well (e.g. ReLU, success- ful architectures). Hyperparameters (and architecture) can be tuned jointly, but "lazily" (interpolating/extrapolating from experience instead of trying too many combinations). -Often it is helpful to start with a simplified dataset (e.g. fewer and/or easier samples) and a simple network, and after obtaining promising results gradually increasing the complexity of both data and network while tuning hyperparam- eters and trying regularization methods.• Regularization via data:-When not working with nearly infinite/abundant data: * Gathering more real data (and using methods that take its properties into account) is advisable if possible: · Labeled samples are best, but unlabeled ones can also be helpful (com- patible with semi-supervised learning). · Samples from the same domain are best, but samples from similar do- mains can also be helpful (compatible with domain adaptation and trans- fer learning). · Reliable high-quality samples are best, but lower-quality ones can also be helpful (their confidence/importance can be adjusted accordingly). · Labels for an additional task can be helpful (compatible with multi-task learning). · Additional input features (from additional information sources) and/or data preprocessing (i.e. domain-specific data transformations) can be helpful (the network architecture needs to be adjusted accordingly). * Data augmentation (e.g. target-preserving handcrafted domain-specific transformations) can well compensate for limited data. If natural ways to augment data (to mimic natural transformations sufficiently well) are known, they can be tried (and combined). * If natural ways to augment data are unknown or turn out to be insufficient, it may be possible to infer the transformation from data (e.g. learning image- deformation fields) if a sufficient amount of data is available for that. -Popular generic methods (e.g. advanced variants of Dropout) often also help.• Architecture and regularization terms:-Knowledge about possible meaningful properties of the mapping can be used to e.g. hardwire invariances (to certain transformations) into the architecture, or be formulated as regularization terms. -Popular methods may help as well (see Tables 3-4), but should be chosen to match the assumptions about the mapping (e.g. convolutional layers are fully appropriate only if local and shift-equivariant feature extraction on regular-grid data is desired).• Optimization:-Initialization: Even though pre-trained ready-made models greatly speed up prototyping, training from a good random initialization should also be consid- ered. -Optimizers: Trying a few different ones, including advanced ones (e.g. Nesterov momentum, Adam, ProxProp), may lead to improved results. Correctly chosen parameters, such as learning rate, usually make a big difference.Recommendations for developers of novel regularization methods Getting an overview and understanding the reasons for the success of the best methods is a great foundation. Promising empty niches (certain combinations of taxonomy properties) exist that can be addressed. The assumptions to be imposed upon the model can have a strong impact on most elements of the taxonomy. Data augmentation is more expressive than loss terms (loss terms enforce properties only in infinitesimally small neighborhood of the training samples; data augmentation can use rich transformation parameter distributions).Data and loss terms impose assumptions and invariances in a rather soft manner, and their influence can be tuned, whereas hardwiring the network architecture is a harsher way to impose assumptions. Different assumptions and options to impose them have different advantages and disadvantages.Future directions for data-based methods There are several promising directions that in our opinion require more investigation: Adaptive sampling of θ might lead to lower errors and shorter training times (Fawzi et al., 2016) (in turn, shorter training times may additionally work as implicit regularization (Hardt et al., 2016), see also Section 7). Sec- ondly, learning class-dependent transformations (i.e. p(θ|t)) in our opinion might lead to more plausible samples. Furthermore, the field of adversarial examples (and network ro- bustness to them) is gaining increased attention after the recently sparked discussion on real-world adversarial examples and their robustness/invariance to transformations such as the change of camera position ( Lu et al., 2017;Athalye and Sutskever, 2017). Countering strong adversarial examples may require better regularization techniques.Summary In this work we proposed a broad definition of regularization for deep learn- ing, identified five main elements of neural network training (data, architecture, error term, regularization term, optimization procedure), described regularization via each of them, including a further, finer taxonomy for each, and presented example methods from these subcategories. Instead of attempting to explain referenced works in detail, we merely pin- pointed their properties relevant to our categorization. Our work demonstrates some links between existing methods. Moreover, our systematic approach enables the discovery of new, improved regularization methods by combining the best properties of the existing ones.Zhang, C., Bengio, S., Hardt, M., Recht, B., and Vinyals, O. (2017). Understanding deep learning requires rethinking generalization. In Proceedings of the International Conference on Learning Representations (ICLR). (ˆ10)A Ambiguities in the taxonomy Although our proposed taxonomy seems intuitive, there are some ambiguities: Certain methods have multiple interpretations matching various categories. Viewed from the exterior, a neural network maps inputs x to outputs y.We formulate this as y = fw(τ θ (x)) for transformations τ θ in input space (and similarly for hidden-feature space, where τ θ is applied in between layers of the network fw). However, how to split this x-to-y mapping into "the τ θ part" and "the fw part", and thus into Section 3 vs. Section 4, is ambiguous and up to one's taste and goals. In our choices (marked with " below), we attempt to use common notions and Occam's razor.• Ambiguity of attributing noise to f , or to w, or to data transformations τ θ :-Stochastic methods such as Stochastic depth (Huang et al., 2016b) can have several interpretations if stochastic transformations are allowed for f or w:Stochastic transformation of the architecture f (randomly dropping some connections), Table 3 Stochastic transformation of the weights w (setting some weights to 0 in a certain random pattern)Stochastic transformation τ θ of data in hidden-feature space; dependence is p(θ), described in Table 1 for completeness• Ambiguity of splitting τ θ into τ and θ:-Dropout: Parameters θ are the dropout mask; dependence is p(θ); transformation τ applies the dropout mask to the hidden features Parameters θ are the seed state of a pseudorandom number generator; dependence is p(θ); transformation τ internally generates the random dropout mask from the random seed and applies it to the hidden features -Projecting dropout noise into input space (Bouthillier et al., 2015, Sec. 3) can fit our taxonomy in different ways by defining τ and θ accordingly. It can have similar interpretations as Dropout above (if τ is generalized to allow for dependence on x, f, w), but we prefer the third interpretation without such generalizations:Parameters θ are the dropout mask (to be applied in a hidden layer); dependence is p(θ); transformation τ transforms the input to mimic the effect of the mask Parameters θ are the seed state of a pseudorandom number generator; dependence is p(θ); transformation τ internally generates the random dropout mask from the random seed and transforms the input to mimic the effect of the mask Parameters θ describe the transformation of the input in any formulation; dependence is p(θ|x, f, w); transformation τ merely applies the transformation in input space• Ambiguity of splitting the network operation fw into layers: There are several possibilities to represent a function (neural network) as a composition (or directed acyclic graph) of functions (layers).• Many of the input and hidden-feature transformations (Section 3) can be considered layers of the network (Section 4). In fact, the term "layer" is not uncommon for Dropout or Batch normalization.• The usage of a trainable parameter in several parts of the network is called weight sharing. However, some mappings can be expressed with two equivalent formulas such that a parameter appears only once in one formulation, and several times in the other.• Ambiguity of E vs. R: Auxiliary denoising task in ladder networks ( Rasmus et al., 2015) and similar autoencoder-style loss terms can be interpreted in different ways:Regularization term R without given auxiliary targets tThe ideal reconstructions can be considered as targets t (if the definition of "targets" is slightly modified) and thus the denoising task becomes part of the error term ETo understand the success of target-preserving data augmentation methods, we consider the data-augmented loss function, which we obtain by replacing the training samples (xi, ti) ∈ D in the empirical risk loss function (Eq. (3)) by augmented training samples (τ θ (xi), ti): Since q is non-negative and q(x, t) dx dt = 1, it is a valid probability density function inducing the distribution Q of augmented data. Therefore, ˆ LA = E (x,t)∼Q ℓ(x, t) .When Q = P , Eq. (11) becomes the expected risk (2). We can show how this is related to importance sampling: = E (x,t)∼Q ℓ(x, t) p(x, t) q(x, t)The difference between L andˆLAandˆ andˆLA is the re-weighting term p(x, t)/q(x, t) identical to the one known from importance sampling (see Bishop, 1995a). The more similar Q is to P (i.e. the closer Q models the ground truth distribution P ), the more similar the augmented-data lossˆLAlossˆ lossˆLA is to the expected loss L. We see that data augmentation tries to simulate the real distribution P by creating new samples from the training set D, bridging the gap between the expected and the empirical risk.
